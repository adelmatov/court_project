################################################################################
#
#                    –°–ë–û–†–ö–ê –ö–û–î–ê –ü–ê–†–°–ï–†–ê –°–£–î–ï–ë–ù–´–• –î–ï–õ
#
################################################################################
#
# –î–∞—Ç–∞ —Å–±–æ—Ä–∫–∏: 2025-12-05 20:00:17
# 
# ‚ö†Ô∏è  –í–ê–ñ–ù–û: –≠–¢–û –ù–ï –ò–°–ü–û–õ–ù–Ø–ï–ú–´–ô –§–ê–ô–õ!
#
# –≠—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –≤–µ—Å—å –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞ court_parser,
# —Å–æ–±—Ä–∞–Ω–Ω—ã–π –∏–∑ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –º–æ–¥—É–ª–µ–π –≤ –æ–¥–∏–Ω —Ñ–∞–π–ª –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –∞–Ω–∞–ª–∏–∑–∞.
#
# –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ:
#   - –ü—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –ò–ò –ø–æ–ª–Ω—É—é –∫–∞—Ä—Ç–∏–Ω—É –∫–æ–¥–æ–≤–æ–π –±–∞–∑—ã
#   - –£–ø—Ä–æ—Å—Ç–∏—Ç—å code review –∏ –∞–Ω–∞–ª–∏–∑ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã
#   - –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞
#
# –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞:
#   parsers/court_parser/
#   ‚îú‚îÄ‚îÄ utils/          - –£—Ç–∏–ª–∏—Ç—ã (–ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ, retry, –≤–∞–ª–∏–¥–∞—Ü–∏—è)
#   ‚îú‚îÄ‚îÄ config/         - –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
#   ‚îú‚îÄ‚îÄ auth/           - –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–∞ —Å–∞–π—Ç–µ
#   ‚îú‚îÄ‚îÄ database/       - –†–∞–±–æ—Ç–∞ —Å PostgreSQL
#   ‚îú‚îÄ‚îÄ parsing/        - –ü–∞—Ä—Å–∏–Ω–≥ HTML
#   ‚îú‚îÄ‚îÄ search/         - –ü–æ–∏—Å–∫–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã
#   ‚îú‚îÄ‚îÄ core/           - –ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å –ø–∞—Ä—Å–µ—Ä–∞
#   ‚îî‚îÄ‚îÄ main.py         - –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞
#
# –î–ª—è –∑–∞–ø—É—Å–∫–∞ –ø–∞—Ä—Å–µ—Ä–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã:
#   python parsers/court_parser/main.py
#
################################################################################



################################################################################
# –í–°–¢–†–û–ï–ù–ù–´–ï –†–ï–°–£–†–°–´ (config.json –∏ –¥—Ä.)
################################################################################


# --- config.json ---

# {
#   "auth": {
#     "login": "941208351468",
#     "password": "1234Poker!",
#     "user_name": "–î–ï–õ–¨–ú–ê–¢–û–í –ê–õ–ú–ê–ó –£–†–ê–ó–ì–ê–õ–ò–ï–í–ò–ß"
#   },
#   "base_url": "https://office.sud.kz",
#   "database": {
#     "dbname": "court",
#     "user": "postgres",
#     "password": "admin",
#     "host": "localhost",
#     "port": 5432
#   },
#   "parsing_settings": {
#     "year": "2025",
#     "court_types": [
#       "appellate"
#     ],
#     "start_from": 1,
#     "max_number": 9999,
#     "max_consecutive_empty": 5,
#     "max_consecutive_failures": 5,
#     "max_parallel_regions": 3,
#     "delay_between_requests": 0,
#     "region_retry_max_attempts": 3,
#     "region_retry_delay_seconds": 5,
#     "limit_regions": null,
#     "limit_cases_per_region": null,
#     "target_regions": null
#   },
#   "regions": {
#     "astana": {
#       "id": "2",
#       "name": "–≥–æ—Ä–æ–¥ –ê—Å—Ç–∞–Ω–∞",
#       "kato_code": "71",
#       "courts": {
#         "smas": {
#           "id": "413",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –≥–æ—Ä–æ–¥–∞ –ê—Å—Ç–∞–Ω—ã",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "2",
#           "name": "–°—É–¥ –≥–æ—Ä–æ–¥–∞ –ê—Å—Ç–∞–Ω—ã",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "almaty": {
#       "id": "3",
#       "name": "–≥–æ—Ä–æ–¥ –ê–ª–º–∞—Ç—ã",
#       "kato_code": "75",
#       "courts": {
#         "smas": {
#           "id": "414",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –≥–æ—Ä–æ–¥–∞ –ê–ª–º–∞—Ç—ã",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "13",
#           "name": "–ê–ª–º–∞—Ç–∏–Ω—Å–∫–∏–π –≥–æ—Ä–æ–¥—Å–∫–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "shymkent": {
#       "id": "19",
#       "name": "–≥–æ—Ä–æ–¥ –®—ã–º–∫–µ–Ω—Ç",
#       "kato_code": "52",
#       "courts": {
#         "smas": {
#           "id": "415",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –≥–æ—Ä–æ–¥–∞ –®—ã–º–∫–µ–Ω—Ç–∞",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "383",
#           "name": "–°—É–¥ –≥–æ—Ä–æ–¥–∞ –®—ã–º–∫–µ–Ω—Ç–∞",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "akmola": {
#       "id": "4",
#       "name": "–ê–∫–º–æ–ª–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "11",
#       "courts": {
#         "smas": {
#           "id": "416",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ê–∫–º–æ–ª–∏–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "29",
#           "name": "–ê–∫–º–æ–ª–∏–Ω—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "aktobe": {
#       "id": "5",
#       "name": "–ê–∫—Ç—é–±–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "15",
#       "courts": {
#         "smas": {
#           "id": "417",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ê–∫—Ç—é–±–∏–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "55",
#           "name": "–ê–∫—Ç—é–±–∏–Ω—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "almaty_region": {
#       "id": "6",
#       "name": "–ê–ª–º–∞—Ç–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "19",
#       "courts": {
#         "smas": {
#           "id": "430",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ê–ª–º–∞—Ç–∏–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "93",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "75",
#           "name": "–ê–ª–º–∞—Ç–∏–Ω—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "atyrau": {
#       "id": "7",
#       "name": "–ê—Ç—ã—Ä–∞—É—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "23",
#       "courts": {
#         "smas": {
#           "id": "419",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ê—Ç—ã—Ä–∞—É—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "105",
#           "name": "–ê—Ç—ã—Ä–∞—É—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "vko": {
#       "id": "8",
#       "name": "–í–æ—Å—Ç–æ—á–Ω–æ-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "63",
#       "courts": {
#         "smas": {
#           "id": "420",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –í–æ—Å—Ç–æ—á–Ω–æ-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "119",
#           "name": "–í–æ—Å—Ç–æ—á–Ω–æ-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "zhambyl": {
#       "id": "9",
#       "name": "–ñ–∞–º–±—ã–ª—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "31",
#       "courts": {
#         "smas": {
#           "id": "421",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ñ–∞–º–±—ã–ª—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "158",
#           "name": "–ñ–∞–º–±—ã–ª—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "zko": {
#       "id": "10",
#       "name": "–ó–∞–ø–∞–¥–Ω–æ-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "27",
#       "courts": {
#         "smas": {
#           "id": "422",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ó–∞–ø–∞–¥–Ω–æ-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "175",
#           "name": "–ó–∞–ø–∞–¥–Ω–æ-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "karaganda": {
#       "id": "11",
#       "name": "–ö–∞—Ä–∞–≥–∞–Ω–¥–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "35",
#       "courts": {
#         "smas": {
#           "id": "423",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ö–∞—Ä–∞–≥–∞–Ω–¥–∏–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "199",
#           "name": "–ö–∞—Ä–∞–≥–∞–Ω–¥–∏–Ω—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "kostanay": {
#       "id": "12",
#       "name": "–ö–æ—Å—Ç–∞–Ω–∞–π—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "39",
#       "courts": {
#         "smas": {
#           "id": "424",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ö–æ—Å—Ç–∞–Ω–∞–π—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "237",
#           "name": "–ö–æ—Å—Ç–∞–Ω–∞–π—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "kyzylorda": {
#       "id": "13",
#       "name": "–ö—ã–∑—ã–ª–æ—Ä–¥–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "43",
#       "courts": {
#         "smas": {
#           "id": "425",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ö—ã–∑—ã–ª–æ—Ä–¥–∏–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "266",
#           "name": "–ö—ã–∑—ã–ª–æ—Ä–¥–∏–Ω—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "mangystau": {
#       "id": "14",
#       "name": "–ú–∞–Ω–≥–∏—Å—Ç–∞—É—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "47",
#       "courts": {
#         "smas": {
#           "id": "426",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ú–∞–Ω–≥–∏—Å—Ç–∞—É—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "281",
#           "name": "–ú–∞–Ω–≥–∏—Å—Ç–∞—É—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "pavlodar": {
#       "id": "15",
#       "name": "–ü–∞–≤–ª–æ–¥–∞—Ä—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "55",
#       "courts": {
#         "smas": {
#           "id": "427",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –ü–∞–≤–ª–æ–¥–∞—Ä—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "295",
#           "name": "–ü–∞–≤–ª–æ–¥–∞—Ä—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "sko": {
#       "id": "16",
#       "name": "–°–µ–≤–µ—Ä–æ-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "59",
#       "courts": {
#         "smas": {
#           "id": "428",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –°–µ–≤–µ—Ä–æ-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "316",
#           "name": "–°–µ–≤–µ—Ä–æ-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "turkestan": {
#       "id": "17",
#       "name": "–¢—É—Ä–∫–µ—Å—Ç–∞–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å",
#       "kato_code": "51",
#       "courts": {
#         "smas": {
#           "id": "429",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –¢—É—Ä–∫–µ—Å—Ç–∞–Ω—Å–∫–æ–π –æ–±–ª–∞—Å—Ç–∏",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "340",
#           "name": "–¢—É—Ä–∫–µ—Å—Ç–∞–Ω—Å–∫–∏–π –æ–±–ª–∞—Å—Ç–Ω–æ–π —Å—É–¥",
#           "instance_code": "99",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "ulytau": {
#       "id": "20",
#       "name": "–û–±–ª–∞—Å—Ç—å “∞–ª—ã—Ç–∞—É",
#       "kato_code": "62",
#       "courts": {
#         "smas": {
#           "id": "482",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –æ–±–ª–∞—Å—Ç–∏ “∞–ª—ã—Ç–∞—É",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "476",
#           "name": "–°—É–¥ –æ–±–ª–∞—Å—Ç–∏ “∞–ª—ã—Ç–∞—É",
#           "instance_code": "00",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "abay": {
#       "id": "21",
#       "name": "–û–±–ª–∞—Å—Ç—å –ê–±–∞–π",
#       "kato_code": "10",
#       "courts": {
#         "smas": {
#           "id": "467",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –æ–±–ª–∞—Å—Ç–∏ –ê–±–∞–π",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "456",
#           "name": "–°—É–¥ –æ–±–ª–∞—Å—Ç–∏ –ê–±–∞–π",
#           "instance_code": "00",
#           "case_type_code": "4–∞"
#         }
#       }
#     },
#     "zhetysu": {
#       "id": "22",
#       "name": "–û–±–ª–∞—Å—Ç—å –ñ–µ—Ç—ñ—Å—É",
#       "kato_code": "33",
#       "courts": {
#         "smas": {
#           "id": "450",
#           "name": "–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–∂—Ä–∞–π–æ–Ω–Ω—ã–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—É–¥ –æ–±–ª–∞—Å—Ç–∏ –ñ–µ—Ç—ñ—Å—É",
#           "instance_code": "94",
#           "case_type_code": "4"
#         },
#         "appellate": {
#           "id": "437",
#           "name": "–°—É–¥ –æ–±–ª–∞—Å—Ç–∏ –ñ–µ—Ç—ñ—Å—É",
#           "instance_code": "00",
#           "case_type_code": "4–∞"
#         }
#       }
#     }
#   },
#   "retry_settings": {
#     "http_request": {
#       "max_attempts": 3,
#       "initial_delay": 1.0,
#       "backoff_multiplier": 2.0,
#       "max_delay": 30.0,
#       "jitter": true,
#       "retriable_status_codes": [
#         500,
#         502,
#         503,
#         504
#       ],
#       "retriable_exceptions": [
#         "TimeoutError",
#         "ClientError",
#         "ServerDisconnectedError"
#       ]
#     },
#     "authentication": {
#       "max_attempts": 5,
#       "initial_delay": 2.0,
#       "backoff_multiplier": 2.0,
#       "max_delay": 60.0,
#       "create_new_session": true,
#       "retriable_on_auth_check_fail": true
#     },
#     "search_case": {
#       "max_attempts": 3,
#       "delay": 3.0,
#       "backoff": "linear",
#       "save_failed_html": true
#     },
#     "rate_limit": {
#       "default_wait": 60,
#       "respect_retry_after_header": true,
#       "slow_down_multiplier": 2.0,
#       "slow_down_duration": 600
#     },
#     "circuit_breaker": {
#       "enabled": true,
#       "failure_threshold": 20,
#       "recovery_timeout": 300,
#       "half_open_max_attempts": 3
#     },
#     "session_recovery": {
#       "reauth_on_401": true,
#       "max_reauth_attempts": 2
#     }
#   },
#   "update_settings": {
#     "enabled": true,
#     "update_interval_days": 2,
#     "filters": {
#       "defendant_keywords": [
#         "–¥–æ—Ö–æ–¥"
#       ],
#       "exclude_event_types": [
#         "–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –∞—Ä—Ö–∏–≤",
#         "–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –¥–µ–ª–∞",
#         "–†–µ—à–µ–Ω–∏–µ –≤—Å—Ç—É–ø–∏–ª–æ –≤ —Å–∏–ª—É"
#       ]
#     }
#   },
#   "documents_settings": {
#     "enabled": true,
#     "storage_dir": "./documents",
#     "download_delay": 2.0,
#     "max_per_session": 100,
#     "filters": {
#       "defendant_keywords": [
#         "–¥–æ—Ö–æ–¥"
#       ],
#       "exclude_event_types": [
#         "–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –∞—Ä—Ö–∏–≤",
#         "–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –¥–µ–ª–∞",
#         "–†–µ—à–µ–Ω–∏–µ –≤—Å—Ç—É–ø–∏–ª–æ –≤ —Å–∏–ª—É"
#       ],
#       "check_interval_days": 7
#     }
#   }
# }



################################################################################
# –§–ê–ô–õ: parsers/court_parser/utils/__init__.py
################################################################################


"""
–£—Ç–∏–ª–∏—Ç—ã –ø–∞—Ä—Å–µ—Ä–∞
"""
from utils.logger import setup_logger, get_logger, setup_worker_logger, init_logging
from utils.text_processor import TextProcessor
from utils.validators import DataValidator, ValidationError
from utils.retry import (
    RetryStrategy, 
    RetryConfig, 
    CircuitBreaker,
    RetryableError,
    NonRetriableError,
    CircuitBreakerOpenError
)
from utils.progress import ProgressDisplay, RegionProgress, RegionStatus, CourtProgress
from utils.constants import PartyRole, CaseStatus, HttpStatus
from utils.http_utils import HttpHeaders, ViewStateExtractor, AjaxRequestBuilder
from utils.stats_reporter import StatsReporter, StatsCollector, ReportFormatter


################################################################################
# –§–ê–ô–õ: parsers/court_parser/utils/constants.py
################################################################################


"""
–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
"""


class PartyRole:
    """–†–æ–ª–∏ —Å—Ç–æ—Ä–æ–Ω –≤ –¥–µ–ª–µ"""
    PLAINTIFF = 'plaintiff'
    DEFENDANT = 'defendant'


class CaseStatus:
    """–°—Ç–∞—Ç—É—Å—ã —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –æ–ø–µ—Ä–∞—Ü–∏–π —Å –¥–µ–ª–æ–º"""
    SAVED = 'saved'
    UPDATED = 'updated'
    ERROR = 'error'
    NO_RESULTS = 'no_results'
    TARGET_NOT_FOUND = 'target_not_found'
    REGION_NOT_FOUND = 'region_not_found'
    SAVE_FAILED = 'save_failed'


class HttpStatus:
    """HTTP —Å—Ç–∞—Ç—É—Å—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏"""
    RETRIABLE = frozenset({500, 502, 503, 504})
    NON_RETRIABLE = frozenset({400, 401, 403, 404})


################################################################################
# –§–ê–ô–õ: parsers/court_parser/utils/http_utils.py
################################################################################


# parsers/court_parser/utils/http_utils.py
"""
–û–±—â–∏–µ HTTP —É—Ç–∏–ª–∏—Ç—ã
"""

from typing import Dict, Optional
from selectolax.parser import HTMLParser


class HttpHeaders:
    """–§–∞–±—Ä–∏–∫–∞ HTTP –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤"""
    
    USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
    
    @staticmethod
    def get_base() -> Dict[str, str]:
        """–ë–∞–∑–æ–≤—ã–µ HTTP –∑–∞–≥–æ–ª–æ–≤–∫–∏"""
        return {
            'User-Agent': HttpHeaders.USER_AGENT,
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
        }
    
    @staticmethod
    def get_ajax() -> Dict[str, str]:
        """AJAX –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è RichFaces"""
        headers = HttpHeaders.get_base()
        headers.update({
            'Accept': '*/*',
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            'Faces-Request': 'partial/ajax',
            'X-Requested-With': 'XMLHttpRequest',  # ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ!
        })
        return headers


class ViewStateExtractor:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ ViewState –∏–∑ HTML"""
    
    @staticmethod
    def extract(html: str) -> Optional[str]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ ViewState –∏–∑ HTML"""
        parser = HTMLParser(html)
        viewstate_input = parser.css_first('input[name="javax.faces.ViewState"]')
        
        if viewstate_input and viewstate_input.attributes:
            return viewstate_input.attributes.get('value')
        return None


class AjaxRequestBuilder:
    """–ü–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª—å –¥–∞–Ω–Ω—ã—Ö –¥–ª—è AJAX –∑–∞–ø—Ä–æ—Å–æ–≤ RichFaces"""
    
    @staticmethod
    def build(
        form_id: str,
        ajax_id: str,
        viewstate: str,
        extra_params: Optional[Dict[str, str]] = None
    ) -> Dict[str, str]:
        """
        –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è partial/ajax –∑–∞–ø—Ä–æ—Å–∞
        """
        data = {
            form_id: form_id,
            'javax.faces.ViewState': viewstate,
            'javax.faces.source': ajax_id,
            'javax.faces.partial.execute': f'{ajax_id} @component',
            'javax.faces.partial.render': '@component',
            'org.richfaces.ajax.component': ajax_id,
            ajax_id: ajax_id,
            'rfExt': 'null',
            'AJAX:EVENTS_COUNT': '1',
            'javax.faces.partial.ajax': 'true'
        }
        
        if extra_params:
            data.update(extra_params)
        
        return data


################################################################################
# –§–ê–ô–õ: parsers/court_parser/utils/logger.py
################################################################################


"""
–ü—Ä–æ—Å—Ç–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å —Ü–≤–µ—Ç–Ω—ã–º –≤—ã–≤–æ–¥–æ–º
"""
import logging
import sys
from datetime import datetime
from pathlib import Path
from logging.handlers import RotatingFileHandler


COLORS = {
    'DEBUG': '\033[36m',
    'INFO': '\033[32m',
    'WARNING': '\033[33m',
    'ERROR': '\033[31m',
    'CRITICAL': '\033[35m',
    'RESET': '\033[0m'
}


class ColoredFormatter(logging.Formatter):
    """–§–æ—Ä–º–∞—Ç—Ç–µ—Ä —Å —Ü–≤–µ—Ç–∞–º–∏ –¥–ª—è –∫–æ–Ω—Å–æ–ª–∏"""
    
    def format(self, record):
        time_str = datetime.fromtimestamp(record.created).strftime('%H:%M:%S')
        color = COLORS.get(record.levelname, '')
        reset = COLORS['RESET']
        return f"{color}[{time_str}] {record.levelname}{reset}: {record.getMessage()}"


class FileFormatter(logging.Formatter):
    """–§–æ—Ä–º–∞—Ç—Ç–µ—Ä –¥–ª—è —Ñ–∞–π–ª–∞"""
    
    def format(self, record):
        time_str = datetime.fromtimestamp(record.created).strftime('%Y-%m-%d %H:%M:%S')
        return f"{time_str} [{record.levelname}] {record.name}: {record.getMessage()}"

def setup_logger(
    name: str, 
    log_dir: str = "logs", 
    level: str = "INFO",
    console_output: bool = True
) -> logging.Logger:
    """
    –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞ —Å —Ä–æ—Ç–∞—Ü–∏–µ–π
    
    Args:
        name: –∏–º—è –ª–æ–≥–≥–µ—Ä–∞
        log_dir: –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è –ª–æ–≥–æ–≤
        level: —É—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
        console_output: –≤—ã–≤–æ–¥–∏—Ç—å –ª–∏ –≤ –∫–æ–Ω—Å–æ–ª—å
    """
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    
    if logger.handlers:
        logger.handlers.clear()
    
    Path(log_dir).mkdir(exist_ok=True)
    file_handler = RotatingFileHandler(
        f"{log_dir}/parser.log",
        maxBytes=10 * 1024 * 1024,
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(FileFormatter())
    logger.addHandler(file_handler)
    
    if console_output:
        console = logging.StreamHandler(sys.stdout)
        console.setLevel(getattr(logging, level))
        console.setFormatter(ColoredFormatter())
        logger.addHandler(console)
    
    return logger

def get_logger(name: str) -> logging.Logger:
    """–ü–æ–ª—É—á–∏—Ç—å –ª–æ–≥–≥–µ—Ä"""
    return logging.getLogger(name)

def setup_worker_logger(region_key: str, log_dir: str = "logs") -> logging.Logger:
    """
    –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞ –¥–ª—è –≤–æ—Ä–∫–µ—Ä–∞ —Ä–µ–≥–∏–æ–Ω–∞
    
    –¢–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤—ã–π –≤—ã–≤–æ–¥, –±–µ–∑ –∫–æ–Ω—Å–æ–ª–∏
    """
    return setup_logger(
        name=f'worker_{region_key}',
        log_dir=log_dir,
        level='DEBUG',
        console_output=False
    )

def init_logging(log_dir: str = "logs", level: str = "INFO"):
    setup_logger('main', log_dir, level, console_output=False)
    
    components = [
        'court_parser',
        'authenticator', 
        'db_manager',
        'circuit_breaker',
        'retry_strategy',
        'session_manager',
        'results_parser',
        'data_extractor',
        'document_parser',
        'form_handler',
        'search_engine',
        'document_handler',
        'stats_collector',
        'stats_reporter'
    ]
    
    for component in components:
        setup_logger(component, log_dir, 'DEBUG', console_output=False)


################################################################################
# –§–ê–ô–õ: parsers/court_parser/utils/progress.py
################################################################################


"""
–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞
"""
import asyncio
import sys
from typing import Dict, Optional, List
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum


class RegionStatus(Enum):
    WAITING = "‚è∏Ô∏è"
    ACTIVE = "‚è≥"
    DONE = "‚úÖ"
    ERROR = "‚ùå"


@dataclass
class CourtProgress:
    """–ü—Ä–æ–≥—Ä–µ—Å—Å –æ–¥–Ω–æ–≥–æ —Å—É–¥–∞"""
    saved: int = 0
    queries: int = 0
    consecutive_empty: int = 0
    done: bool = False


@dataclass
class RegionProgress:
    """–ü—Ä–æ–≥—Ä–µ—Å—Å —Ä–µ–≥–∏–æ–Ω–∞ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —Å—É–¥–∞–º–∏"""
    key: str
    name: str
    status: RegionStatus = RegionStatus.WAITING
    courts: Dict[str, CourtProgress] = field(default_factory=dict)
    current_court: str = ""
    start_time: Optional[datetime] = None
    
    def elapsed(self) -> str:
        if not self.start_time:
            return "--:--"
        seconds = int((datetime.now() - self.start_time).total_seconds())
        return f"{seconds // 60}:{seconds % 60:02d}"
    
    def total_saved(self) -> int:
        return sum(c.saved for c in self.courts.values())
    
    def total_queries(self) -> int:
        return sum(c.queries for c in self.courts.values())


class ProgressDisplay:
    """–£–ª—É—á—à–µ–Ω–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å—É–¥–æ–≤"""
    
    def __init__(self, regions: Dict[str, str], court_types: List[str]):
        """
        Args:
            regions: {region_key: display_name}
            court_types: ['smas', 'appellate']
        """
        self.regions: Dict[str, RegionProgress] = {}
        self.court_types = court_types
        
        for key, name in regions.items():
            self.regions[key] = RegionProgress(
                key=key,
                name=self._short_name(name),
                courts={ct: CourtProgress() for ct in court_types}
            )
        
        self.lock = asyncio.Lock()
        self.started = False
        self.finished = False
        self._lines_printed = 0
        self._supports_ansi = self._check_ansi_support()
    
    def _short_name(self, name: str) -> str:
        """–°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –¥–ª–∏–Ω–Ω—ã—Ö –Ω–∞–∑–≤–∞–Ω–∏–π"""
        replacements = {
            '–≥–æ—Ä–æ–¥ ': '',
            '–æ–±–ª–∞—Å—Ç—å': '–æ–±–ª.',
            '–û–±–ª–∞—Å—Ç—å ': '',
            '-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–∞—è': '-–ö–∞–∑.',
            '–í–æ—Å—Ç–æ—á–Ω–æ-–ö–∞–∑.': '–í–ö–û',
            '–ó–∞–ø–∞–¥–Ω–æ-–ö–∞–∑.': '–ó–ö–û',
            '–°–µ–≤–µ—Ä–æ-–ö–∞–∑.': '–°–ö–û',
        }
        for old, new in replacements.items():
            name = name.replace(old, new)
        
        if len(name) > 18:
            name = name[:17] + "‚Ä¶"
        
        return name
    
    def _check_ansi_support(self) -> bool:
        if not sys.stdout.isatty():
            return False
        if sys.platform == 'win32':
            try:
                import os
                os.system('')
                return True
            except:
                return False
        return True
    
    def _move_cursor_up(self, n: int):
        """–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –∫—É—Ä—Å–æ—Ä –≤–≤–µ—Ä—Ö –Ω–∞ n —Å—Ç—Ä–æ–∫"""
        if n > 0 and self._supports_ansi:
            sys.stdout.write(f"\033[{n}A")
    
    def _clear_line(self):
        """–û—á–∏—Å—Ç–∏—Ç—å —Ç–µ–∫—É—â—É—é —Å—Ç—Ä–æ–∫—É"""
        if self._supports_ansi:
            sys.stdout.write("\033[2K\r")
    
    def _write_line(self, text: str):
        """–ó–∞–ø–∏—Å–∞—Ç—å —Å—Ç—Ä–æ–∫—É"""
        self._clear_line()
        sys.stdout.write(text + "\n")
    
    def _get_active_regions(self) -> List[RegionProgress]:
        return [r for r in self.regions.values() if r.status == RegionStatus.ACTIVE]
    
    def _get_done_regions(self) -> List[RegionProgress]:
        return [r for r in self.regions.values() if r.status == RegionStatus.DONE]
    
    def _get_waiting_regions(self) -> List[RegionProgress]:
        return [r for r in self.regions.values() if r.status == RegionStatus.WAITING]
    
    def _get_error_regions(self) -> List[RegionProgress]:
        return [r for r in self.regions.values() if r.status == RegionStatus.ERROR]
    
    def _render(self) -> List[str]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä–æ–∫ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
        lines = []
        
        total_saved = sum(r.total_saved() for r in self.regions.values())
        total_queries = sum(r.total_queries() for r in self.regions.values())
        done_count = len(self._get_done_regions())
        active_count = len(self._get_active_regions())
        error_count = len(self._get_error_regions())
        
        lines.append("‚ïê" * 72)
        
        status_parts = []
        if done_count > 0:
            status_parts.append(f"{done_count}‚úÖ")
        if active_count > 0:
            status_parts.append(f"{active_count}‚è≥")
        if error_count > 0:
            status_parts.append(f"{error_count}‚ùå")
        status_str = " ".join(status_parts) if status_parts else "0"
        
        header = f" –ü–ê–†–°–ò–ù–ì ‚îÇ {status_str} / {len(self.regions)} ‚îÇ {total_saved} —Å–æ—Ö—Ä ‚îÇ {total_queries} –∑–∞–ø—Ä"
        lines.append(header)
        lines.append("‚ïê" * 72)
        
        active = self._get_active_regions()
        if active:
            lines.append("")
            for region in active:
                court_parts = []
                for ct in self.court_types:
                    court = region.courts[ct]
                    ct_label = ct.upper()[:4]
                    
                    if court.done:
                        status = f"‚úì{court.saved}"
                    elif ct == region.current_court:
                        status = f"‚ñ∂{court.saved}"
                        if court.consecutive_empty > 0:
                            status += f"‚åÄ{court.consecutive_empty}"
                    elif court.queries > 0:
                        status = f"{court.saved}"
                    else:
                        status = "‚Äî"
                    
                    court_parts.append(f"{ct_label}:{status}")
                
                courts_str = "  ".join(court_parts)
                line = f" {region.status.value} {region.name:<18} {courts_str:<32} {region.elapsed()}"
                lines.append(line)
            lines.append("")
        
        lines.append("‚îÄ" * 72)
        
        done = self._get_done_regions()
        if done:
            done_items = [f"{r.name}({r.total_saved()})" for r in done[:4]]
            done_str = ", ".join(done_items)
            if len(done) > 4:
                done_str += f" (+{len(done) - 4})"
            lines.append(f" ‚úÖ –ì–æ—Ç–æ–≤–æ: {done_str}")
        
        errors = self._get_error_regions()
        if errors:
            error_names = ", ".join([r.name for r in errors[:3]])
            if len(errors) > 3:
                error_names += f" (+{len(errors) - 3})"
            lines.append(f" ‚ùå –û—à–∏–±–∫–∏: {error_names}")
        
        waiting = self._get_waiting_regions()
        if waiting:
            waiting_names = ", ".join([r.name for r in waiting[:3]])
            if len(waiting) > 3:
                waiting_names += f"‚Ä¶ (+{len(waiting) - 3})"
            lines.append(f" ‚è∏Ô∏è  –û–∂–∏–¥–∞—é—Ç: {waiting_names}")
        
        lines.append("‚ïê" * 72)
        
        return lines
    
    async def update(self, region_key: str, **kwargs):
        """
        –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å —Ä–µ–≥–∏–æ–Ω–∞
        
        Args:
            region_key: –∫–ª—é—á —Ä–µ–≥–∏–æ–Ω–∞
            court: —Ç–µ–∫—É—â–∏–π —Å—É–¥
            saved: —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –¥–µ–ª
            queries: –≤—ã–ø–æ–ª–Ω–µ–Ω–æ –∑–∞–ø—Ä–æ—Å–æ–≤
            consecutive_empty: –ø—É—Å—Ç—ã—Ö –ø–æ–¥—Ä—è–¥
            court_done: —Å—É–¥ –∑–∞–≤–µ—Ä—à—ë–Ω
            status: —Å—Ç–∞—Ç—É—Å —Ä–µ–≥–∏–æ–Ω–∞ (RegionStatus)
        """
        if self.finished:
            return
        
        async with self.lock:
            region = self.regions.get(region_key)
            if not region:
                return
            
            if 'status' in kwargs:
                region.status = kwargs['status']
            
            if 'court' in kwargs:
                region.current_court = kwargs['court']
                if region.status == RegionStatus.WAITING:
                    region.status = RegionStatus.ACTIVE
                    region.start_time = datetime.now()
            
            court_key = kwargs.get('court') or region.current_court
            if court_key and court_key in region.courts:
                court = region.courts[court_key]
                if 'saved' in kwargs:
                    court.saved = kwargs['saved']
                if 'queries' in kwargs:
                    court.queries = kwargs['queries']
                if 'consecutive_empty' in kwargs:
                    court.consecutive_empty = kwargs['consecutive_empty']
                if 'court_done' in kwargs:
                    court.done = kwargs['court_done']
            
            if self.started and self._supports_ansi:
                self._redraw()
    
    def _redraw(self):
        """–ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∞—Ç—å —ç–∫—Ä–∞–Ω"""
        try:
            if self._lines_printed > 0:
                self._move_cursor_up(self._lines_printed)
            
            lines = self._render()
            
            for line in lines:
                self._write_line(line)
            
            self._lines_printed = len(lines)
            sys.stdout.flush()
            
        except Exception:
            # –ú–æ–ª—á–∞ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏, —á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ—Ä—ã–≤–∞—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ—Ü–µ—Å—Å
            pass
    
    async def start(self):
        """–ù–∞—á–∞—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ"""
        async with self.lock:
            self.started = True
            if self._supports_ansi:
                sys.stdout.write("\n")
                self._redraw()
    
    async def finish(self):
        """–ó–∞–≤–µ—Ä—à–∏—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ"""
        async with self.lock:
            self.finished = True
            if self._supports_ansi:
                self._redraw()
            sys.stdout.write("\n")
            sys.stdout.flush()
    
    async def set_region_done(self, region_key: str):
        """–ü–æ–º–µ—Ç–∏—Ç—å —Ä–µ–≥–∏–æ–Ω –∫–∞–∫ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–π"""
        await self.update(region_key, status=RegionStatus.DONE)
    
    async def set_region_error(self, region_key: str):
        """–ü–æ–º–µ—Ç–∏—Ç—å —Ä–µ–≥–∏–æ–Ω –∫–∞–∫ –æ—à–∏–±–æ—á–Ω—ã–π"""
        await self.update(region_key, status=RegionStatus.ERROR)
    
    async def set_court_done(self, region_key: str, court_key: str):
        """–ü–æ–º–µ—Ç–∏—Ç—å —Å—É–¥ —Ä–µ–≥–∏–æ–Ω–∞ –∫–∞–∫ –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–π"""
        await self.update(region_key, court=court_key, court_done=True)


################################################################################
# –§–ê–ô–õ: parsers/court_parser/utils/retry.py
################################################################################


"""
–ì–∏–±–∫–∞—è —Å–∏—Å—Ç–µ–º–∞ retry —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
"""

import asyncio
import random
from typing import Callable, Any, Optional, List, Type
from functools import wraps
from datetime import datetime, timedelta

import aiohttp

from utils.logger import get_logger


class RetryableError(Exception):
    """–û—à–∏–±–∫–∞, –∫–æ—Ç–æ—Ä—É—é –º–æ–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å"""
    pass


class NonRetriableError(Exception):
    """–û—à–∏–±–∫–∞, –∫–æ—Ç–æ—Ä—É—é –Ω–µ–ª—å–∑—è –ø–æ–≤—Ç–æ—Ä–∏—Ç—å"""
    pass


class CircuitBreakerOpenError(Exception):
    """Circuit Breaker –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ OPEN"""
    pass


class RetryConfig:
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è retry"""
    
    def __init__(self, config: dict):
        self.max_attempts = config.get('max_attempts', 3)
        self.initial_delay = config.get('initial_delay', 1.0)
        self.backoff_multiplier = config.get('backoff_multiplier', 2.0)
        self.max_delay = config.get('max_delay', 30.0)
        self.jitter = config.get('jitter', True)
        self.backoff = config.get('backoff', 'exponential')  # exponential –∏–ª–∏ linear
        
        # –î–ª—è HTTP retry
        self.retriable_status_codes = config.get('retriable_status_codes', [500, 502, 503, 504])
        self.retriable_exceptions = config.get('retriable_exceptions', [])


class CircuitBreaker:
    """
    Circuit Breaker –ø–∞—Ç—Ç–µ—Ä–Ω
    
    –°–æ—Å—Ç–æ—è–Ω–∏—è:
    - CLOSED: –Ω–æ—Ä–º–∞–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞
    - OPEN: —Å–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –Ω–µ –ø—ã—Ç–∞–µ–º—Å—è
    - HALF_OPEN: –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
    """
    
    def __init__(self, config: dict):
        self.enabled = config.get('enabled', True)
        self.failure_threshold = config.get('failure_threshold', 20)
        self.recovery_timeout = config.get('recovery_timeout', 300)  # —Å–µ–∫—É–Ω–¥
        self.half_open_max_attempts = config.get('half_open_max_attempts', 3)
        
        self.state = 'CLOSED'
        self.failure_count = 0
        self.last_failure_time: Optional[datetime] = None
        self.half_open_success_count = 0
        
        self.logger = get_logger('circuit_breaker')
    
    def record_success(self):
        """–ó–∞–ø–∏—Å—å —É—Å–ø–µ—à–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞"""
        if not self.enabled:
            return
        
        if self.state == 'HALF_OPEN':
            self.half_open_success_count += 1
            
            if self.half_open_success_count >= self.half_open_max_attempts:
                self.logger.info("üéâ Circuit Breaker: HALF_OPEN ‚Üí CLOSED (—Å–µ—Ä–≤–µ—Ä –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω)")
                self.state = 'CLOSED'
                self.failure_count = 0
                self.half_open_success_count = 0
        
        elif self.state == 'CLOSED':
            # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø—Ä–∏ —É—Å–ø–µ—Ö–µ
            self.failure_count = max(0, self.failure_count - 1)
    
    def record_failure(self):
        """–ó–∞–ø–∏—Å—å –Ω–µ—É–¥–∞—á–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞"""
        if not self.enabled:
            return
        
        self.failure_count += 1
        self.last_failure_time = datetime.now()
        
        if self.state == 'CLOSED' and self.failure_count >= self.failure_threshold:
            self.logger.critical(
                f"üö® Circuit Breaker: CLOSED ‚Üí OPEN "
                f"({self.failure_count} –æ—à–∏–±–æ–∫ –ø–æ–¥—Ä—è–¥)"
            )
            self.state = 'OPEN'
        
        elif self.state == 'HALF_OPEN':
            self.logger.warning("Circuit Breaker: HALF_OPEN ‚Üí OPEN (–ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞)")
            self.state = 'OPEN'
            self.half_open_success_count = 0
    
    def can_execute(self) -> bool:
        """–ú–æ–∂–Ω–æ –ª–∏ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å"""
        if not self.enabled:
            return True
        
        if self.state == 'CLOSED':
            return True
        
        if self.state == 'HALF_OPEN':
            return True
        
        # state == 'OPEN'
        if self.last_failure_time:
            elapsed = (datetime.now() - self.last_failure_time).total_seconds()
            
            if elapsed >= self.recovery_timeout:
                self.logger.info(
                    f"Circuit Breaker: OPEN ‚Üí HALF_OPEN "
                    f"(–ø–∞—É–∑–∞ {self.recovery_timeout} —Å–µ–∫ –ø—Ä–æ—à–ª–∞)"
                )
                self.state = 'HALF_OPEN'
                self.half_open_success_count = 0
                return True
        
        return False
    
    def get_wait_time(self) -> Optional[float]:
        """–°–∫–æ–ª—å–∫–æ –∂–¥–∞—Ç—å –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–∏ (–µ—Å–ª–∏ OPEN)"""
        if self.state != 'OPEN' or not self.last_failure_time:
            return None
        
        elapsed = (datetime.now() - self.last_failure_time).total_seconds()
        remaining = self.recovery_timeout - elapsed
        
        return max(0, remaining)


class RetryStrategy:
    """–°—Ç—Ä–∞—Ç–µ–≥–∏—è retry —Å –≥–∏–±–∫–∏–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏"""
    
    def __init__(self, config: RetryConfig, circuit_breaker: Optional[CircuitBreaker] = None):
        self.config = config
        self.circuit_breaker = circuit_breaker
        self.logger = get_logger('retry_strategy')
    
    def calculate_delay(self, attempt: int) -> float:
        """–†–∞—Å—á–µ—Ç –∑–∞–¥–µ—Ä–∂–∫–∏ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π"""
        if self.config.backoff == 'linear':
            delay = self.config.initial_delay
        else:  # exponential
            delay = self.config.initial_delay * (self.config.backoff_multiplier ** (attempt - 1))
        
        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –∑–∞–¥–µ—Ä–∂–∫–∏
        delay = min(delay, self.config.max_delay)
        
        # Jitter (—Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å ¬±20%)
        if self.config.jitter:
            jitter_range = delay * 0.2
            delay += random.uniform(-jitter_range, jitter_range)
        
        return max(0, delay)
    
    def is_retriable_exception(self, exc: Exception) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –º–æ–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å"""
        exc_name = type(exc).__name__
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ —Å–ø–∏—Å–∫—É –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
        if exc_name in self.config.retriable_exceptions:
            return True
        
        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ retriable –∏—Å–∫–ª—é—á–µ–Ω–∏—è
        retriable_types = (
            asyncio.TimeoutError,
            aiohttp.ClientError,
            aiohttp.ServerDisconnectedError,
            aiohttp.ClientConnectionError,
            ConnectionError,
            RetryableError
        )
        
        return isinstance(exc, retriable_types)
    
    def is_retriable_status(self, status: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ HTTP —Å—Ç–∞—Ç—É—Å –º–æ–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å"""
        return status in self.config.retriable_status_codes
    
    async def execute_with_retry(self, 
                                func: Callable,
                                *args,
                                error_context: str = "",
                                **kwargs) -> Any:
        """
        –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ —Å retry
        
        Args:
            func: –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
            error_context: –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, "HTTP GET /api")
            *args, **kwargs: –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è func
        
        Raises:
            NonRetriableError: –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ –Ω–µ –ø–æ–¥–ª–µ–∂–∏—Ç retry
            CircuitBreakerOpenError: –µ—Å–ª–∏ Circuit Breaker –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ OPEN
        """
        last_exception = None
        
        for attempt in range(1, self.config.max_attempts + 1):
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ Circuit Breaker
            if self.circuit_breaker and not self.circuit_breaker.can_execute():
                wait_time = self.circuit_breaker.get_wait_time()
                
                if wait_time and wait_time > 0:
                    self.logger.warning(
                        f"‚è∏Ô∏è Circuit Breaker OPEN, –∂–¥–µ–º {wait_time:.0f} —Å–µ–∫..."
                    )
                    await asyncio.sleep(wait_time)
                    
                    # –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Å–ª–µ –æ–∂–∏–¥–∞–Ω–∏—è
                    if not self.circuit_breaker.can_execute():
                        raise CircuitBreakerOpenError(
                            f"Circuit Breaker –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ OPEN, —Å–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
                        )
                else:
                    raise CircuitBreakerOpenError(
                        f"Circuit Breaker –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ OPEN"
                    )
            
            try:
                # –ü–æ–ø—ã—Ç–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
                result = await func(*args, **kwargs)
                
                # –£—Å–ø–µ—Ö
                if self.circuit_breaker:
                    self.circuit_breaker.record_success()
                
                if attempt > 1:
                    self.logger.info(f"‚úÖ –£—Å–ø–µ—Ö –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt}")
                
                return result
            
            except NonRetriableError:
                # –ù–µ –ø–æ–≤—Ç–æ—Ä—è–µ–º–∞—è –æ—à–∏–±–∫–∞ - –ø—Ä–æ–∫–∏–¥—ã–≤–∞–µ–º –Ω–∞–≤–µ—Ä—Ö
                if self.circuit_breaker:
                    self.circuit_breaker.record_success()  # –ù–µ —Å—á–∏—Ç–∞–µ–º –∫–∞–∫ failure
                raise
            
            except Exception as exc:
                last_exception = exc
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–æ–∂–Ω–æ –ª–∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å
                if not self.is_retriable_exception(exc):
                    self.logger.error(f"‚ùå Non-retriable error: {type(exc).__name__}: {exc}")
                    raise NonRetriableError(f"{type(exc).__name__}: {exc}") from exc
                
                # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º failure
                if self.circuit_breaker:
                    self.circuit_breaker.record_failure()
                
                # –ï—Å–ª–∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞ - –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ–º –æ—à–∏–±–∫—É
                if attempt >= self.config.max_attempts:
                    self.logger.error(
                        f"‚ùå –í—Å–µ {self.config.max_attempts} –ø–æ–ø—ã—Ç–∫–∏ –∏—Å—á–µ—Ä–ø–∞–Ω—ã"
                    )
                    raise RetryableError(
                        f"–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–æ—Å–ª–µ {self.config.max_attempts} –ø–æ–ø—ã—Ç–æ–∫: {exc}"
                    ) from exc
                
                # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
                delay = self.calculate_delay(attempt)
                
                self.logger.warning(
                    f"‚ö†Ô∏è [{error_context}] {type(exc).__name__} "
                    f"(–ø–æ–ø—ã—Ç–∫–∞ {attempt}/{self.config.max_attempts}), "
                    f"–ø–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ {delay:.1f} —Å–µ–∫"
                )
                
                await asyncio.sleep(delay)
        
        # –ù–µ –¥–æ–ª–∂–Ω–æ —Å—é–¥–∞ –¥–æ–π—Ç–∏, –Ω–æ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
        raise RetryableError(f"Unexpected retry exhaustion") from last_exception


################################################################################
# –§–ê–ô–õ: parsers/court_parser/utils/stats_reporter.py
################################################################################


"""
–°–±–æ—Ä –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–∞—Ä—Å–µ—Ä–∞
"""
import re
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from dataclasses import dataclass, field

from utils.logger import get_logger


@dataclass
class CourtStats:
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–¥–Ω–æ–≥–æ —Å—É–¥–∞"""
    total_cases: int = 0
    max_sequence: int = 0
    gaps_count: int = 0
    without_judge: int = 0  # —Ç–æ–ª—å–∫–æ –¥–ª—è –°–ú–ê–°
    without_parties: int = 0
    last_case_date: Optional[datetime] = None
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Å—Å–∏–∏ (–∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤–æ –≤—Ä–µ–º—è –ø–∞—Ä—Å–∏–Ω–≥–∞)
    session_queries: int = 0
    session_saved: int = 0
    session_time: str = ""
    stop_reason: str = ""  # 'empty_limit', 'query_limit', 'error', 'manual', 'completed'
    consecutive_empty_at_stop: int = 0


@dataclass
class RegionStats:
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–µ–≥–∏–æ–Ω–∞"""
    name: str
    courts: Dict[str, CourtStats] = field(default_factory=dict)


@dataclass 
class DatabaseStats:
    """–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ë–î"""
    total_cases: int = 0
    total_judges: int = 0
    total_parties: int = 0
    total_events: int = 0
    smas_with_judge: int = 0
    smas_without_judge: int = 0
    cases_without_parties: int = 0
    total_gaps: int = 0
    first_case_date: Optional[datetime] = None
    last_case_date: Optional[datetime] = None


class StatsCollector:
    """–°–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–∑ –ë–î"""
    
    def __init__(self, db_manager, settings):
        self.db = db_manager
        self.settings = settings
        self.logger = get_logger('stats_collector')
    
    async def collect_database_stats(self) -> DatabaseStats:
        """–°–æ–±—Ä–∞—Ç—å –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ë–î"""
        stats = DatabaseStats()
        
        async with self.db.pool.acquire() as conn:
            # –û–±—â–∏–µ —Å—á—ë—Ç—á–∏–∫–∏
            stats.total_cases = await conn.fetchval("SELECT COUNT(*) FROM cases")
            stats.total_judges = await conn.fetchval("SELECT COUNT(*) FROM judges")
            stats.total_parties = await conn.fetchval("SELECT COUNT(*) FROM parties")
            stats.total_events = await conn.fetchval("SELECT COUNT(*) FROM case_events")
            
            # –î–µ–ª–∞ –±–µ–∑ —Å—Ç–æ—Ä–æ–Ω
            stats.cases_without_parties = await conn.fetchval("""
                SELECT COUNT(*) FROM cases c
                WHERE NOT EXISTS (
                    SELECT 1 FROM case_parties cp WHERE cp.case_id = c.id
                )
            """)
            
            # –î–∞—Ç—ã
            row = await conn.fetchrow("""
                SELECT MIN(case_date) as first_date, MAX(case_date) as last_date
                FROM cases
            """)
            if row:
                stats.first_case_date = row['first_date']
                stats.last_case_date = row['last_date']
            
            # –°–ú–ê–° —Å/–±–µ–∑ —Å—É–¥—å–∏
            smas_codes = self._get_smas_instance_codes()
            if smas_codes:
                codes_condition = self._build_codes_condition(smas_codes)
                
                row = await conn.fetchrow(f"""
                    SELECT 
                        COUNT(*) FILTER (WHERE judge_id IS NOT NULL) as with_judge,
                        COUNT(*) FILTER (WHERE judge_id IS NULL) as without_judge
                    FROM cases
                    WHERE {codes_condition}
                """)
                if row:
                    stats.smas_with_judge = row['with_judge']
                    stats.smas_without_judge = row['without_judge']
        
        return stats
    
    async def collect_region_stats(self, year: str) -> Dict[str, RegionStats]:
        """–°–æ–±—Ä–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –≤—Å–µ–º —Ä–µ–≥–∏–æ–Ω–∞–º"""
        regions_stats = {}
        
        for region_key, region_config in self.settings.regions.items():
            region_stats = RegionStats(name=region_config['name'])
            
            for court_key, court_config in region_config['courts'].items():
                court_stats = await self._collect_court_stats(
                    region_config, court_config, court_key, year
                )
                region_stats.courts[court_key] = court_stats
            
            regions_stats[region_key] = region_stats
        
        return regions_stats
    
    async def _collect_court_stats(
        self, 
        region_config: Dict, 
        court_config: Dict,
        court_key: str,
        year: str
    ) -> CourtStats:
        """–°–æ–±—Ä–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ–¥–Ω–æ–≥–æ —Å—É–¥–∞"""
        stats = CourtStats()
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –Ω–æ–º–µ—Ä–∞ –¥–µ–ª–∞
        kato = region_config['kato_code']
        instance = court_config['instance_code']
        year_short = year[-2:]
        case_type = court_config['case_type_code']
        prefix = f"{kato}{instance}-{year_short}-00-{case_type}/"
        
        async with self.db.pool.acquire() as conn:
            # –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
            row = await conn.fetchrow("""
                SELECT 
                    COUNT(*) as total,
                    MAX(created_at) as last_created
                FROM cases
                WHERE case_number LIKE $1
            """, f"{prefix}%")
            
            if row:
                stats.total_cases = row['total']
                stats.last_case_date = row['last_created']
            
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø–æ—Ä—è–¥–∫–æ–≤—ã–µ –Ω–æ–º–µ—Ä–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–æ–ø—É—Å–∫–æ–≤
            if stats.total_cases > 0:
                rows = await conn.fetch("""
                    SELECT case_number FROM cases
                    WHERE case_number LIKE $1
                """, f"{prefix}%")
                
                sequences = set()
                for r in rows:
                    try:
                        seq = int(r['case_number'].split('/')[-1])
                        sequences.add(seq)
                    except (ValueError, IndexError):
                        continue
                
                if sequences:
                    stats.max_sequence = max(sequences)
                    expected = set(range(1, stats.max_sequence + 1))
                    gaps = expected - sequences
                    stats.gaps_count = len(gaps)
            
            # –ë–µ–∑ —Å—É–¥—å–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è –°–ú–ê–°)
            if court_key == 'smas':
                stats.without_judge = await conn.fetchval("""
                    SELECT COUNT(*) FROM cases
                    WHERE case_number LIKE $1 AND judge_id IS NULL
                """, f"{prefix}%")
            
            # –ë–µ–∑ —Å—Ç–æ—Ä–æ–Ω
            stats.without_parties = await conn.fetchval("""
                SELECT COUNT(*) FROM cases c
                WHERE c.case_number LIKE $1
                AND NOT EXISTS (
                    SELECT 1 FROM case_parties cp WHERE cp.case_id = c.id
                )
            """, f"{prefix}%")
        
        return stats
    
    def _get_smas_instance_codes(self) -> set:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–¥—ã –∏–Ω—Å—Ç–∞–Ω—Ü–∏–π –°–ú–ê–°"""
        codes = set()
        for region_config in self.settings.regions.values():
            smas = region_config['courts'].get('smas')
            if smas:
                codes.add(smas['instance_code'])
        return codes
    
    def _build_codes_condition(self, codes: set) -> str:
        """–ü–æ—Å—Ç—Ä–æ–∏—Ç—å SQL —É—Å–ª–æ–≤–∏–µ –¥–ª—è –∫–æ–¥–æ–≤ –∏–Ω—Å—Ç–∞–Ω—Ü–∏–π"""
        conditions = [f"SUBSTRING(case_number FROM 3 FOR 2) = '{code}'" for code in codes]
        return f"({' OR '.join(conditions)})"


class ReportFormatter:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç—á—ë—Ç–æ–≤"""
    
    WIDTH = 110
    
    def __init__(self, settings):
        self.settings = settings
        self.empty_limit = settings.parsing_settings.get('max_consecutive_empty', 5)
    
    def _line(self, content: str, left: str = "‚îÉ", right: str = "‚îÉ") -> str:
        """
        –°–æ–∑–¥–∞—Ç—å —Å—Ç—Ä–æ–∫—É —Ç–∞–±–ª–∏—Ü—ã —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ–º
        
        –£—á–∏—Ç—ã–≤–∞–µ—Ç Unicode-—Å–∏–º–≤–æ–ª—ã (—ç–º–æ–¥–∑–∏ –∑–∞–Ω–∏–º–∞—é—Ç 2 –ø–æ–∑–∏—Ü–∏–∏)
        """
        # –í—ã—á–∏—Å–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É —Å—Ç—Ä–æ–∫–∏
        visual_len = self._visual_length(content)
        
        # –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —à–∏—Ä–∏–Ω–∞ (–±–µ–∑ —Ä–∞–º–æ–∫)
        inner_width = self.WIDTH - 2
        
        # –î–æ–ø–æ–ª–Ω—è–µ–º –ø—Ä–æ–±–µ–ª–∞–º–∏
        padding = inner_width - visual_len
        if padding > 0:
            content = content + ' ' * padding
        elif padding < 0:
            # –û–±—Ä–µ–∑–∞–µ–º –µ—Å–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è
            content = self._truncate(content, inner_width)
        
        return f"{left}{content}{right}"
    
    def _visual_length(self, text: str) -> int:
        """
        –í—ã—á–∏—Å–ª–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É —Å—Ç—Ä–æ–∫–∏
        
        –≠–º–æ–¥–∑–∏ –∏ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ Unicode-—Å–∏–º–≤–æ–ª—ã –∑–∞–Ω–∏–º–∞—é—Ç 2 –ø–æ–∑–∏—Ü–∏–∏
        """
        length = 0
        for char in text:
            # –≠–º–æ–¥–∑–∏ –∏ —à–∏—Ä–æ–∫–∏–µ —Å–∏–º–≤–æ–ª—ã
            if ord(char) > 0x1F000 or char in '‚úÖ‚ùå‚ö†Ô∏è‚è∏Ô∏è‚èπÔ∏èüî¥üë®‚Äç‚öñÔ∏èüìãüìäüì•üìåüéâüö®':
                length += 2
            else:
                length += 1
        return length
    
    def _truncate(self, text: str, max_visual_len: int) -> str:
        """–û–±—Ä–µ–∑–∞—Ç—å —Å—Ç—Ä–æ–∫—É –¥–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –≤–∏–∑—É–∞–ª—å–Ω–æ–π –¥–ª–∏–Ω—ã"""
        result = []
        current_len = 0
        
        for char in text:
            char_len = 2 if ord(char) > 0x1F000 or char in '‚úÖ‚ùå‚ö†Ô∏è‚è∏Ô∏è‚èπÔ∏èüî¥üë®‚Äç‚öñÔ∏èüìãüìäüì•üìåüéâüö®' else 1
            
            if current_len + char_len > max_visual_len - 1:
                result.append('‚Ä¶')
                break
            
            result.append(char)
            current_len += char_len
        
        return ''.join(result)
    
    def _center(self, text: str) -> str:
        """–¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ —Å —É—á—ë—Ç–æ–º Unicode"""
        visual_len = self._visual_length(text)
        total_padding = self.WIDTH - visual_len
        
        if total_padding <= 0:
            return text
        
        left_pad = total_padding // 2
        right_pad = total_padding - left_pad
        
        return ' ' * left_pad + text + ' ' * right_pad
    
    def format_start_report(
        self, 
        db_stats: DatabaseStats, 
        regions_stats: Dict[str, RegionStats],
        plan: Dict[str, Any]
    ) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –æ—Ç—á—ë—Ç–∞"""
        lines = []
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        lines.append("‚ïê" * self.WIDTH)
        lines.append(self._center("–ü–ê–†–°–ï–† –°–£–î–ï–ë–ù–´–• –î–ï–õ –ö–ê–ó–ê–•–°–¢–ê–ù–ê v2.1"))
        lines.append(self._center(f"–ó–∞–ø—É—Å–∫: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"))
        lines.append("‚ïê" * self.WIDTH)
        lines.append("")
        
        # –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ë–î
        lines.extend(self._format_db_stats(db_stats))
        lines.append("")
        
        # –¢–∞–±–ª–∏—Ü–∞ —Ä–µ–≥–∏–æ–Ω–æ–≤
        lines.extend(self._format_regions_table(regions_stats, plan.get('year', '2025')))
        lines.append("")
        
        # –ü—Ä–æ–±–ª–µ–º—ã
        problems = self._find_problems(regions_stats)
        if problems:
            lines.extend(self._format_problems(problems))
            lines.append("")
        
        # –ü–ª–∞–Ω –∑–∞–ø—É—Å–∫–∞
        lines.extend(self._format_plan(plan))
        lines.append("")
        lines.append("‚ïê" * self.WIDTH)
        
        return "\n".join(lines)
    
    def format_end_report(
        self,
        db_stats_before: DatabaseStats,
        db_stats_after: DatabaseStats,
        regions_stats: Dict[str, RegionStats],
        session_stats: Dict[str, Any]
    ) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –æ—Ç—á—ë—Ç–∞"""
        lines = []
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        lines.append("‚ïê" * self.WIDTH)
        lines.append(self._center("–ü–ê–†–°–ò–ù–ì –ó–ê–í–ï–†–®–Å–ù"))
        
        start_time = session_stats.get('start_time', datetime.now())
        end_time = session_stats.get('end_time', datetime.now())
        duration = end_time - start_time
        hours, remainder = divmod(int(duration.total_seconds()), 3600)
        minutes, seconds = divmod(remainder, 60)
        
        lines.append(self._center(
            f"{start_time.strftime('%Y-%m-%d %H:%M')} ‚Äî {end_time.strftime('%H:%M')} "
            f"({hours}—á {minutes}–º {seconds}—Å)"
        ))
        lines.append("‚ïê" * self.WIDTH)
        lines.append("")
        
        # –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–µ—Å—Å–∏–∏
        lines.extend(self._format_session_results(session_stats))
        lines.append("")
        
        # –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ —Ä–µ–≥–∏–æ–Ω–∞–º (—Å–µ—Å—Å–∏—è)
        lines.extend(self._format_session_details(regions_stats))
        lines.append("")
        
        # –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –î–û –∏ –ü–û–°–õ–ï
        lines.extend(self._format_comparison(db_stats_before, db_stats_after))
        lines.append("")
        
        # –§–∏–Ω–∞–ª—å–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ —Ä–µ–≥–∏–æ–Ω–æ–≤
        lines.extend(self._format_regions_table(regions_stats, session_stats.get('year', '2025'), show_status=True))
        lines.append("")
        
        # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        recommendations = self._generate_recommendations(regions_stats, db_stats_after)
        if recommendations:
            lines.extend(self._format_recommendations(recommendations))
            lines.append("")
        
        lines.append("‚ïê" * self.WIDTH)
        
        # –ò—Ç–æ–≥–æ–≤—ã–π —Å—Ç–∞—Ç—É—Å
        has_errors = any(
            court.stop_reason == 'error'
            for region in regions_stats.values()
            for court in region.courts.values()
        )
        
        if has_errors:
            lines.append(self._center("‚ö†Ô∏è –ü–ê–†–°–ò–ù–ì –ó–ê–í–ï–†–®–Å–ù –° –û–®–ò–ë–ö–ê–ú–ò"))
        else:
            lines.append(self._center("‚úÖ –ü–ê–†–°–ò–ù–ì –ó–ê–í–ï–†–®–Å–ù –£–°–ü–ï–®–ù–û"))
        
        lines.append("‚ïê" * self.WIDTH)
        
        return "\n".join(lines)
    
    def _format_db_stats(self, stats: DatabaseStats) -> List[str]:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—â–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ë–î"""
        lines = []
        
        lines.append("‚îè" + "‚îÅ" * (self.WIDTH - 2) + "‚îì")
        lines.append(self._line(self._center("–°–û–°–¢–û–Ø–ù–ò–ï –ë–ê–ó–´ –î–ê–ù–ù–´–•")[1 :-1]))
        lines.append("‚î£" + "‚îÅ" * (self.WIDTH - 2) + "‚î´")
        
        # –õ–µ–≤–∞—è –∏ –ø—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∏
        first_date = stats.first_case_date.strftime('%Y-%m-%d') if stats.first_case_date else '‚Äî'
        last_date = stats.last_case_date.strftime('%Y-%m-%d') if stats.last_case_date else '‚Äî'
        
        rows = [
            (f"  –í—Å–µ–≥–æ –¥–µ–ª:          {stats.total_cases:,}", f"–ü–µ—Ä–≤–æ–µ –¥–µ–ª–æ:       {first_date}"),
            (f"  –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å—É–¥–µ–π:   {stats.total_judges:,}", f"–ü–æ—Å–ª–µ–¥–Ω–µ–µ –¥–µ–ª–æ:    {last_date}"),
            (f"  –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å—Ç–æ—Ä–æ–Ω:  {stats.total_parties:,}", ""),
            (f"  –í—Å–µ–≥–æ —Å–æ–±—ã—Ç–∏–π:      {stats.total_events:,}", ""),
        ]
        
        mid = self.WIDTH // 2
        for left, right in rows:
            content = f"{left:<{mid-1}}{right}"
            lines.append(self._line(content))
        
        lines.append(self._line(""))
        
        # –ü—Ä–æ–±–ª–µ–º–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        smas_total = stats.smas_with_judge + stats.smas_without_judge
        smas_pct = (stats.smas_without_judge / smas_total * 100) if smas_total > 0 else 0
        
        lines.append(self._line("  ‚ö†Ô∏è –ü–†–û–ë–õ–ï–ú–´"))
        lines.append(self._line("  " + "‚îÄ" * 25))
        lines.append(self._line(f"  –°–ú–ê–° –±–µ–∑ —Å—É–¥—å–∏:      {stats.smas_without_judge:,} –¥–µ–ª ({smas_pct:.1f}% –æ—Ç –°–ú–ê–°)"))
        lines.append(self._line(f"  –î–µ–ª –±–µ–∑ —Å—Ç–æ—Ä–æ–Ω:      {stats.cases_without_parties:,} –¥–µ–ª"))
        
        lines.append(self._line(""))
        lines.append("‚îó" + "‚îÅ" * (self.WIDTH - 2) + "‚îõ")
        
        return lines
    
    def _format_regions_table(
        self, 
        regions_stats: Dict[str, RegionStats],
        year: str, 
        show_status: bool = True
    ) -> List[str]:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã —Ä–µ–≥–∏–æ–Ω–æ–≤"""
        lines = []
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
        lines.append("‚îè" + "‚îÅ" * (self.WIDTH - 2) + "‚îì")
        lines.append(self._line(self._center(f"–î–ï–¢–ê–õ–ò–ó–ê–¶–ò–Ø –ü–û –†–ï–ì–ò–û–ù–ê–ú ({year})")[1:-1]))
        lines.append("‚î£" + "‚îÅ" * 19 + "‚î≥" + "‚îÅ" * 44 + "‚î≥" + "‚îÅ" * 43 + "‚î´")
        
        # –ü–æ–¥–∑–∞–≥–æ–ª–æ–≤–∫–∏ –∫–æ–ª–æ–Ω–æ–∫
        lines.append("‚îÉ                   ‚îÉ              –° –ú –ê –°                       ‚îÉ           –ê –ü –ï –õ –õ –Ø –¶ –ò –Ø              ‚îÉ")
        
        if show_status:
            lines.append("‚îÉ –†–µ–≥–∏–æ–Ω            ‚îÉ –í—Å–µ–≥–æ ‚îÇ–ü—Ä–æ–ø—É—Å.‚îÇ–ë–µ–∑ —Å—É–¥‚îÇ–ë–µ–∑ —Å—Ç.‚îÇ –°—Ç–∞—Ç—É—Å   ‚îÉ –í—Å–µ–≥–æ ‚îÇ–ü—Ä–æ–ø—É—Å.‚îÇ–ë–µ–∑ —Å—Ç.‚îÇ –°—Ç–∞—Ç—É—Å          ‚îÉ")
        else:
            lines.append("‚îÉ –†–µ–≥–∏–æ–Ω            ‚îÉ –í—Å–µ–≥–æ ‚îÇ–ü—Ä–æ–ø—É—Å.‚îÇ–ë–µ–∑ —Å—É–¥‚îÇ–ë–µ–∑ —Å—Ç.‚îÇ          ‚îÉ –í—Å–µ–≥–æ ‚îÇ–ü—Ä–æ–ø—É—Å.‚îÇ–ë–µ–∑ —Å—Ç.‚îÇ                 ‚îÉ")
        
        lines.append("‚î£" + "‚îÅ" * 19 + "‚ïã" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 10 + "‚ïã" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 17 + "‚î´")
        
        # –î–∞–Ω–Ω—ã–µ
        totals = {'smas': CourtStats(), 'appellate': CourtStats()}
        
        for region_key, region_stats in regions_stats.items():
            smas = region_stats.courts.get('smas', CourtStats())
            appel = region_stats.courts.get('appellate', CourtStats())
            
            # –ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ –∏—Ç–æ–≥–æ–≤
            totals['smas'].total_cases += smas.total_cases
            totals['smas'].gaps_count += smas.gaps_count
            totals['smas'].without_judge += smas.without_judge
            totals['smas'].without_parties += smas.without_parties
            totals['appellate'].total_cases += appel.total_cases
            totals['appellate'].gaps_count += appel.gaps_count
            totals['appellate'].without_parties += appel.without_parties
            
            # –°—Ç–∞—Ç—É—Å—ã
            smas_status = self._determine_status(smas) if show_status else ""
            appel_status = self._determine_status(appel) if show_status else ""
            
            # –ö–æ—Ä–æ—Ç–∫–æ–µ –∏–º—è —Ä–µ–≥–∏–æ–Ω–∞
            name = self._short_name(region_stats.name)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –ø–æ–∑–∏—Ü–∏—è–º–∏
            line = (
                f"‚îÉ {name:<17} "
                f"‚îÉ{smas.total_cases:>6} ‚îÇ{smas.gaps_count:>6} ‚îÇ{smas.without_judge:>6} ‚îÇ{smas.without_parties:>6} ‚îÇ {smas_status:<8} "
                f"‚îÉ{appel.total_cases:>6} ‚îÇ{appel.gaps_count:>6} ‚îÇ{appel.without_parties:>6} ‚îÇ {appel_status:<15} ‚îÉ"
            )
            lines.append(line)
        
        # –ò—Ç–æ–≥–∏
        lines.append("‚î£" + "‚îÅ" * 19 + "‚ïã" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 10 + "‚ïã" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 17 + "‚î´")
        
        line = (
            f"‚îÉ {'–ò–¢–û–ì–û':<17} "
            f"‚îÉ{totals['smas'].total_cases:>6} ‚îÇ{totals['smas'].gaps_count:>6} ‚îÇ{totals['smas'].without_judge:>6} ‚îÇ{totals['smas'].without_parties:>6} ‚îÇ          "
            f"‚îÉ{totals['appellate'].total_cases:>6} ‚îÇ{totals['appellate'].gaps_count:>6} ‚îÇ{totals['appellate'].without_parties:>6} ‚îÇ                 ‚îÉ"
        )
        lines.append(line)
        
        lines.append("‚îó" + "‚îÅ" * 19 + "‚îª" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 10 + "‚îª" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 17 + "‚îõ")
        
        # –õ–µ–≥–µ–Ω–¥–∞
        lines.append("")
        lines.append("–°—Ç–∞—Ç—É—Å—ã: ‚úÖ –ù–û–†–ú ‚Äî –ª–∏–º–∏—Ç –ø—É—Å—Ç—ã—Ö ‚îÇ ‚úÖ –ì–û–¢–û–í–û ‚Äî –≤–µ—Å—å –¥–∏–∞–ø–∞–∑–æ–Ω ‚îÇ ‚ö†Ô∏è –ß–ê–°–¢–ò–ß ‚Äî –Ω–µ–ø–æ–ª–Ω—ã–µ ‚îÇ üî¥ –ü–£–°–¢–û ‚Äî –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö ‚îÇ ‚ùå –û–®–ò–ë–ö–ê")
        
        return lines
    
    def _determine_status(self, court: CourtStats) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Å—É–¥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö"""
        # –ï—Å–ª–∏ –µ—Å—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Å—Å–∏–∏ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ—ë
        if court.stop_reason:
            return self._format_stop_reason(court.stop_reason)
        
        # –ò–Ω–∞—á–µ ‚Äî –≤—ã—á–∏—Å–ª—è–µ–º –ø–æ –¥–∞–Ω–Ω—ã–º
        if court.total_cases == 0:
            return "üî¥ –ü–£–°–¢–û"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö
        if court.max_sequence > 0:
            gap_ratio = court.gaps_count / court.max_sequence if court.max_sequence > 0 else 0
            if gap_ratio < 0.1:
                return "‚úÖ –ù–û–†–ú"
            else:
                return "‚ö†Ô∏è –ß–ê–°–¢–ò–ß"
        
        return "‚úÖ –ù–û–†–ú"
    
    def _format_stop_reason(self, reason: str) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏—á–∏–Ω—ã –æ—Å—Ç–∞–Ω–æ–≤–∫–∏"""
        mapping = {
            'empty_limit': '‚úÖ –ù–û–†–ú',
            'query_limit': '‚è∏Ô∏è –õ–ò–ú–ò–¢',
            'error': '‚ùå –û–®–ò–ë–ö–ê',
            'manual': '‚èπÔ∏è –°–¢–û–ü',
            'completed': '‚úÖ –ì–û–¢–û–í–û',
            '': '',
        }
        return mapping.get(reason, reason)
    
    def _short_name(self, name: str) -> str:
        """–°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –∏–º–µ–Ω–∏ —Ä–µ–≥–∏–æ–Ω–∞"""
        replacements = {
            '–≥–æ—Ä–æ–¥ ': '',
            '–æ–±–ª–∞—Å—Ç—å': '–æ–±–ª.',
            '–û–±–ª–∞—Å—Ç—å ': '',
            '-–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—Å–∫–∞—è': '',
            '–í–æ—Å—Ç–æ—á–Ω–æ': '–í–ö',
            '–ó–∞–ø–∞–¥–Ω–æ': '–ó–ö', 
            '–°–µ–≤–µ—Ä–æ': '–°–ö',
        }
        for old, new in replacements.items():
            name = name.replace(old, new)
        return name[:17]
    
    def _find_problems(self, regions_stats: Dict[str, RegionStats]) -> Dict[str, List]:
        """–ù–∞–π—Ç–∏ –ø—Ä–æ–±–ª–µ–º—ã –≤ –¥–∞–Ω–Ω—ã—Ö"""
        problems = {
            'empty_regions': [],
            'high_gaps': [],
            'many_without_judge': [],
        }
        
        for region_key, region in regions_stats.items():
            smas = region.courts.get('smas', CourtStats())
            appel = region.courts.get('appellate', CourtStats())
            
            # –ü—É—Å—Ç—ã–µ —Ä–µ–≥–∏–æ–Ω—ã
            if smas.total_cases == 0 and appel.total_cases == 0:
                problems['empty_regions'].append(region.name)
            
            # –ú–Ω–æ–≥–æ –ø—Ä–æ–ø—É—Å–∫–æ–≤
            if smas.gaps_count > 20:
                problems['high_gaps'].append((region.name, '–°–ú–ê–°', smas.gaps_count))
            if appel.gaps_count > 20:
                problems['high_gaps'].append((region.name, '–ê–ø–µ–ª–ª—è—Ü–∏—è', appel.gaps_count))
            
            # –ú–Ω–æ–≥–æ –±–µ–∑ —Å—É–¥—å–∏ (—Ç–æ–ª—å–∫–æ –°–ú–ê–°)
            if smas.without_judge > 50:
                pct = (smas.without_judge / smas.total_cases * 100) if smas.total_cases > 0 else 0
                problems['many_without_judge'].append((region.name, smas.without_judge, pct))
        
        return problems
    
    def _format_problems(self, problems: Dict[str, List]) -> List[str]:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –±–ª–æ–∫–∞ –ø—Ä–æ–±–ª–µ–º"""
        lines = []
        lines.append("‚îè" + "‚îÅ" * (self.WIDTH - 2) + "‚îì")
        lines.append(self._line(self._center("‚ö†Ô∏è –¢–†–ï–ë–£–Æ–¢ –í–ù–ò–ú–ê–ù–ò–Ø")[1:-1]))
        lines.append("‚î£" + "‚îÅ" * (self.WIDTH - 2) + "‚î´")
        
        if problems['empty_regions']:
            lines.append(self._line(""))
            names = ", ".join(problems['empty_regions'][:5])
            if len(problems['empty_regions']) > 5:
                names += f" (+{len(problems['empty_regions']) - 5})"
            lines.append(self._line(f"  üî¥ –†–ï–ì–ò–û–ù–´ –ë–ï–ó –î–ê–ù–ù–´–•: {names}"))
        
        if problems['many_without_judge']:
            lines.append(self._line(""))
            lines.append(self._line("  üë®‚Äç‚öñÔ∏è –°–ú–ê–° –ë–ï–ó –°–£–î–¨–ò:"))
            for name, count, pct in sorted(problems['many_without_judge'], key=lambda x: -x[1])[:5]:
                lines.append(self._line(f"     ‚Ä¢ {name}: {count} –¥–µ–ª ({pct:.1f}%)"))
        
        if problems['high_gaps']:
            lines.append(self._line(""))
            lines.append(self._line("  üìã –ú–ù–û–ì–û –ü–†–û–ü–£–°–ö–û–í:"))
            for name, court, count in sorted(problems['high_gaps'], key=lambda x: -x[2])[:5]:
                lines.append(self._line(f"     ‚Ä¢ {name} {court}: {count} –ø—Ä–æ–ø—É—Å–∫–æ–≤"))
        
        lines.append(self._line(""))
        lines.append("‚îó" + "‚îÅ" * (self.WIDTH - 2) + "‚îõ")
        
        return lines
    
    def _format_plan(self, plan: Dict[str, Any]) -> List[str]:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–ª–∞–Ω–∞ –∑–∞–ø—É—Å–∫–∞"""
        lines = []
        lines.append("‚îè" + "‚îÅ" * (self.WIDTH - 2) + "‚îì")
        lines.append(self._line(self._center("üìã –ü–õ–ê–ù –ó–ê–ü–£–°–ö–ê")[1:-1]))
        lines.append("‚î£" + "‚îÅ" * (self.WIDTH - 2) + "‚î´")
        lines.append(self._line(""))
        
        mode = plan.get('mode', 'parse')
        year = plan.get('year', '2025')
        courts = ", ".join(plan.get('court_types', ['smas']))
        regions = plan.get('target_regions', [])
        regions_str = ", ".join(regions[:3])
        if len(regions) > 3:
            regions_str += f" (+{len(regions) - 3})"
        
        lines.append(self._line(f"  –†–µ–∂–∏–º:                  {mode}"))
        lines.append(self._line(f"  –ì–æ–¥:                    {year}"))
        lines.append(self._line(f"  –°—É–¥—ã:                   {courts}"))
        lines.append(self._line(f"  –†–µ–≥–∏–æ–Ω—ã:                {regions_str} ({len(regions)} —à—Ç)"))
        lines.append(self._line(f"  –õ–∏–º–∏—Ç –ø—É—Å—Ç—ã—Ö –ø–æ–¥—Ä—è–¥:    {plan.get('max_consecutive_empty', 5)}"))
        
        lines.append(self._line(""))
        lines.append("‚îó" + "‚îÅ" * (self.WIDTH - 2) + "‚îõ")
        
        return lines
    
    def _format_session_results(self, stats: Dict[str, Any]) -> List[str]:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–µ—Å—Å–∏–∏"""
        lines = []
        lines.append("‚îè" + "‚îÅ" * (self.WIDTH - 2) + "‚îì")
        lines.append(self._line(self._center("–†–ï–ó–£–õ–¨–¢–ê–¢–´ –°–ï–°–°–ò–ò")[1:-1]))
        lines.append("‚î£" + "‚îÅ" * (self.WIDTH - 2) + "‚î´")
        lines.append(self._line(""))
        
        regions_total = stats.get('regions_total', 0)
        regions_done = stats.get('regions_processed', 0)
        regions_failed = stats.get('regions_failed', 0)
        
        status_icon = "‚úÖ" if regions_failed == 0 else "‚ö†Ô∏è"
        
        mid = self.WIDTH // 2
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —á–∏—Å–ª–∞ –æ—Ç–¥–µ–ª—å–Ω–æ, –∑–∞—Ç–µ–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å—Ç—Ä–æ–∫–∏
        total_queries = f"{stats.get('total_queries', 0):,}"
        total_saved = f"{stats.get('total_cases_saved', 0):,}"
        gaps_filled = f"{stats.get('gaps_filled', 0):,}"
        
        lines.append(self._line(f"  {'üìä –í–´–ü–û–õ–ù–ï–ù–û':<{mid-3}}{'üì• –°–û–•–†–ê–ù–ï–ù–û'}"))
        lines.append(self._line(f"  {'‚îÄ' * 25:<{mid-3}}{'‚îÄ' * 25}"))
        
        # –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞
        left1 = f"–†–µ–≥–∏–æ–Ω–æ–≤: {regions_done}/{regions_total} {status_icon}"
        right1 = f"–ù–æ–≤—ã—Ö –¥–µ–ª: {total_saved}"
        lines.append(self._line(f"  {left1:<{mid-3}}{right1}"))
        
        left2 = f"–ó–∞–ø—Ä–æ—Å–æ–≤: {total_queries}"
        right2 = f"–ó–∞–ø–æ–ª–Ω–µ–Ω–æ –ø—Ä–æ–ø—É—Å–∫–æ–≤: {gaps_filled}"
        lines.append(self._line(f"  {left2:<{mid-3}}{right2}"))
        
        lines.append(self._line(""))
        lines.append("‚îó" + "‚îÅ" * (self.WIDTH - 2) + "‚îõ")
        
        return lines
    
    def _format_session_details(self, regions_stats: Dict[str, RegionStats]) -> List[str]:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ—Ç–∞–ª–µ–π —Å–µ—Å—Å–∏–∏ –ø–æ —Ä–µ–≥–∏–æ–Ω–∞–º"""
        lines = []
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ä–µ–≥–∏–æ–Ω—ã —Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å—é –≤ —Å–µ—Å—Å–∏–∏
        active_regions = {
            k: v for k, v in regions_stats.items()
            if any(c.session_queries > 0 or c.stop_reason for c in v.courts.values())
        }
        
        if not active_regions:
            return lines
        
        lines.append("‚îè" + "‚îÅ" * (self.WIDTH - 2) + "‚îì")
        lines.append(self._line(self._center("–î–ï–¢–ê–õ–ò–ó–ê–¶–ò–Ø –°–ï–°–°–ò–ò")[1:-1]))
        lines.append("‚î£" + "‚îÅ" * 19 + "‚î≥" + "‚îÅ" * 44 + "‚î≥" + "‚îÅ" * 43 + "‚î´")
        lines.append("‚îÉ                   ‚îÉ              –° –ú –ê –°                       ‚îÉ           –ê –ü –ï –õ –õ –Ø –¶ –ò –Ø              ‚îÉ")
        lines.append("‚îÉ –†–µ–≥–∏–æ–Ω            ‚îÉ–ó–∞–ø—Ä–æ—Å.‚îÇ–°–æ—Ö—Ä–∞–Ω.‚îÇ–ü—É—Å—Ç—ã—Ö ‚îÇ –í—Ä–µ–º—è  ‚îÇ –û—Å—Ç–∞–Ω–æ–≤–∫–∞‚îÉ–ó–∞–ø—Ä–æ—Å.‚îÇ–°–æ—Ö—Ä–∞–Ω.‚îÇ –í—Ä–µ–º—è  ‚îÇ –û—Å—Ç–∞–Ω–æ–≤–∫–∞       ‚îÉ")
        lines.append("‚î£" + "‚îÅ" * 19 + "‚ïã" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 8 + "‚îø" + "‚îÅ" * 10 + "‚ïã" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 7 + "‚îø" + "‚îÅ" * 8 + "‚îø" + "‚îÅ" * 17 + "‚î´")
        
        for region_key, region in active_regions.items():
            smas = region.courts.get('smas', CourtStats())
            appel = region.courts.get('appellate', CourtStats())
            
            name = self._short_name(region.name)
            
            smas_stop = self._format_stop_reason(smas.stop_reason)
            appel_stop = self._format_stop_reason(appel.stop_reason)
            
            line = (
                f"‚îÉ {name:<17} "
                f"‚îÉ{smas.session_queries:>6} ‚îÇ{smas.session_saved:>6} ‚îÇ{smas.consecutive_empty_at_stop:>6} ‚îÇ{smas.session_time:>7} ‚îÇ {smas_stop:<8} "
                f"‚îÉ{appel.session_queries:>6} ‚îÇ{appel.session_saved:>6} ‚îÇ{appel.session_time:>7} ‚îÇ {appel_stop:<15} ‚îÉ"
            )
            lines.append(line)
        
        lines.append("‚îó" + "‚îÅ" * 19 + "‚îª" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 8 + "‚î∑" + "‚îÅ" * 10 + "‚îª" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 7 + "‚î∑" + "‚îÅ" * 8 + "‚î∑" + "‚îÅ" * 17 + "‚îõ")
        
        return lines
    
    def _format_comparison(
        self, 
        before: DatabaseStats, 
        after: DatabaseStats
    ) -> List[str]:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –î–û –∏ –ü–û–°–õ–ï"""
        lines = []
        lines.append("‚îè" + "‚îÅ" * (self.WIDTH - 2) + "‚îì")
        lines.append(self._line(self._center("–°–†–ê–í–ù–ï–ù–ò–ï: –î–û –ò –ü–û–°–õ–ï")[1:-1]))
        lines.append("‚î£" + "‚îÅ" * (self.WIDTH - 2) + "‚î´")
        lines.append(self._line(""))
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–∞–±–ª–∏—Ü—ã —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        header = f"  {'–ü–æ–∫–∞–∑–∞—Ç–µ–ª—å':<25}{'–ë–´–õ–û':>15}{'–°–¢–ê–õ–û':>15}{'–ò–ó–ú–ï–ù–ï–ù–ò–ï':>15}"
        lines.append(self._line(header))
        lines.append(self._line("  " + "‚îÄ" * 70))
        
        def diff_str(before_val: int, after_val: int) -> str:
            diff = after_val - before_val
            if diff > 0:
                return f"+{diff:,}"
            elif diff < 0:
                return f"{diff:,}"
            return "‚Äî"
        
        def format_row(label: str, bef: int, aft: int) -> str:
            bef_str = f"{bef:,}"
            aft_str = f"{aft:,}"
            diff = diff_str(bef, aft)
            return f"  {label:<25}{bef_str:>15}{aft_str:>15}{diff:>15}"
        
        rows = [
            ("–í—Å–µ–≥–æ –¥–µ–ª", before.total_cases, after.total_cases),
            ("–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å—É–¥–µ–π", before.total_judges, after.total_judges),
            ("–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å—Ç–æ—Ä–æ–Ω", before.total_parties, after.total_parties),
            ("–í—Å–µ–≥–æ —Å–æ–±—ã—Ç–∏–π", before.total_events, after.total_events),
        ]
        
        for label, bef, aft in rows:
            lines.append(self._line(format_row(label, bef, aft)))
        
        lines.append(self._line(""))
        lines.append("‚îó" + "‚îÅ" * (self.WIDTH - 2) + "‚îõ")
        
        return lines
    
    def _generate_recommendations(
        self, 
        regions_stats: Dict[str, RegionStats],
        db_stats: DatabaseStats
    ) -> List[str]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"""
        recs = []
        
        # –†–µ–≥–∏–æ–Ω—ã —Å –æ—à–∏–±–∫–∞–º–∏
        error_regions = [
            region.name for region in regions_stats.values()
            if any(c.stop_reason == 'error' for c in region.courts.values())
        ]
        if error_regions:
            names = ", ".join(error_regions[:3])
            if len(error_regions) > 3:
                names += f" (+{len(error_regions) - 3})"
            recs.append(f"–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —Ä–µ–≥–∏–æ–Ω—ã —Å –æ—à–∏–±–∫–∞–º–∏: {names}")
        
        # –ú–Ω–æ–≥–æ –±–µ–∑ —Å—É–¥—å–∏
        if db_stats.smas_without_judge > 100:
            recs.append(f"–û–±–Ω–æ–≤–∏—Ç—å —Å—É–¥–µ–π ({db_stats.smas_without_judge} –¥–µ–ª –°–ú–ê–° –±–µ–∑ —Å—É–¥—å–∏): python main.py --mode update")
        
        # –ú–Ω–æ–≥–æ –¥–µ–ª –±–µ–∑ —Å—Ç–æ—Ä–æ–Ω
        if db_stats.cases_without_parties > 50:
            recs.append(f"–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–µ–ª–∞ –±–µ–∑ —Å—Ç–æ—Ä–æ–Ω: {db_stats.cases_without_parties} —à—Ç")
        
        return recs
    
    def _format_recommendations(self, recs: List[str]) -> List[str]:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"""
        lines = []
        lines.append("‚îè" + "‚îÅ" * (self.WIDTH - 2) + "‚îì")
        lines.append(self._line(self._center("üìå –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò")[1:-1]))
        lines.append("‚î£" + "‚îÅ" * (self.WIDTH - 2) + "‚î´")
        lines.append(self._line(""))
        
        for i, rec in enumerate(recs, 1):
            lines.append(self._line(f"  {i}. {rec}"))
        
        lines.append(self._line(""))
        lines.append("‚îó" + "‚îÅ" * (self.WIDTH - 2) + "‚îõ")
        
        return lines


class StatsReporter:
    """–ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤—ã–≤–æ–¥–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
    
    def __init__(self, db_manager, settings):
        self.collector = StatsCollector(db_manager, settings)
        self.formatter = ReportFormatter(settings)
        self.settings = settings
        self.logger = get_logger('stats_reporter')
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        self.db_stats_before: Optional[DatabaseStats] = None
        self.regions_stats: Dict[str, RegionStats] = {}
    
    async def print_start_report(self, plan: Dict[str, Any]):
        """–í—ã–≤–æ–¥ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –æ—Ç—á—ë—Ç–∞"""
        year = plan.get('year', '2025')
        
        # –°–æ–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        self.db_stats_before = await self.collector.collect_database_stats()
        self.regions_stats = await self.collector.collect_region_stats(year)
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º
        report = self.formatter.format_start_report(
            self.db_stats_before,
            self.regions_stats,
            plan
        )
        
        # –í—ã–≤–æ–¥–∏–º –≤ –∫–æ–Ω—Å–æ–ª—å –∏ –ª–æ–≥
        print(report)
        self.logger.info("\n" + report)
    
    async def print_end_report(self, session_stats: Dict[str, Any]):
        """–í—ã–≤–æ–¥ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –æ—Ç—á—ë—Ç–∞"""
        year = session_stats.get('year', '2025')
        
        # –°–æ–±–∏—Ä–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        db_stats_after = await self.collector.collect_database_stats()
        regions_stats_after = await self.collector.collect_region_stats(year)
        
        # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å –¥–∞–Ω–Ω—ã–º–∏ —Å–µ—Å—Å–∏–∏
        for region_key, region_data in session_stats.get('regions', {}).items():
            if region_key in regions_stats_after:
                for court_key, court_data in region_data.items():
                    if court_key in regions_stats_after[region_key].courts:
                        court = regions_stats_after[region_key].courts[court_key]
                        court.session_queries = court_data.get('queries', 0)
                        court.session_saved = court_data.get('saved', 0)
                        court.session_time = court_data.get('time', '')
                        court.stop_reason = court_data.get('stop_reason', '')
                        court.consecutive_empty_at_stop = court_data.get('consecutive_empty', 0)
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º
        report = self.formatter.format_end_report(
            self.db_stats_before,
            db_stats_after,
            regions_stats_after,
            session_stats
        )
        
        # –í—ã–≤–æ–¥–∏–º
        print(report)
        self.logger.info("\n" + report)
    
    def update_court_session_stats(
        self, 
        region_key: str, 
        court_key: str,
        queries: int = 0,
        saved: int = 0,
        time_str: str = "",
        stop_reason: str = "",
        consecutive_empty: int = 0
    ):
        """–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–µ—Å—Å–∏–∏ –¥–ª—è —Å—É–¥–∞"""
        if region_key in self.regions_stats:
            court = self.regions_stats[region_key].courts.get(court_key)
            if court:
                court.session_queries = queries
                court.session_saved = saved
                court.session_time = time_str
                court.stop_reason = stop_reason
                court.consecutive_empty_at_stop = consecutive_empty


################################################################################
# –§–ê–ô–õ: parsers/court_parser/utils/text_processor.py
################################################################################


"""
–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏ –æ—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞
"""
import re
from datetime import datetime
from typing import List, Optional, Dict


class TextProcessor:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–∞"""
    
    @staticmethod
    def clean(text: str) -> str:
        """–û—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞ –æ—Ç –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤"""
        if not text:
            return ""
        return ' '.join(text.split()).strip()
    
    @staticmethod
    def parse_date(date_str: str, format_str: str = '%d.%m.%Y') -> Optional[datetime]:
        """
        –ü–∞—Ä—Å–∏–Ω–≥ –¥–∞—Ç—ã —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –≥–æ–¥–∞
        
        –ü—Ä–∏–º–µ—Ä—ã:
        '15.01.2025' ‚Üí 2025-01-15
        '15.01.25' ‚Üí 2025-01-15 (–∞–≤—Ç–æ–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ)
        '15.01.1925' ‚Üí None (–Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≥–æ–¥)
        """
        try:
            # –ü–æ–ø—ã—Ç–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞
            parsed = datetime.strptime(date_str.strip(), format_str)
            
            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ì–û–î–ê
            year = parsed.year
            
            # –ï—Å–ª–∏ –≥–æ–¥ –¥–≤—É–∑–Ω–∞—á–Ω—ã–π (0-99), –¥–æ–±–∞–≤–ª—è–µ–º 2000
            if year < 100:
                year = 2000 + year
                parsed = parsed.replace(year=year)
            
            # –ï—Å–ª–∏ –≥–æ–¥ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ 1900-1999, –ø—ã—Ç–∞–µ–º—Å—è –∏—Å–ø—Ä–∞–≤–∏—Ç—å
            elif 1900 <= year < 2000:
                # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 2 —Ü–∏—Ñ—Ä—ã –∏ –¥–æ–±–∞–≤–ª—è–µ–º 2000
                year_last_two = year % 100
                year = 2000 + year_last_two
                parsed = parsed.replace(year=year)
            
            # –í–ê–õ–ò–î–ê–¶–ò–Ø: –≥–æ–¥ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ —Ä–∞–∑—É–º–Ω–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ
            if not (2000 <= parsed.year <= 2030):
                return None
            
            return parsed
            
        except (ValueError, AttributeError):
            return None
    
    @staticmethod
    def split_parties(text: str) -> List[str]:
        """
        –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω
        
        –ü—Ä–∞–≤–∏–ª–∞:
        1. –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∑–∞–ø—è—Ç–æ–π (–æ—Å–Ω–æ–≤–Ω–æ–µ)
        2. –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–π –∫–∞–≤—ã—á–∫–∏ + –ø—Ä–æ–±–µ–ª + –∑–∞–≥–ª–∞–≤–Ω–∞—è –±—É–∫–≤–∞
        
        –ü—Ä–∏–º–µ—Ä—ã:
        '–¢–û–û "–ö–æ–º–ø–∞–Ω–∏—è", –ò–≤–∞–Ω–æ–≤' ‚Üí ['–¢–û–û "–ö–æ–º–ø–∞–Ω–∏—è"', '–ò–≤–∞–Ω–æ–≤']
        '–¢–û–û "–ö–æ–º–ø–∞–Ω–∏—è" –ò–í–ê–ù–û–í' ‚Üí ['–¢–û–û "–ö–æ–º–ø–∞–Ω–∏—è"', '–ò–í–ê–ù–û–í']
        '–ü–µ—Ç—Ä–æ–≤, –°–∏–¥–æ—Ä–æ–≤' ‚Üí ['–ü–µ—Ç—Ä–æ–≤', '–°–∏–¥–æ—Ä–æ–≤']
        """
        import re
        
        if not text.strip():
            return []
        
        # –®–ê–ì 1: –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø—è—Ç—ã–µ –ø–æ—Å–ª–µ –∫–∞–≤—ã—á–µ–∫ –ø–µ—Ä–µ–¥ –∑–∞–≥–ª–∞–≤–Ω—ã–º–∏ –±—É–∫–≤–∞–º–∏
        # –ü–∞—Ç—Ç–µ—Ä–Ω: –∫–∞–≤—ã—á–∫–∞ + –ø—Ä–æ–±–µ–ª—ã + –∑–∞–≥–ª–∞–≤–Ω–∞—è –±—É–∫–≤–∞ (–Ω–∞—á–∞–ª–æ –§–ò–û –∏–ª–∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏)
        # –ü—Ä–∏–º–µ—Ä—ã: '" –ò–í–ê–ù–û–í', '¬ª –¢–û–û', '" –ì–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ–Ω–Ω–æ–µ'
        
        text = re.sub(
            r'(["\¬ª"‚Äû])\s+([–ê-–Ø–Å][–ê-–Ø–Å–∞-—è—ë\s]+)',  # –ü–æ—Å–ª–µ –∫–∞–≤—ã—á–∫–∏ + –ø—Ä–æ–±–µ–ª + –∑–∞–≥–ª–∞–≤–Ω–∞—è
            r'\1, \2',  # –í—Å—Ç–∞–≤–ª—è–µ–º –∑–∞–ø—è—Ç—É—é
            text
        )
        
        # –®–ê–ì 2: –†–∞–∑–¥–µ–ª—è–µ–º –ø–æ –∑–∞–ø—è—Ç—ã–º —Å —É—á–µ—Ç–æ–º –∫–∞–≤—ã—á–µ–∫
        parts = []
        current = ""
        in_quotes = False
        quote_chars = {'"', '¬ª', '"', '‚Äû', '¬´'}
        
        for i, char in enumerate(text):
            if char in quote_chars:
                in_quotes = not in_quotes
            
            if char == ',' and not in_quotes:
                # –ó–∞–ø—è—Ç–∞—è –≤–Ω–µ –∫–∞–≤—ã—á–µ–∫ - —Ä–∞–∑–¥–µ–ª—è–µ–º
                part = current.strip(' .,;-')
                if part and len(part) >= 5:  # –ú–∏–Ω–∏–º—É–º 5 —Å–∏–º–≤–æ–ª–æ–≤
                    parts.append(part)
                current = ""
            else:
                current += char
        
        # –ü–æ—Å–ª–µ–¥–Ω—è—è —á–∞—Å—Ç—å
        part = current.strip(' .,;-')
        if part and len(part) >= 5:
            parts.append(part)
        
        return parts
    
    @staticmethod
    def parse_case_number(case_number: str) -> Optional[Dict[str, str]]:
        """
        –ü–∞—Ä—Å–∏–Ω–≥ –Ω–æ–º–µ—Ä–∞ –¥–µ–ª–∞
        
        –ü—Ä–∏–º–µ—Ä: "6294-25-00-4/215" ‚Üí
        {
            'court_code': '6294',
            'year': '25',
            'middle': '00',
            'case_type': '4',
            'sequence': '215'
        }
        """
        pattern = r'^(\d+)-(\d+)-(\d+)-([0-9–∞-—è–ê-–Ø]+)/(\d+)$'
        match = re.match(pattern, case_number)
        
        if not match:
            return None
        
        return {
            'court_code': match.group(1),
            'year': match.group(2),
            'middle': match.group(3),
            'case_type': match.group(4),
            'sequence': match.group(5)
        }
    
    @staticmethod
    def generate_case_number(region_config: Dict, court_config: Dict, 
                           year: str, sequence: int) -> str:
        """
        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–æ–º–µ—Ä–∞ –¥–µ–ª–∞
        
        –§–æ—Ä–º–∞—Ç: –ö–ê–¢–û+instance-–≥–æ–¥-00-—Ç–∏–ø/–ø–æ—Ä—è–¥–∫–æ–≤—ã–π
        –ü—Ä–∏–º–µ—Ä: 6294-25-00-4/215
        """
        kato = region_config['kato_code']
        instance = court_config['instance_code']
        year_short = year[-2:]
        case_type = court_config['case_type_code']
        
        return f"{kato}{instance}-{year_short}-00-{case_type}/{sequence}"
    
    @staticmethod
    def parse_full_case_number(case_number: str) -> Optional[Dict]:
        """
        –†–∞—Å–ø–∞—Ä—Å–∏—Ç—å –ø–æ–ª–Ω—ã–π –Ω–æ–º–µ—Ä –¥–µ–ª–∞
        
        –í—Ö–æ–¥: "6294-25-00-4/215"
        –í—ã—Ö–æ–¥: {
            'court_code': '6294',
            'year_short': '25',
            'case_type': '4',
            'sequence': '215'
        }
        """
        pattern = r'^(\d+)-(\d+)-(\d+)-([0-9–∞-—è–ê-–Ø]+)/(\d+)$'
        match = re.match(pattern, case_number)
        
        if not match:
            return None
        
        return {
            'court_code': match.group(1),
            'year_short': match.group(2),
            'middle': match.group(3),
            'case_type': match.group(4),
            'sequence': match.group(5)
        }

    @staticmethod
    def find_region_and_court_by_case_number(case_number: str, regions_config: Dict) -> Optional[Dict]:
        """
        –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å region_key –∏ court_key –ø–æ –Ω–æ–º–µ—Ä—É –¥–µ–ª–∞
        
        Args:
            case_number: –ø–æ–ª–Ω—ã–π –Ω–æ–º–µ—Ä –¥–µ–ª–∞ "6294-25-00-4/215"
            regions_config: –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ä–µ–≥–∏–æ–Ω–æ–≤ –∏–∑ settings
        
        Returns:
            {
                'region_key': 'astana',
                'court_key': 'smas',
                'year': '2025',
                'sequence': '215'
            }
        """
        parsed = TextProcessor.parse_full_case_number(case_number)
        if not parsed:
            return None
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–¥ —Å—É–¥–∞ (–ö–ê–¢–û + –∏–Ω—Å—Ç–∞–Ω—Ü–∏—è)
        court_code = parsed['court_code']
        case_type = parsed['case_type']
        
        # –ò—â–µ–º —Ä–µ–≥–∏–æ–Ω –∏ —Å—É–¥ –ø–æ –∫–æ–¥—É
        for region_key, region_config in regions_config.items():
            kato = region_config['kato_code']
            
            for court_key, court_config in region_config['courts'].items():
                instance = court_config['instance_code']
                full_code = f"{kato}{instance}"
                
                if court_code == full_code and court_config['case_type_code'] == case_type:
                    # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–ª–Ω—ã–π –≥–æ–¥ –∏–∑ –∫–æ—Ä–æ—Ç–∫–æ–≥–æ
                    year_short = int(parsed['year_short'])
                    year = f"20{year_short:02d}"
                    
                    return {
                        'region_key': region_key,
                        'court_key': court_key,
                        'year': year,
                        'sequence': parsed['sequence']
                    }
        
        return None


################################################################################
# –§–ê–ô–õ: parsers/court_parser/utils/validators.py
################################################################################


"""
–í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
"""
from typing import Dict, Any, Optional
from datetime import datetime


class ValidationError(Exception):
    """–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏"""
    pass


class DataValidator:
    """–í–∞–ª–∏–¥–∞—Ç–æ—Ä –¥–∞–Ω–Ω—ã—Ö"""
    
    @staticmethod
    def validate_case_data(data: Dict[str, Any]) -> bool:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–µ–ª–∞"""
        # –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
        if not data.get('case_number'):
            raise ValidationError("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–æ–º–µ—Ä –¥–µ–ª–∞")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã
        if len(data['case_number']) > 100:
            raise ValidationError("–ù–æ–º–µ—Ä –¥–µ–ª–∞ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞—Ç—ã
        if data.get('case_date'):
            date = data['case_date']
            if isinstance(date, datetime):
                if not (1990 <= date.year <= 2030):
                    raise ValidationError(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≥–æ–¥: {date.year}")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É–¥—å–∏
        if data.get('judge') and len(data['judge']) > 200:
            raise ValidationError("–ò–º—è —Å—É–¥—å–∏ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ")
        
        return True
    
    @staticmethod
    def validate_party_name(name: str) -> bool:
        """
        –í–∞–ª–∏–¥–∞—Ü–∏—è –∏–º–µ–Ω–∏ —Å—Ç–æ—Ä–æ–Ω—ã
        
        –ü—Ä–∞–≤–∏–ª–∞:
        - –ú–∏–Ω–∏–º—É–º 5 —Å–∏–º–≤–æ–ª–æ–≤
        - –ú–∞–∫—Å–∏–º—É–º 500 —Å–∏–º–≤–æ–ª–æ–≤
        - –ù–µ —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã
        - –ù–µ —Ç–æ–ª—å–∫–æ –∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä–∞ –∏–∑ 2-3 –±—É–∫–≤
        """
        if not name or not name.strip():
            return False
        
        name = name.strip()
        
        # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞
        if len(name) < 5:
            return False
        
        # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞
        if len(name) > 500:
            return False
        
        # –ù–µ —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã
        if name.isdigit():
            return False
        
        # –ù–µ –∫–æ—Ä–æ—Ç–∫–∏–µ –∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä—ã (–ê–û, –¢–û–û –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è)
        if len(name) < 10 and name.replace(' ', '').replace('"', '').isupper():
            return False
        
        return True
    
    @staticmethod
    def validate_event(event: Dict[str, Any]) -> bool:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è —Å–æ–±—ã—Ç–∏—è"""
        if not event.get('event_type'):
            return False
        
        if not event.get('event_date'):
            return False
        
        if len(event['event_type']) > 300:
            raise ValidationError("–¢–∏–ø —Å–æ–±—ã—Ç–∏—è —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π")
        
        return True


################################################################################
# –§–ê–ô–õ: parsers/court_parser/config/__init__.py
################################################################################


from .settings import Settings


################################################################################
# –§–ê–ô–õ: parsers/court_parser/config/settings.py
################################################################################


"""
–ó–∞–≥—Ä—É–∑–∫–∞ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
"""
import json
from pathlib import Path
from typing import Dict, Any, Optional, List


class ConfigurationError(Exception):
    """–û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
    pass


class Settings:
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä—Å–µ—Ä–∞"""
    
    def __init__(self, config_path: str = None):
        if config_path is None:
            config_path = Path(__file__).parent.parent / 'config.json'
        
        self.config = self._load_config(config_path)
        self._validate()
    
    def _load_config(self, path: Path) -> Dict[str, Any]:
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ JSON"""
        if not path.exists():
            raise ConfigurationError(f"–§–∞–π–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω: {path}")
        
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except json.JSONDecodeError as e:
            raise ConfigurationError(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON: {e}")
    
    def _validate(self):
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π"""
        required = ['auth', 'base_url', 'database', 'regions', 'parsing_settings']
        for field in required:
            if field not in self.config:
                raise ConfigurationError(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–ª–µ: {field}")
    
    @property
    def base_url(self) -> str:
        return self.config['base_url']
    
    @property
    def auth(self) -> Dict[str, str]:
        return self.config['auth']
    
    @property
    def database(self) -> Dict[str, Any]:
        return self.config['database']
    
    @property
    def regions(self) -> Dict[str, Any]:
        return self.config['regions']
    
    @property
    def parsing_settings(self) -> Dict[str, Any]:
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞"""
        return self.config['parsing_settings']
    
    @property
    def retry_settings(self) -> Dict[str, Any]:
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∏ retry"""
        return self.config.get('retry_settings', {})
    
    def get_region(self, region_key: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Ä–µ–≥–∏–æ–Ω–∞"""
        if region_key not in self.regions:
            raise ConfigurationError(f"–†–µ–≥–∏–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω: {region_key}")
        return self.regions[region_key]
    
    def get_court(self, region_key: str, court_key: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Å—É–¥–∞"""
        region = self.get_region(region_key)
        if court_key not in region['courts']:
            raise ConfigurationError(f"–°—É–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω: {court_key}")
        return region['courts'][court_key]
    
    def get_target_regions(self) -> List[str]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–≤—ã—Ö —Ä–µ–≥–∏–æ–Ω–æ–≤"""
        target = self.parsing_settings.get('target_regions')
        
        if target is None:
            # –í—Å–µ —Ä–µ–≥–∏–æ–Ω—ã
            return list(self.regions.keys())
        elif isinstance(target, list):
            # –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ä–µ–≥–∏–æ–Ω—ã
            return target
        else:
            raise ConfigurationError("target_regions –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å null –∏–ª–∏ —Å–ø–∏—Å–∫–æ–º")
    
    def get_limit_regions(self) -> Optional[int]:
        """–õ–∏–º–∏—Ç —Ä–µ–≥–∏–æ–Ω–æ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏"""
        return self.parsing_settings.get('limit_regions')
    
    def get_limit_cases_per_region(self) -> Optional[int]:
        """–õ–∏–º–∏—Ç –¥–µ–ª –Ω–∞ —Ä–µ–≥–∏–æ–Ω"""
        return self.parsing_settings.get('limit_cases_per_region')
    
    @property
    def update_settings(self) -> Dict[str, Any]:
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"""
        return self.config.get('update_settings', {})


################################################################################
# –§–ê–ô–õ: parsers/court_parser/auth/__init__.py
################################################################################


from .authenticator import Authenticator


################################################################################
# –§–ê–ô–õ: parsers/court_parser/auth/authenticator.py
################################################################################


# parsers/court_parser/auth/authenticator.py
"""
–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–∞ —Å–∞–π—Ç–µ office.sud.kz
"""

from typing import Dict, Optional
import asyncio
import aiohttp
from selectolax.parser import HTMLParser

from utils.logger import get_logger
from utils.retry import RetryStrategy, RetryConfig, NonRetriableError, RetryableError
from utils.http_utils import HttpHeaders, ViewStateExtractor
import traceback


class AuthenticationError(Exception):
    """–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
    pass


class Authenticator:
    """–ö–ª–∞—Å—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —Å retry"""
    
    def __init__(self, base_url: str, auth_config: Dict[str, str], 
                 retry_config: Optional[Dict] = None):
        self.base_url = base_url
        self.login = auth_config['login']
        self.password = auth_config['password']
        self.user_name = auth_config['user_name']
        self.logger = get_logger('authenticator')
        self.retry_config = retry_config or {}
    
    async def authenticate(self, session_manager) -> bool:
        """–ü–æ–ª–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —Å retry"""
        auth_retry_config = self.retry_config.get('authentication', {})
        
        if not auth_retry_config:
            return await self._do_authenticate(session_manager)
        
        retry_cfg = RetryConfig(auth_retry_config)
        strategy = RetryStrategy(retry_cfg)
        create_new_session = auth_retry_config.get('create_new_session', True)
        
        async def _auth_with_session_reset():
            try:
                return await self._do_authenticate(session_manager)
            except RetryableError:
                if create_new_session:
                    self.logger.debug("–°–æ–∑–¥–∞—é –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é –ø–µ—Ä–µ–¥ retry...")
                    await session_manager.create_session()
                raise
        
        try:
            return await strategy.execute_with_retry(
                _auth_with_session_reset,
                error_context="–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è"
            )
        except Exception as e:
            self.logger.error(f"‚ùå –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å: {e}")
            self.logger.debug(f"Traceback:\n{traceback.format_exc()}")
            raise AuthenticationError(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è: {e}") from e
    
    async def _do_authenticate(self, session_manager) -> bool:
        """–û–¥–∏–Ω —Ü–∏–∫–ª –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
        session = await session_manager.get_session()
        
        self.logger.info("–ù–∞—á–∏–Ω–∞—é –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é...")
        
        # –≠—Ç–∞–ø 1: –ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º—ã
        viewstate, form_ids = await self._load_login_page(session)
        await asyncio.sleep(0.5)
        
        # –≠—Ç–∞–ø 2: –û—Ç–ø—Ä–∞–≤–∫–∞ –ª–æ–≥–∏–Ω–∞
        await self._perform_login(session, viewstate, form_ids)
        await asyncio.sleep(0.5)
        
        # –≠—Ç–∞–ø 3: –ü—Ä–æ–≤–µ—Ä–∫–∞
        if await self._verify_authentication(session):
            self.logger.info("‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞")
            return True
        
        raise RetryableError("–ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞")
    
    async def _load_login_page(self, session: aiohttp.ClientSession) -> tuple:
        """–ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ª–æ–≥–∏–Ω–∞ –∏ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º—ã"""
        url = f"{self.base_url}/index.xhtml?lang=ru"
        headers = self._get_base_headers()
        
        try:
            async with session.get(url, headers=headers) as response:
                if response.status in [500, 502, 503, 504]:
                    raise RetryableError(f"HTTP {response.status}")
                if response.status != 200:
                    raise RetryableError(f"HTTP {response.status}")
                
                html = await response.text()
                
                # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ ViewState
                viewstate = ViewStateExtractor.extract(html)
                if not viewstate:
                    raise RetryableError("ViewState –Ω–µ –Ω–∞–π–¥–µ–Ω")
                
                # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ ID —Ñ–æ—Ä–º—ã
                form_ids = self._extract_auth_form_ids(html)
                
                if not form_ids.get('form_base') or not form_ids.get('submit_button'):
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
                    with open("auth_form_not_found.html", "w", encoding="utf-8") as f:
                        f.write(html)
                    raise RetryableError(
                        f"–§–æ—Ä–º–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ò–∑–≤–ª–µ—á–µ–Ω–æ: {form_ids}"
                    )
                
                self.logger.info(f"üìã –§–æ—Ä–º–∞: {form_ids['form_base']}, –∫–Ω–æ–ø–∫–∞: {form_ids['submit_button']}")
                return viewstate, form_ids
                
        except aiohttp.ClientError as e:
            raise RetryableError(f"–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: {e}")
    
    async def _perform_login(self, session: aiohttp.ClientSession, 
                            viewstate: str, form_ids: Dict[str, str]):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –ª–æ–≥–∏–Ω–∞ –∏ –ø–∞—Ä–æ–ª—è"""
        url = f"{self.base_url}/index.xhtml"
        
        form_base = form_ids['form_base']
        submit_button = form_ids['submit_button']
        
        data = {
            form_base: form_base,
            f'{form_base}:xin': self.login,
            f'{form_base}:password': self.password,
            'javax.faces.ViewState': viewstate,
            'javax.faces.source': submit_button,
            'javax.faces.partial.event': 'click',
            'javax.faces.partial.execute': f'{submit_button} @component',
            'javax.faces.partial.render': '@component',
            'org.richfaces.ajax.component': submit_button,
            submit_button: submit_button,
            'rfExt': 'null',
            'AJAX:EVENTS_COUNT': '1',
            'javax.faces.partial.ajax': 'true'
        }
        
        headers = self._get_ajax_headers()
        headers['Referer'] = url
        
        try:
            async with session.post(url, data=data, headers=headers) as response:
                if response.status in [400, 500, 502, 503, 504]:
                    text = await response.text()
                    self.logger.warning(f"HTTP {response.status} –ø—Ä–∏ –ª–æ–≥–∏–Ω–µ: {text[:200]}")
                    raise RetryableError(f"HTTP {response.status} –ø—Ä–∏ –ª–æ–≥–∏–Ω–µ")
                
                if response.status != 200:
                    raise RetryableError(f"HTTP {response.status}")
                
                self.logger.debug("–õ–æ–≥–∏–Ω –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω")
                
        except aiohttp.ClientError as e:
            raise RetryableError(f"–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: {e}")
    
    async def _verify_authentication(self, session: aiohttp.ClientSession) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
        url = f"{self.base_url}/form/proceedings/services.xhtml"
        
        try:
            async with session.get(url, headers=self._get_base_headers(), 
                                   allow_redirects=False) as response:
                
                if response.status in [301, 302, 303, 307, 308]:
                    raise RetryableError("–†–µ–¥–∏—Ä–µ–∫—Ç - –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω")
                
                if response.status in [401, 403]:
                    raise NonRetriableError(f"HTTP {response.status}: –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω")
                
                if response.status in [500, 502, 503, 504]:
                    raise RetryableError(f"HTTP {response.status}")
                
                if response.status != 200:
                    raise RetryableError(f"HTTP {response.status}")
                
                html = await response.text()
                
                # –ü—Ä–∏–∑–Ω–∞–∫–∏ —É—Å–ø–µ—à–Ω–æ–π –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                checks = [
                    'profile-context-menu' in html,
                    '–í—ã–π—Ç–∏' in html,
                    'logout()' in html,
                    'userInfo.xhtml' in html,
                ]
                
                passed = sum(checks)
                
                if passed >= 2:
                    return True
                
                # –ï—Å–ª–∏ —Ñ–æ—Ä–º–∞ –ª–æ–≥–∏–Ω–∞ - —Ç–æ—á–Ω–æ –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω
                if 'password' in html.lower() and 'xin' in html.lower():
                    raise RetryableError("–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —Ñ–æ—Ä–º–∞ –ª–æ–≥–∏–Ω–∞")
                
                # –•–æ—Ç—è –±—ã 1 –ø—Ä–∏–∑–Ω–∞–∫ - –ø—Ä–∏–Ω–∏–º–∞–µ–º
                if passed >= 1:
                    self.logger.warning(f"‚ö†Ô∏è –¢–æ–ª—å–∫–æ {passed}/4 –ø—Ä–∏–∑–Ω–∞–∫–æ–≤, –Ω–æ –ø—Ä–∏–Ω–∏–º–∞–µ–º")
                    return True
                
                raise RetryableError(f"–ù–µ—Ç –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ ({passed}/4)")
                
        except (RetryableError, NonRetriableError):
            raise
        except aiohttp.ClientError as e:
            raise RetryableError(f"–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: {e}")
    
    def _extract_auth_form_ids(self, html: str) -> Dict[str, str]:
        """–î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ ID —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ñ–æ—Ä–º—ã –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"""
        parser = HTMLParser(html)
        ids = {}
        
        # 1. –ò—â–µ–º –ø–æ–ª–µ email (–ò–ò–ù)
        email_input = parser.css_first('input[type="email"]')
        if email_input and email_input.attributes:
            xin_name = email_input.attributes.get('name', '')
            if ':' in xin_name:
                # "j_idt72:auth:xin" ‚Üí "j_idt72:auth"
                ids['form_base'] = ':'.join(xin_name.split(':')[:-1])
                ids['xin_field'] = xin_name
        
        # 2. –ò—â–µ–º –∫–Ω–æ–ø–∫—É "–í–æ–π—Ç–∏" –≤ —Ñ–æ—Ä–º–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        if ids.get('form_base'):
            for btn in parser.css('input[type="submit"]'):
                if not btn.attributes:
                    continue
                
                btn_name = btn.attributes.get('name', '')
                btn_value = btn.attributes.get('value', '')
                btn_style = btn.attributes.get('style', '')
                
                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ
                if 'display: none' in btn_style or 'display:none' in btn_style:
                    continue
                
                # –ö–Ω–æ–ø–∫–∞ –¥–æ–ª–∂–Ω–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç—å —Ñ–æ—Ä–º–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
                if ids['form_base'] in btn_name:
                    # –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º –∫–Ω–æ–ø–∫—É "–í–æ–π—Ç–∏"
                    if btn_value == '–í–æ–π—Ç–∏':
                        ids['submit_button'] = btn_name
                        break
                    # –ò–ª–∏ –ª—é–±—É—é –≤–∏–¥–∏–º—É—é –∫–Ω–æ–ø–∫—É —Ñ–æ—Ä–º—ã
                    elif 'submit_button' not in ids:
                        ids['submit_button'] = btn_name
        
        self.logger.debug(f"–ò–∑–≤–ª–µ—á—ë–Ω–Ω—ã–µ ID: {ids}")
        return ids
    
    def _get_base_headers(self) -> Dict[str, str]:
        return HttpHeaders.get_base()

    def _get_ajax_headers(self) -> Dict[str, str]:
        return HttpHeaders.get_ajax()


################################################################################
# –§–ê–ô–õ: parsers/court_parser/database/__init__.py
################################################################################


from .db_manager import DatabaseManager
from .models import CaseData, EventData, SearchResult


################################################################################
# –§–ê–ô–õ: parsers/court_parser/database/db_manager.py
################################################################################


"""
–ú–µ–Ω–µ–¥–∂–µ—Ä –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
"""
from typing import Dict, Any, Optional, List, Set
import asyncpg

from database.models import CaseData, EventData
from utils.text_processor import TextProcessor
from utils.validators import DataValidator
from utils.logger import get_logger
from utils.constants import PartyRole


class DatabaseManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
    
    def __init__(self, db_config: Dict[str, Any]):
        self.db_config = db_config
        self.pool: Optional[asyncpg.Pool] = None
        self.text_processor = TextProcessor()
        self.validator = DataValidator()
        self.logger = get_logger('db_manager')
        
        # –ö–µ—à–∏ –¥–ª—è ID —Å—É—â–Ω–æ—Å—Ç–µ–π
        self.judges_cache: Dict[str, int] = {}
        self.parties_cache: Dict[str, int] = {}
        self.event_types_cache: Dict[str, int] = {}
    
    async def connect(self):
        """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î"""
        import traceback
        
        try:
            self.pool = await asyncpg.create_pool(
                host=self.db_config['host'],
                port=self.db_config['port'],
                database=self.db_config['dbname'],
                user=self.db_config['user'],
                password=self.db_config['password'],
                min_size=1,
                max_size=10
            )
            
            # –ó–∞–≥—Ä—É–∑–∫–∞ –∫–µ—à–µ–π
            await self._load_caches()
            
            self.logger.info("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")
            
        except Exception as e:
            self.logger.critical(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î: {e}")
            self.logger.debug(f"Traceback:\n{traceback.format_exc()}")
            raise
    
    async def disconnect(self):
        """–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç –ë–î"""
        if self.pool:
            await self.pool.close()
            self.logger.info("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î –∑–∞–∫—Ä—ã—Ç–æ")
    
    async def save_case(self, case_data: CaseData) -> Dict[str, Any]:
        """
        –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–µ–ª–∞ –≤ –ë–î
        
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: {'status': 'saved'|'updated'|'error', 'case_id': int}
        """
        try:
            # –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
            self.validator.validate_case_data(case_data.to_dict())
            
            async with self.pool.acquire() as conn:
                async with conn.transaction():
                    # 1. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–µ–ª–∞
                    case_id = await self._save_case_record(conn, case_data)
                    
                    if not case_id:
                        return {'status': 'error', 'case_id': None}
                    
                    # 2. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω
                    await self._save_parties(conn, case_id, case_data)
                    
                    # 3. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π
                    await self._save_events(conn, case_id, case_data.events)
                    
                    self.logger.info(f"‚úÖ –î–µ–ª–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {case_data.case_number}")
                    return {'status': 'saved', 'case_id': case_id}
        
        except asyncpg.UniqueViolationError:
            self.logger.debug(f"–î–µ–ª–æ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: {case_data.case_number}")
            return {'status': 'updated', 'case_id': None}
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–µ–ª–∞ {case_data.case_number}: {e}")
            return {'status': 'error', 'case_id': None}
    
    async def _save_case_record(self, conn: asyncpg.Connection, 
                               case_data: CaseData) -> Optional[int]:
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –¥–µ–ª–∞"""
        # –ü–æ–ª—É—á–µ–Ω–∏–µ/—Å–æ–∑–¥–∞–Ω–∏–µ —Å—É–¥—å–∏
        judge_id = None
        if case_data.judge:
            judge_id = await self._get_or_create_judge(conn, case_data.judge)
        
        # –í—Å—Ç–∞–≤–∫–∞ –¥–µ–ª–∞
        query = """
            INSERT INTO cases (case_number, case_date, judge_id)
            VALUES ($1, $2, $3)
            ON CONFLICT (case_number) DO UPDATE 
            SET case_date = EXCLUDED.case_date,
                judge_id = COALESCE(EXCLUDED.judge_id, cases.judge_id),
                updated_at = CURRENT_TIMESTAMP
            RETURNING id
        """
        
        case_id = await conn.fetchval(
            query,
            case_data.case_number,
            case_data.case_date,
            judge_id
        )
        
        return case_id
    
    async def _save_parties(self, conn: asyncpg.Connection, 
                          case_id: int, case_data: CaseData):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω –¥–µ–ª–∞"""
        # –ò—Å—Ç—Ü—ã
        for plaintiff in case_data.plaintiffs:
            if self.validator.validate_party_name(plaintiff):
                party_id = await self._get_or_create_party(conn, plaintiff)
                await self._link_party_to_case(conn, case_id, party_id, PartyRole.PLAINTIFF)
        
        # –û—Ç–≤–µ—Ç—á–∏–∫–∏
        for defendant in case_data.defendants:
            if self.validator.validate_party_name(defendant):
                party_id = await self._get_or_create_party(conn, defendant)
                await self._link_party_to_case(conn, case_id, party_id, PartyRole.DEFENDANT)
    
    async def _save_events(self, conn: asyncpg.Connection, 
                         case_id: int, events: List[EventData]):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –¥–µ–ª–∞"""
        for event in events:
            if self.validator.validate_event(event.to_dict()):
                event_type_id = await self._get_or_create_event_type(
                    conn, event.event_type
                )
                
                await conn.execute(
                    """
                    INSERT INTO case_events (case_id, event_type_id, event_date)
                    VALUES ($1, $2, $3)
                    ON CONFLICT DO NOTHING
                    """,
                    case_id, event_type_id, event.event_date
                )
    
    async def _get_or_create_judge(self, conn: asyncpg.Connection, 
                                  judge_name: str) -> int:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ —Å—É–¥—å–∏"""
        judge_name = self.text_processor.clean(judge_name)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–µ—à–∞
        if judge_name in self.judges_cache:
            return self.judges_cache[judge_name]
        
        # –°–æ–∑–¥–∞–Ω–∏–µ/–ø–æ–ª—É—á–µ–Ω–∏–µ –∏–∑ –ë–î
        judge_id = await conn.fetchval(
            """
            INSERT INTO judges (full_name)
            VALUES ($1)
            ON CONFLICT (full_name) DO UPDATE SET full_name = EXCLUDED.full_name
            RETURNING id
            """,
            judge_name
        )
        
        self.judges_cache[judge_name] = judge_id
        return judge_id
    
    async def _get_or_create_party(self, conn: asyncpg.Connection, 
                                  party_name: str) -> int:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω—ã"""
        party_name = self.text_processor.clean(party_name)
        
        if party_name in self.parties_cache:
            return self.parties_cache[party_name]
        
        party_id = await conn.fetchval(
            """
            INSERT INTO parties (name)
            VALUES ($1)
            ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
            RETURNING id
            """,
            party_name
        )
        
        self.parties_cache[party_name] = party_id
        return party_id
    
    async def _get_or_create_event_type(self, conn: asyncpg.Connection, 
                                       event_type: str) -> int:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è"""
        event_type = self.text_processor.clean(event_type)
        
        if event_type in self.event_types_cache:
            return self.event_types_cache[event_type]
        
        event_type_id = await conn.fetchval(
            """
            INSERT INTO event_types (name)
            VALUES ($1)
            ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
            RETURNING id
            """,
            event_type
        )
        
        self.event_types_cache[event_type] = event_type_id
        return event_type_id
    
    async def _link_party_to_case(self, conn: asyncpg.Connection,
                                 case_id: int, party_id: int, role: str):
        """–°–≤—è–∑—ã–≤–∞–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω—ã —Å –¥–µ–ª–æ–º"""
        await conn.execute(
            """
            INSERT INTO case_parties (case_id, party_id, party_role)
            VALUES ($1, $2, $3)
            ON CONFLICT DO NOTHING
            """,
            case_id, party_id, role
        )
    
    async def _load_caches(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∫–µ—à–µ–π –∏–∑ –ë–î"""
        async with self.pool.acquire() as conn:
            # –°—É–¥—å–∏
            judges = await conn.fetch("SELECT id, full_name FROM judges")
            for row in judges:
                self.judges_cache[row['full_name']] = row['id']
            
            # –°—Ç–æ—Ä–æ–Ω—ã
            parties = await conn.fetch("SELECT id, name FROM parties")
            for row in parties:
                self.parties_cache[row['name']] = row['id']
            
            # –¢–∏–ø—ã —Å–æ–±—ã—Ç–∏–π
            events = await conn.fetch("SELECT id, name FROM event_types")
            for row in events:
                self.event_types_cache[row['name']] = row['id']
        
        self.logger.debug(f"–ö–µ—à–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã: {len(self.judges_cache)} —Å—É–¥–µ–π, "
                         f"{len(self.parties_cache)} —Å—Ç–æ—Ä–æ–Ω, "
                         f"{len(self.event_types_cache)} —Ç–∏–ø–æ–≤ —Å–æ–±—ã—Ç–∏–π")
    
    async def __aenter__(self):
        await self.connect()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.disconnect()
    
    async def get_cases_for_update(self, filters: Dict) -> List[str]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –Ω–æ–º–µ—Ä–∞ –¥–µ–ª –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        """
        defendant_keywords = filters.get('defendant_keywords', [])
        exclude_events = filters.get('exclude_event_types', [])
        interval_days = filters.get('update_interval_days', 2)
        
        # –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ SQL –∑–∞–ø—Ä–æ—Å–∞
        query = """
            SELECT DISTINCT c.case_number, c.case_date
            FROM cases c
        """
        
        conditions = []
        params = []
        param_counter = 1
        
        # –§–ò–õ–¨–¢–† 1: –ü–æ –æ—Ç–≤–µ—Ç—á–∏–∫—É (–µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω)
        if defendant_keywords:
            query += """
                JOIN case_parties cp ON c.id = cp.case_id AND cp.party_role = 'defendant'
                JOIN parties p ON cp.party_id = p.id
            """
            
            keyword_conditions = []
            for keyword in defendant_keywords:
                keyword_conditions.append(f"p.name ILIKE ${param_counter}")
                params.append(f'%{keyword}%')
                param_counter += 1
            
            conditions.append(f"({' OR '.join(keyword_conditions)})")
        
        # –§–ò–õ–¨–¢–† 2: –ò—Å–∫–ª—é—á–∏—Ç—å –¥–µ–ª–∞ —Å –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–º–∏ —Å–æ–±—ã—Ç–∏—è–º–∏
        if exclude_events:
            placeholders = ', '.join([f'${i}' for i in range(param_counter, param_counter + len(exclude_events))])
            
            conditions.append(f"""
                NOT EXISTS (
                    SELECT 1 
                    FROM case_events ce
                    JOIN event_types et ON ce.event_type_id = et.id
                    WHERE ce.case_id = c.id
                    AND et.name IN ({placeholders})
                )
            """)
            
            params.extend(exclude_events)
            param_counter += len(exclude_events)
        
        # –§–ò–õ–¨–¢–† 3: –ù–µ –ø—Ä–æ–≤–µ—Ä—è–ª–∏—Å—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N –¥–Ω–µ–π
        conditions.append(f"""
            (
                c.last_updated_at IS NULL 
                OR c.last_updated_at < NOW() - INTERVAL '{interval_days} days'
            )
        """)
        
        # –°–æ–±–∏—Ä–∞–µ–º WHERE
        if conditions:
            query += " WHERE " + " AND ".join(conditions)
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: —Å—Ç–∞—Ä—ã–µ –¥–µ–ª–∞ –ø–µ—Ä–≤—ã–º–∏
        query += " ORDER BY c.case_date ASC"
        
        # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(query, *params)
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–æ–º–µ—Ä–∞ –¥–µ–ª
        case_numbers = [row['case_number'] for row in rows]
        
        self.logger.info(f"–ù–∞–π–¥–µ–Ω–æ –¥–µ–ª –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {len(case_numbers)}")
        return case_numbers

    async def mark_case_as_updated(self, case_number: str):
        """
        –ü–æ–º–µ—Ç–∏—Ç—å –¥–µ–ª–æ –∫–∞–∫ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–æ–µ
        
        –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –≤–µ—Å—å —Ü–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—à—ë–ª —É—Å–ø–µ—à–Ω–æ:
        - –î–µ–ª–æ –Ω–∞–π–¥–µ–Ω–æ –Ω–∞ —Å–∞–π—Ç–µ
        - –°–æ–±—ã—Ç–∏—è —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω—ã
        - –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ –ë–î
        - –ë–µ–∑ –æ—à–∏–±–æ–∫
        """
        async with self.pool.acquire() as conn:
            await conn.execute("""
                UPDATE cases 
                SET last_updated_at = CURRENT_TIMESTAMP 
                WHERE case_number = $1
            """, case_number)
        
        self.logger.debug(f"–î–µ–ª–æ –ø–æ–º–µ—á–µ–Ω–æ –∫–∞–∫ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω–æ–µ: {case_number}")

    async def get_existing_case_numbers(
        self, 
        region_key: str, 
        court_key: str, 
        year: str,
        settings
    ) -> Set[int]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ—Ä—è–¥–∫–æ–≤—ã—Ö –Ω–æ–º–µ—Ä–æ–≤ –¥–µ–ª –¥–ª—è —Ä–µ–≥–∏–æ–Ω–∞/—Å—É–¥–∞/–≥–æ–¥–∞
        
        Args:
            region_key: –∫–ª—é—á —Ä–µ–≥–∏–æ–Ω–∞ ('astana', 'almaty', ...)
            court_key: –∫–ª—é—á —Å—É–¥–∞ ('smas', 'appellate')
            year: –≥–æ–¥ ('2025')
            settings: —ç–∫–∑–µ–º–ø–ª—è—Ä Settings –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        
        Returns:
            {1, 2, 5, 10, 15, 23, 45, 67, 89, 100, ...}
        
        Example:
            >>> existing = await db.get_existing_case_numbers('astana', 'smas', '2025', settings)
            >>> 1075 in existing
            True
        """
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–µ—Ñ–∏–∫—Å–∞ –Ω–æ–º–µ—Ä–∞
        region_config = settings.get_region(region_key)
        court_config = settings.get_court(region_key, court_key)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –Ω–æ–º–µ—Ä–∞ –¥–µ–ª–∞
        # –ù–∞–ø—Ä–∏–º–µ—Ä: "6294-25-00-4/" –¥–ª—è –ê—Å—Ç–∞–Ω—ã, SMAS, 2025
        kato = region_config['kato_code']
        instance = court_config['instance_code']
        year_short = year[-2:]  # "2025" ‚Üí "25"
        case_type = court_config['case_type_code']
        
        prefix = f"{kato}{instance}-{year_short}-00-{case_type}/"
        
        # SQL –∑–∞–ø—Ä–æ—Å
        query = """
            SELECT case_number
            FROM cases
            WHERE case_number LIKE $1
        """
        
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(query, f"{prefix}%")
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–æ—Ä—è–¥–∫–æ–≤—ã–µ –Ω–æ–º–µ—Ä–∞
        sequence_numbers = set()
        
        for row in rows:
            case_number = row['case_number']
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –∏–∑ "6294-25-00-4/1075"
            if '/' in case_number:
                try:
                    seq_str = case_number.split('/')[-1]
                    seq_num = int(seq_str)
                    sequence_numbers.add(seq_num)
                except (ValueError, IndexError):
                    # –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
                    self.logger.warning(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞: {case_number}")
                    continue
        
        self.logger.info(
            f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –Ω–æ–º–µ—Ä–æ–≤ –¥–ª—è {region_key}/{court_key}/{year}: {len(sequence_numbers)}"
        )
        
        return sequence_numbers
    
    async def get_last_sequence_number(
        self, 
        region_key: str, 
        court_key: str, 
        year: str,
        settings
    ) -> int:
        """
        –ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π) –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –¥–µ–ª–∞ –¥–ª—è —Ä–µ–≥–∏–æ–Ω–∞/—Å—É–¥–∞/–≥–æ–¥–∞
        
        Args:
            region_key: –∫–ª—é—á —Ä–µ–≥–∏–æ–Ω–∞ ('astana')
            court_key: –∫–ª—é—á —Å—É–¥–∞ ('smas', 'appellate')
            year: –≥–æ–¥ ('2025')
            settings: —ç–∫–∑–µ–º–ø–ª—è—Ä Settings
        
        Returns:
            –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –∏–ª–∏ 0 –µ—Å–ª–∏ –¥–µ–ª –Ω–µ—Ç
        
        Example:
            >>> last = await db.get_last_sequence_number('astana', 'smas', '2025', settings)
            >>> last
            1075
        """
        region_config = settings.get_region(region_key)
        court_config = settings.get_court(region_key, court_key)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –Ω–æ–º–µ—Ä–∞ –¥–µ–ª–∞
        kato = region_config['kato_code']
        instance = court_config['instance_code']
        year_short = year[-2:]
        case_type = court_config['case_type_code']
        
        prefix = f"{kato}{instance}-{year_short}-00-{case_type}/"
        
        query = """
            SELECT case_number
            FROM cases
            WHERE case_number LIKE $1
        """
        
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(query, f"{prefix}%")
        
        if not rows:
            self.logger.info(f"–î–µ–ª –¥–ª—è {region_key}/{court_key}/{year} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –Ω–∞—á–∏–Ω–∞–µ–º —Å 1")
            return 0
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä
        max_sequence = 0
        
        for row in rows:
            case_number = row['case_number']
            if '/' in case_number:
                try:
                    seq_str = case_number.split('/')[-1]
                    seq_num = int(seq_str)
                    if seq_num > max_sequence:
                        max_sequence = seq_num
                except (ValueError, IndexError):
                    continue
        
        self.logger.info(
            f"–ü–æ—Å–ª–µ–¥–Ω–∏–π –Ω–æ–º–µ—Ä –¥–ª—è {region_key}/{court_key}/{year}: {max_sequence}"
        )
        
        return max_sequence
    
    def get_smas_instance_codes(self, settings) -> Set[str]:
        """
        –°–æ–±—Ä–∞—Ç—å –≤—Å–µ instance_code –¥–ª—è —Å—É–¥–æ–≤ –°–ú–ê–° –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        
        Returns:
            {'94', '93', ...}
        """
        smas_codes = set()
        
        for region_key, region_config in settings.regions.items():
            courts = region_config.get('courts', {})
            smas_court = courts.get('smas')
            
            if smas_court and smas_court.get('instance_code'):
                smas_codes.add(smas_court['instance_code'])
        
        self.logger.debug(f"–°–ú–ê–° instance_codes: {smas_codes}")
        return smas_codes
    
    async def get_smas_cases_without_judge(
        self, 
        settings,
        interval_days: int = 2
    ) -> List[str]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –Ω–æ–º–µ—Ä–∞ –¥–µ–ª –°–ú–ê–° –±–µ–∑ –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω–æ–≥–æ —Å—É–¥—å–∏
        
        Args:
            settings: —ç–∫–∑–µ–º–ø–ª—è—Ä Settings –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è instance_codes
            interval_days: –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ (–æ–±—â–∏–π –¥–ª—è update mode)
        
        Returns:
            ['7194-25-00-4/123', '7594-25-00-4/456', ...]
        """
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ instance_code –¥–ª—è –°–ú–ê–°
        smas_codes = self.get_smas_instance_codes(settings)
        
        if not smas_codes:
            self.logger.warning("–ù–µ –Ω–∞–π–¥–µ–Ω—ã instance_codes –¥–ª—è –°–ú–ê–° –≤ –∫–æ–Ω—Ñ–∏–≥–µ")
            return []
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è SQL
        # –ù–æ–º–µ—Ä –¥–µ–ª–∞: "7194-25-00-4/123" ‚Üí court_code = "7194" ‚Üí instance = "94"
        # –ü–∞—Ç—Ç–µ—Ä–Ω: —Å–∏–º–≤–æ–ª—ã 3-4 –≤ court_code (–∏–Ω–¥–µ–∫—Å—ã 2-3 –≤ –Ω–æ–º–µ—Ä–µ –¥–æ –ø–µ—Ä–≤–æ–≥–æ –¥–µ—Ñ–∏—Å–∞)
        # SQL: SUBSTRING(case_number FROM 3 FOR 2)
        
        # –°—Ç—Ä–æ–∏–º —É—Å–ª–æ–≤–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ instance_code
        code_conditions = []
        params = []
        param_counter = 1
        
        for code in smas_codes:
            code_conditions.append(f"SUBSTRING(case_number FROM 3 FOR 2) = ${param_counter}")
            params.append(code)
            param_counter += 1
        
        codes_where = f"({' OR '.join(code_conditions)})"
        
        query = f"""
            SELECT case_number
            FROM cases
            WHERE 
                judge_id IS NULL
                AND {codes_where}
                AND (
                    last_updated_at IS NULL
                    OR last_updated_at < NOW() - INTERVAL '{interval_days} days'
                )
            ORDER BY case_date DESC
        """
        
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(query, *params)
        
        case_numbers = [row['case_number'] for row in rows]
        
        self.logger.info(
            f"–ù–∞–π–¥–µ–Ω–æ –¥–µ–ª –°–ú–ê–° –±–µ–∑ —Å—É–¥—å–∏: {len(case_numbers)}"
        )
        
        return case_numbers
    

    # Docs processing:

    async def get_document_keys(self, case_id: int) -> set:
        """–ü–æ–ª—É—á–∏—Ç—å –∫–ª—é—á–∏ —É–∂–µ —Å–∫–∞—á–∞–Ω–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"""
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                "SELECT doc_date, doc_name FROM case_documents WHERE case_id = $1",
                case_id
            )
        return {f"{r['doc_date'].isoformat()}|{ r['doc_name']}" for r in rows}

    async def save_documents(self, case_id: int, documents: List[Dict]) -> int:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö"""
        if not documents:
            return 0
        saved = 0
        async with self.pool.acquire() as conn:
            for doc in documents:
                try:
                    await conn.execute("""
                        INSERT INTO case_documents (case_id, doc_date, doc_name, file_path, downloaded_at)
                        VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)
                        ON CONFLICT (case_id, doc_date, doc_name) DO UPDATE
                        SET file_path = EXCLUDED.file_path, downloaded_at = CURRENT_TIMESTAMP
                    """, case_id, doc['doc_date'], doc['doc_name'], doc['file_path'])
                    saved += 1
                except Exception as e:
                    self.logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞: {e}")
        return saved

    async def get_cases_pending_documents(self, limit: int = None) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å –¥–µ–ª–∞ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"""
        query = """
            SELECT id, case_number FROM cases
            WHERE documents_pending = TRUE
            ORDER BY case_date DESC
        """
        if limit:
            query += f" LIMIT {limit}"
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(query)
        return [{'id': r['id'], 'case_number': r['case_number']} for r in rows]

    async def mark_documents_downloaded(self, case_id: int):
        """–ü–æ–º–µ—Ç–∏—Ç—å —á—Ç–æ –¥–æ–∫—É–º–µ–Ω—Ç—ã —Å–∫–∞—á–∞–Ω—ã"""
        async with self.pool.acquire() as conn:
            await conn.execute("""
                UPDATE cases SET documents_pending = FALSE, documents_checked_at = CURRENT_TIMESTAMP
                WHERE id = $1
            """, case_id)

    async def mark_case_for_documents(self, case_id: int):
        """–ü–æ–º–µ—Ç–∏—Ç—å –¥–µ–ª–æ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"""
        async with self.pool.acquire() as conn:
            await conn.execute(
                "UPDATE cases SET documents_pending = TRUE WHERE id = $1", case_id
            )

    async def get_cases_for_documents(self, filters: Dict, limit: int = None) -> List[Dict]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –¥–µ–ª–∞ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
        
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç—É –∂–µ –ª–æ–≥–∏–∫—É —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏, —á—Ç–æ –∏ get_cases_for_update
        """
        defendant_keywords = filters.get('defendant_keywords', [])
        exclude_events = filters.get('exclude_event_types', [])
        interval_days = filters.get('check_interval_days', 7)
        
        query = """
            SELECT DISTINCT c.id, c.case_number, c.case_date, c.documents_checked_at
            FROM cases c
        """
        
        conditions = []
        params = []
        param_counter = 1
        
        # –§–ò–õ–¨–¢–† 1: –ü–æ –æ—Ç–≤–µ—Ç—á–∏–∫—É (–µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω)
        if defendant_keywords:
            query += """
                JOIN case_parties cp ON c.id = cp.case_id AND cp.party_role = 'defendant'
                JOIN parties p ON cp.party_id = p.id
            """
            
            keyword_conditions = []
            for keyword in defendant_keywords:
                keyword_conditions.append(f"p.name ILIKE ${param_counter}")
                params.append(f'%{keyword}%')
                param_counter += 1
            
            conditions.append(f"({' OR '.join(keyword_conditions)})")
        
        # –§–ò–õ–¨–¢–† 2: –ò—Å–∫–ª—é—á–∏—Ç—å –¥–µ–ª–∞ —Å –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–º–∏ —Å–æ–±—ã—Ç–∏—è–º–∏
        if exclude_events:
            placeholders = ', '.join([f'${i}' for i in range(param_counter, param_counter + len(exclude_events))])
            
            conditions.append(f"""
                NOT EXISTS (
                    SELECT 1 
                    FROM case_events ce
                    JOIN event_types et ON ce.event_type_id = et.id
                    WHERE ce.case_id = c.id
                    AND et.name IN ({placeholders})
                )
            """)
            
            params.extend(exclude_events)
            param_counter += len(exclude_events)
        
        # –§–ò–õ–¨–¢–† 3: –î–æ–∫—É–º–µ–Ω—Ç—ã –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–ª–∏—Å—å –∏–ª–∏ –ø—Ä–æ–≤–µ—Ä—è–ª–∏—Å—å –¥–∞–≤–Ω–æ
        conditions.append(f"""
            (
                c.documents_checked_at IS NULL 
                OR c.documents_checked_at < NOW() - INTERVAL '{interval_days} days'
            )
        """)
        
        # –°–æ–±–∏—Ä–∞–µ–º WHERE
        if conditions:
            query += " WHERE " + " AND ".join(conditions)
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ (–≤—Å–µ –∫–æ–ª–æ–Ω–∫–∏ –µ—Å—Ç—å –≤ SELECT)
        query += " ORDER BY c.documents_checked_at NULLS FIRST, c.case_date DESC"
        
        if limit:
            query += f" LIMIT {limit}"
        
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(query, *params)
        
        self.logger.info(f"–î–µ–ª –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤: {len(rows)}")
        return [{'id': r['id'], 'case_number': r['case_number']} for r in rows]
    
    async def get_case_id(self, case_number: str) -> Optional[int]:
        """–ü–æ–ª—É—á–∏—Ç—å ID –¥–µ–ª–∞ –ø–æ –Ω–æ–º–µ—Ä—É"""
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                "SELECT id FROM cases WHERE case_number = $1",
                case_number
            )
            return row['id'] if row else None
        
    async def update_case(self, case_data: CaseData) -> Dict[str, Any]:
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–µ–ª–∞ (—Å–æ–±—ã—Ç–∏—è, —Å—É–¥—å—è)
        
        Returns:
            {'case_id': int, 'events_added': int}
        """
        try:
            async with self.pool.acquire() as conn:
                # 1. –ü–æ–ª—É—á–∞–µ–º case_id
                case_id = await conn.fetchval(
                    "SELECT id FROM cases WHERE case_number = $1",
                    case_data.case_number
                )
                
                if not case_id:
                    # –î–µ–ª–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ ‚Äî —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤–æ–µ
                    result = await self.save_case(case_data)
                    return {
                        'case_id': result.get('case_id'),
                        'events_added': len(case_data.events)
                    }
                
                # 2. –û–±–Ω–æ–≤–ª—è–µ–º —Å—É–¥—å—é (–µ—Å–ª–∏ –ø–æ—è–≤–∏–ª—Å—è)
                if case_data.judge:
                    judge_id = await self._get_or_create_judge(conn, case_data.judge)
                    await conn.execute(
                        "UPDATE cases SET judge_id = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2",
                        judge_id, case_id
                    )
                
                # 3. –ü–æ–ª—É—á–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Å–æ–±—ã—Ç–∏—è
                existing_events = await conn.fetch("""
                    SELECT et.name, ce.event_date 
                    FROM case_events ce
                    JOIN event_types et ON ce.event_type_id = et.id
                    WHERE ce.case_id = $1
                """, case_id)
                
                existing_keys = {
                    f"{row['name']}|{row['event_date'].isoformat()}" 
                    for row in existing_events
                }
                
                # 4. –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è
                events_added = 0
                for event in case_data.events:
                    event_key = f"{event.event_type}|{event.event_date.isoformat()}"
                    if event_key not in existing_keys:
                        event_type_id = await self._get_or_create_event_type(conn, event.event_type)
                        await conn.execute("""
                            INSERT INTO case_events (case_id, event_type_id, event_date)
                            VALUES ($1, $2, $3)
                            ON CONFLICT DO NOTHING
                        """, case_id, event_type_id, event.event_date)
                        events_added += 1
                
                # 5. –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–∫—É –≤—Ä–µ–º–µ–Ω–∏
                await conn.execute(
                    "UPDATE cases SET last_updated_at = CURRENT_TIMESTAMP WHERE id = $1",
                    case_id
                )
                
                return {'case_id': case_id, 'events_added': events_added}
        
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–µ–ª–∞ {case_data.case_number}: {e}")
            return {'case_id': None, 'events_added': 0}


################################################################################
# –§–ê–ô–õ: parsers/court_parser/database/models.py
################################################################################


"""
–°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ë–î
"""
from dataclasses import dataclass, field
from datetime import datetime, date
from typing import List, Optional


@dataclass
class CaseData:
    """–î–∞–Ω–Ω—ã–µ –¥–µ–ª–∞"""
    case_number: str
    case_date: Optional[date] = None
    judge: Optional[str] = None
    plaintiffs: List[str] = field(default_factory=list)
    defendants: List[str] = field(default_factory=list)
    events: List['EventData'] = field(default_factory=list)
    result_index: Optional[int] = None  # –ò–Ω–¥–µ–∫—Å –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö –ø–æ–∏—Å–∫–∞ (–Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –ë–î)
    
    def to_dict(self) -> dict:
        """–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ —Å–ª–æ–≤–∞—Ä—å (–±–µ–∑ result_index ‚Äî –æ–Ω –Ω–µ –¥–ª—è –ë–î)"""
        return {
            'case_number': self.case_number,
            'case_date': self.case_date,
            'judge': self.judge,
            'plaintiffs': self.plaintiffs,
            'defendants': self.defendants,
            'events': [e.to_dict() for e in self.events]
        }


@dataclass
class EventData:
    """–î–∞–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è"""
    event_type: str
    event_date: date
    
    def to_dict(self) -> dict:
        return {
            'event_type': self.event_type,
            'event_date': self.event_date
        }


@dataclass
class SearchResult:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞"""
    found: bool
    case_data: Optional[CaseData] = None
    error: Optional[str] = None


@dataclass
class DocumentInfo:
    """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–æ–∫—É–º–µ–Ω—Ç–µ"""
    index: int  # –ò–Ω–¥–µ–∫—Å –∏–∑ onclick (—É–∂–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ)
    doc_date: date
    doc_name: str
    doc_type: str = ""
    
    @property
    def unique_key(self) -> str:
        return f"{self.doc_date.isoformat()}|{self.doc_name}"
    
    def to_dict(self) -> dict:
        return {
            'index': self.index,
            'doc_date': self.doc_date,
            'doc_name': self.doc_name,
            'doc_type': self.doc_type
        }


################################################################################
# –§–ê–ô–õ: parsers/court_parser/parsing/__init__.py
################################################################################


from .html_parser import ResultsParser
from .data_extractor import DataExtractor


################################################################################
# –§–ê–ô–õ: parsers/court_parser/parsing/data_extractor.py
################################################################################


"""
–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ HTML —ç–ª–µ–º–µ–Ω—Ç–æ–≤
"""
from typing import List, Tuple, Optional
from datetime import date

from database.models import EventData
from utils.text_processor import TextProcessor
from utils.logger import get_logger


class DataExtractor:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ HTML —ç–ª–µ–º–µ–Ω—Ç–æ–≤"""
    
    def __init__(self):
        self.text_processor = TextProcessor()
        self.logger = get_logger('data_extractor')
    
    def extract_case_info(self, cell) -> Tuple[str, Optional[date]]:
        """
        –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ –¥–µ–ª–∞ –∏ –¥–∞—Ç—ã
        
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: (case_number, case_date)
        """
        paragraphs = cell.css('p')
        case_number = ""
        case_date = None
        
        if paragraphs:
            # –ü–µ—Ä–≤—ã–π –ø–∞—Ä–∞–≥—Ä–∞—Ñ - –Ω–æ–º–µ—Ä –¥–µ–ª–∞
            case_number = self.text_processor.clean(paragraphs[0].text())
            
            # –í—Ç–æ—Ä–æ–π –ø–∞—Ä–∞–≥—Ä–∞—Ñ - –¥–∞—Ç–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            if len(paragraphs) > 1:
                date_str = self.text_processor.clean(paragraphs[1].text())
                parsed_date = self.text_processor.parse_date(date_str)
                if parsed_date:
                    case_date = parsed_date.date()
        
        return case_number, case_date
    
    def extract_parties(self, cell) -> Tuple[List[str], List[str]]:
        """
        –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω –¥–µ–ª–∞
        
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: (plaintiffs, defendants)
        """
        paragraphs = cell.css('p')
        plaintiffs = []
        defendants = []
        
        if len(paragraphs) >= 2:
            # –ü–µ—Ä–≤—ã–π –ø–∞—Ä–∞–≥—Ä–∞—Ñ - –∏—Å—Ç—Ü—ã
            plaintiffs_text = self.text_processor.clean(paragraphs[0].text())
            if plaintiffs_text:
                plaintiffs = self.text_processor.split_parties(plaintiffs_text)
            
            # –í—Ç–æ—Ä–æ–π –ø–∞—Ä–∞–≥—Ä–∞—Ñ - –æ—Ç–≤–µ—Ç—á–∏–∫–∏
            defendants_text = self.text_processor.clean(paragraphs[1].text())
            if defendants_text:
                defendants = self.text_processor.split_parties(defendants_text)
        
        return plaintiffs, defendants
    
    def extract_judge(self, cell) -> Optional[str]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–º–µ–Ω–∏ —Å—É–¥—å–∏"""
        judge_text = self.text_processor.clean(cell.text())
        return judge_text if judge_text else None
    
    def extract_events(self, cell) -> List[EventData]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π –¥–µ–ª–∞"""
        paragraphs = cell.css('p')
        events = []
        
        for paragraph in paragraphs:
            text = self.text_processor.clean(paragraph.text())
            
            # –§–æ—Ä–º–∞—Ç: "15.01.2025 - –î–µ–ª–æ –ø—Ä–∏–Ω—è—Ç–æ –∫ –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤—É"
            if ' - ' in text:
                try:
                    date_part, event_part = text.split(' - ', 1)
                    
                    parsed_date = self.text_processor.parse_date(date_part)
                    event_type = self.text_processor.clean(event_part)
                    
                    if parsed_date and event_type:
                        events.append(EventData(
                            event_type=event_type,
                            event_date=parsed_date.date()
                        ))
                except ValueError:
                    continue
        
        return events


################################################################################
# –§–ê–ô–õ: parsers/court_parser/parsing/document_parser.py
################################################################################


"""
–ü–∞—Ä—Å–∏–Ω–≥ —Å—Ç—Ä–∞–Ω–∏—Ü —Å –¥–æ–∫—É–º–µ–Ω—Ç–∞–º–∏
"""
from typing import Dict, List, Optional, Tuple
import re
from selectolax.parser import HTMLParser

from database.models import DocumentInfo
from utils.text_processor import TextProcessor
from utils.logger import get_logger
from utils.http_utils import ViewStateExtractor


class DocumentParser:
    """–ü–∞—Ä—Å–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"""
    
    def __init__(self):
        self.text_processor = TextProcessor()
        self.logger = get_logger('document_parser')
    
    def extract_case_card_form(self, html: str) -> Optional[Dict[str, str]]:
        """
        –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º—ã –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –∫–∞—Ä—Ç–æ—á–∫–∏ –¥–µ–ª–∞ –∏–∑ lawsuitList.xhtml
        """
        pattern = r'viewSelectedLawsuit\s*=\s*function\s*\([^)]*\)\s*\{\s*RichFaces\.ajax\s*\(\s*["\']([^"\']+)["\']'
        match = re.search(pattern, html)
        
        if not match:
            self.logger.warning("viewSelectedLawsuit –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return None
        
        ajax_id = match.group(1)
        form_id = ajax_id.rsplit(':', 1)[0]
        viewstate = self._extract_viewstate(html)
        
        if not viewstate:
            return None
        
        return {
            'form_id': form_id,
            'ajax_id': ajax_id,
            'viewstate': viewstate
        }
    
    def extract_document_list(self, html: str) -> Tuple[List[DocumentInfo], Optional[Dict[str, str]]]:
        """
        –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –∏–∑ documentList.xhtml
        """
        parser = HTMLParser(html)
        documents = []
        
        rows = parser.css('table tbody tr.hover-effect')
        
        for row in rows:
            cells = row.css('td')
            if len(cells) < 3:
                continue
            
            # –î–∞—Ç–∞
            date_text = self.text_processor.clean(cells[0].text())
            doc_date = self.text_processor.parse_date(date_text)
            if not doc_date:
                continue
            
            # –¢–∏–ø
            doc_type = self.text_processor.clean(cells[1].text())
            
            # –ò–º—è –∏ –∏–Ω–¥–µ–∫—Å
            link = cells[2].css_first('a')
            if not link:
                continue
            
            doc_name = self.text_processor.clean(link.text())
            onclick = link.attributes.get('onclick', '')
            index_match = re.search(r'viewInlineDoc\s*\(\s*(\d+)\s*\)', onclick)
            
            if not index_match:
                continue
            
            documents.append(DocumentInfo(
                index=int(index_match.group(1)),
                doc_date=doc_date.date(),
                doc_name=doc_name,
                doc_type=doc_type
            ))
        
        form_data = self._extract_document_form(html)
        return documents, form_data
    
    def _extract_document_form(self, html: str) -> Optional[Dict[str, str]]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º—ã –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞"""
        pattern = r'viewInlineDoc\s*=\s*function\s*\([^)]*\)\s*\{\s*RichFaces\.ajax\s*\(\s*["\']([^"\']+)["\']'
        match = re.search(pattern, html)
        
        if not match:
            return None
        
        ajax_id = match.group(1)
        form_id = ajax_id.rsplit(':', 1)[0]
        viewstate = self._extract_viewstate(html)
        
        return {
            'form_id': form_id,
            'ajax_id': ajax_id,
            'viewstate': viewstate
        }
    
    def extract_pdf_url(self, html: str) -> Optional[str]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ URL –¥–æ–∫—É–º–µ–Ω—Ç–∞ –∏–∑ document.xhtml"""
        parser = HTMLParser(html)
        
        embed = parser.css_first('embed[type="application/pdf"]')
        if embed and embed.attributes:
            return embed.attributes.get('src')
        
        embed = parser.css_first('embed[src*=".pdf"]')
        if embed and embed.attributes:
            return embed.attributes.get('src')
        
        return None
    
    def _extract_viewstate(self, html: str) -> Optional[str]:
        return ViewStateExtractor.extract(html)


################################################################################
# –§–ê–ô–õ: parsers/court_parser/parsing/html_parser.py
################################################################################


"""
–ü–∞—Ä—Å–∏–Ω–≥ HTML —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
"""
import re
from typing import List, Optional
from selectolax.parser import HTMLParser

from database.models import CaseData
from parsing.data_extractor import DataExtractor
from utils.logger import get_logger


class ResultsParser:
    """–ü–∞—Ä—Å–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞"""
    
    NO_RESULTS_MESSAGES = [
        "–ü–æ —É–∫–∞–∑–∞–Ω–Ω—ã–º –¥–∞–Ω–Ω—ã–º –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ",
        "–ö”©—Ä—Å–µ—Ç—ñ–ª–≥–µ–Ω –¥–µ—Ä–µ–∫—Ç–µ—Ä –±–æ–π—ã–Ω–∞ –µ—à–Ω”ô—Ä—Å–µ —Ç–∞–±—ã–ª–º–∞–¥—ã"
    ]
    
    def __init__(self):
        self.extractor = DataExtractor()
        self.logger = get_logger('results_parser')
    
    def parse(self, html: str) -> List[CaseData]:
        """
        –ü–∞—Ä—Å–∏–Ω–≥ HTML —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
        
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: —Å–ø–∏—Å–æ–∫ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –¥–µ–ª —Å result_index
        """
        parser = HTMLParser(html)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        if self._is_no_results(parser):
            self.logger.debug("–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
            return []
        
        # –ü–æ–∏—Å–∫ —Ç–∞–±–ª–∏—Ü—ã —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
        table = parser.css_first('table')
        if not table:
            self.logger.warning("–¢–∞–±–ª–∏—Ü–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ HTML")
            return []
        
        # –ü–∞—Ä—Å–∏–Ω–≥ —Å—Ç—Ä–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
        results = self._parse_table(table)
        
        self.logger.debug(f"–†–∞—Å–ø–∞—Ä—Å–µ–Ω–æ –¥–µ–ª: {len(results)}")
        return results
    
    def _is_no_results(self, parser: HTMLParser) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
        content = parser.css_first('.tab__inner-content')
        if not content:
            return True
        
        text = content.text()
        return any(msg in text for msg in self.NO_RESULTS_MESSAGES)
    
    def _parse_table(self, table) -> List[CaseData]:
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ç–∞–±–ª–∏—Ü—ã —Å –¥–µ–ª–∞–º–∏"""
        rows = table.css('tbody tr')
        results = []
        
        for row in rows:
            try:
                case_data = self._parse_row(row)
                if case_data:
                    results.append(case_data)
            except Exception as e:
                self.logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å—Ç—Ä–æ–∫–∏: {e}")
                continue
        
        return results
    
    def _parse_row(self, row) -> Optional[CaseData]:
        """–ü–∞—Ä—Å–∏–Ω–≥ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã —Å –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ–º result_index"""
        cells = row.css('td')
        
        if len(cells) < 4:
            return None
        
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ result_index –∏–∑ onclick –∞—Ç—Ä–∏–±—É—Ç–∞ —Å—Ç—Ä–æ–∫–∏
        result_index = self._extract_result_index(row)
        
        # –Ø—á–µ–π–∫–∞ 1: –ù–æ–º–µ—Ä –¥–µ–ª–∞ –∏ –¥–∞—Ç–∞
        case_number, case_date = self.extractor.extract_case_info(cells[0])
        if not case_number:
            return None
        
        # –Ø—á–µ–π–∫–∞ 2: –°—Ç–æ—Ä–æ–Ω—ã
        plaintiffs, defendants = self.extractor.extract_parties(cells[1])
        
        # –Ø—á–µ–π–∫–∞ 3: –°—É–¥—å—è
        judge = self.extractor.extract_judge(cells[2])
        
        # –Ø—á–µ–π–∫–∞ 4: –ò—Å—Ç–æ—Ä–∏—è (—Å–æ–±—ã—Ç–∏—è)
        events = self.extractor.extract_events(cells[3])
        
        return CaseData(
            case_number=case_number,
            case_date=case_date,
            judge=judge,
            plaintiffs=plaintiffs,
            defendants=defendants,
            events=events,
            result_index=result_index
        )
    
    def _extract_result_index(self, row) -> Optional[int]:
        """
        –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞ –∏–∑ onclick –∞—Ç—Ä–∏–±—É—Ç–∞ —Å—Ç—Ä–æ–∫–∏
        
        –ü—Ä–∏–º–µ—Ä: onclick="viewSelectedLawsuit(1);" ‚Üí 1
        """
        if not row.attributes:
            return None
        
        onclick = row.attributes.get('onclick', '')
        
        # –ü–∞—Ç—Ç–µ—Ä–Ω: viewSelectedLawsuit(N)
        match = re.search(r'viewSelectedLawsuit\s*\(\s*(\d+)\s*\)', onclick)
        
        if match:
            return int(match.group(1))
        
        return None
    
    def find_case_index(self, cases: List[CaseData], target_case_number: str) -> Optional[int]:
        """
        –ù–∞–π—Ç–∏ result_index –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –Ω–æ–º–µ—Ä–∞ –¥–µ–ª–∞
        
        Args:
            cases: —Å–ø–∏—Å–æ–∫ —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω—ã—Ö –¥–µ–ª
            target_case_number: –∏—Å–∫–æ–º—ã–π –Ω–æ–º–µ—Ä –¥–µ–ª–∞
        
        Returns:
            result_index –∏–ª–∏ None –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
        """
        for case in cases:
            if case.case_number == target_case_number:
                return case.result_index
        
        return None


################################################################################
# –§–ê–ô–õ: parsers/court_parser/search/__init__.py
################################################################################


from .form_handler import FormHandler
from .search_engine import SearchEngine


################################################################################
# –§–ê–ô–õ: parsers/court_parser/search/document_handler.py
################################################################################


# parsers/court_parser/search/document_handler.py
"""
–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ —Å—É–¥–µ–±–Ω—ã—Ö –¥–µ–ª
"""
from typing import Dict, List, Optional, Set
from pathlib import Path
import asyncio
import re
import aiohttp

from parsing.document_parser import DocumentParser
from database.models import DocumentInfo
from utils.text_processor import TextProcessor
from utils.logger import get_logger
from utils.http_utils import HttpHeaders, AjaxRequestBuilder


class DocumentHandler:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"""
    
    def __init__(self, base_url: str, storage_dir: str = "./court_documents", regions_config: Dict = None):
        self.base_url = base_url
        self.storage_dir = Path(storage_dir)
        self.storage_dir.mkdir(parents=True, exist_ok=True)
        self.parser = DocumentParser()
        self.text_processor = TextProcessor()
        self.regions_config = regions_config or {}
        self.logger = get_logger('document_handler')
    
    def _get_case_folder(self, case_number: str) -> Path:
        """
        –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–∞–ø–∫—É –¥–ª—è –¥–µ–ª–∞ –ø–æ –Ω–æ–º–µ—Ä—É
        
        –í—Ö–æ–¥: "7594-25-00-4/5229"
        –í—ã—Ö–æ–¥: documents/almaty/smas/2025/7594-25-00-4_5229/
        """
        # –ü–∞—Ä—Å–∏–º –Ω–æ–º–µ—Ä –¥–µ–ª–∞
        case_info = self.text_processor.find_region_and_court_by_case_number(
            case_number, self.regions_config
        )
        
        if case_info:
            region_key = case_info['region_key']
            court_key = case_info['court_key']
            year = case_info['year']
        else:
            # Fallback: –∏–∑–≤–ª–µ–∫–∞–µ–º –≥–æ–¥ –∏–∑ –Ω–æ–º–µ—Ä–∞ –¥–µ–ª–∞
            # "7594-25-00-4/5229" ‚Üí –≥–æ–¥ = "2025"
            match = re.match(r'\d+-(\d{2})-', case_number)
            if match:
                year_short = match.group(1)
                year = f"20{year_short}"
            else:
                year = "unknown"
            
            region_key = "unknown"
            court_key = "unknown"
        
        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–º—è –ø–∞–ø–∫–∏ –¥–ª—è –¥–µ–ª–∞
        safe_case = case_number.replace('/', '_')
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—É—Ç—å: documents/region/court/year/case_number/
        folder = self.storage_dir / region_key / court_key / year / safe_case
        folder.mkdir(parents=True, exist_ok=True)
        
        return folder
    
    def _save_file(self, case_number: str, doc_info: DocumentInfo, content: bytes) -> str:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª –Ω–∞ –¥–∏—Å–∫ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π –ø–∞–ø–æ–∫"""
        # –ü–æ–ª—É—á–∞–µ–º –ø–∞–ø–∫—É –¥–ª—è –¥–µ–ª–∞
        case_dir = self._get_case_folder(case_number)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞
        date_prefix = doc_info.doc_date.strftime('%Y-%m-%d')
        safe_name = self._sanitize_filename(doc_info.doc_name)
        filename = f"{date_prefix}_{safe_name}"
        
        if not filename.lower().endswith('.pdf'):
            filename += '.pdf'
        
        file_path = case_dir / filename
        
        with open(file_path, 'wb') as f:
            f.write(content)
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –æ—Ç storage_dir
        relative_path = file_path.relative_to(self.storage_dir)
        
        self.logger.info(f"–°–æ—Ö—Ä–∞–Ω—ë–Ω: {relative_path}")
        return str(relative_path)
    
    def _sanitize_filename(self, filename: str) -> str:
        """–û—á–∏—Å—Ç–∫–∞ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞"""
        if filename.lower().endswith('.pdf'):
            filename = filename[:-4]
        filename = re.sub(r'[<>:"/\\|?*]', '_', filename)
        filename = re.sub(r'\s+', '_', filename)
        filename = re.sub(r'_+', '_', filename).strip('_')
        return filename[:100] if len(filename) > 100 else filename
    
    async def open_case_card(self, session: aiohttp.ClientSession,
                             results_html: str, case_index: int = 0) -> bool:
        """–û—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É –¥–µ–ª–∞ –∏–∑ —Å–ø–∏—Å–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
        form_data = self.parser.extract_case_card_form(results_html)
        if not form_data:
            return False
        
        url = f"{self.base_url}/lawsuit/lawsuitList.xhtml"
        
        data = AjaxRequestBuilder.build(
            form_id=form_data['form_id'],
            ajax_id=form_data['ajax_id'],
            viewstate=form_data['viewstate'],
            extra_params={'param1': str(case_index)}
        )
        
        headers = HttpHeaders.get_ajax()
        headers['Referer'] = url
        
        async with session.post(url, data=data, headers=headers) as response:
            return response.status == 200
    
    async def get_document_list(self, session: aiohttp.ClientSession):
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"""
        url = f"{self.base_url}/lawsuit/documentList.xhtml"
        headers = HttpHeaders.get_base()
        headers['Referer'] = f"{self.base_url}/lawsuit/lawsuitList.xhtml"
        
        async with session.get(url, headers=headers) as response:
            if response.status != 200:
                return [], None
            html = await response.text()
            return self.parser.extract_document_list(html)
    
    async def open_document(self, session: aiohttp.ClientSession,
                            form_data: Dict[str, str], doc_index: int) -> bool:
        """–û—Ç–∫—Ä—ã—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç –ø–æ –∏–Ω–¥–µ–∫—Å—É"""
        url = f"{self.base_url}/lawsuit/documentList.xhtml"
        
        data = AjaxRequestBuilder.build(
            form_id=form_data['form_id'],
            ajax_id=form_data['ajax_id'],
            viewstate=form_data['viewstate'],
            extra_params={'param1': str(doc_index)}
        )
        
        headers = HttpHeaders.get_ajax()
        async with session.post(url, data=data, headers=headers) as response:
            return response.status == 200
    
    async def get_document_page(self, session: aiohttp.ClientSession) -> Optional[str]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å PDF viewer"""
        url = f"{self.base_url}/lawsuit/document.xhtml"
        headers = HttpHeaders.get_base()
        headers['Referer'] = f"{self.base_url}/lawsuit/documentList.xhtml"
        
        async with session.get(url, headers=headers) as response:
            if response.status != 200:
                return None
            return await response.text()
    
    async def download_pdf(self, session: aiohttp.ClientSession, pdf_url: str,
                           case_number: str, doc_info: DocumentInfo) -> Optional[str]:
        """–°–∫–∞—á–∞—Ç—å PDF —Ñ–∞–π–ª"""
        full_url = f"{self.base_url}{pdf_url}" if pdf_url.startswith('/') else pdf_url
        headers = HttpHeaders.get_base()
        headers['Referer'] = f"{self.base_url}/lawsuit/document.xhtml"
        
        async with session.get(full_url, headers=headers) as response:
            if response.status != 200:
                return None
            content = await response.read()
            return self._save_file(case_number, doc_info, content)
    
    async def fetch_all_documents(
        self, 
        session: aiohttp.ClientSession,
        results_html: str, 
        case_number: str,
        case_index: int = 0,
        existing_keys: Optional[Set[str]] = None,
        delay: float = 1.0
    ) -> List[Dict]:
        """–°–∫–∞—á–∞—Ç—å –≤—Å–µ –Ω–æ–≤—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã –¥–ª—è –¥–µ–ª–∞"""
        existing_keys = existing_keys or set()
        downloaded = []
        
        if not await self.open_case_card(session, results_html, case_index):
            return downloaded
        
        await asyncio.sleep(delay)
        
        documents, form_data = await self.get_document_list(session)
        if not documents or not form_data:
            return downloaded
        
        new_docs = [d for d in documents if d.unique_key not in existing_keys]
        if not new_docs:
            self.logger.info(f"–ù–æ–≤—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –Ω–µ—Ç –¥–ª—è {case_number}")
            return downloaded
        
        self.logger.info(f"–ù–æ–≤—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤: {len(new_docs)}")
        
        for doc in new_docs:
            try:
                if not await self.open_document(session, form_data, doc.index):
                    continue
                await asyncio.sleep(delay)
                
                doc_html = await self.get_document_page(session)
                if not doc_html:
                    continue
                
                pdf_url = self.parser.extract_pdf_url(doc_html)
                if not pdf_url:
                    continue
                
                file_path = await self.download_pdf(session, pdf_url, case_number, doc)
                if file_path:
                    downloaded.append({
                        'doc_date': doc.doc_date,
                        'doc_name': doc.doc_name,
                        'file_path': file_path
                    })
                
                await asyncio.sleep(delay)
            except Exception as e:
                self.logger.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è {doc.doc_name}: {e}")
        
        return downloaded
    
    def _get_headers(self) -> Dict[str, str]:
        return HttpHeaders.get_base()

    def _get_ajax_headers(self) -> Dict[str, str]:
        return HttpHeaders.get_ajax()


################################################################################
# –§–ê–ô–õ: parsers/court_parser/search/form_handler.py
################################################################################


"""
–†–∞–±–æ—Ç–∞ —Å –ø–æ–∏—Å–∫–æ–≤–æ–π —Ñ–æ—Ä–º–æ–π
"""
from typing import Dict, Optional
import asyncio
import re
import aiohttp
from selectolax.parser import HTMLParser

from utils.logger import get_logger
from utils.retry import NonRetriableError
from utils.http_utils import HttpHeaders, ViewStateExtractor


class FormHandler:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–∏—Å–∫–æ–≤–æ–π —Ñ–æ—Ä–º—ã —Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º ID"""
    
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.logger = get_logger('form_handler')
        
        # –ö–µ—à ID —Ñ–æ—Ä–º—ã (–∏–∑–≤–ª–µ–∫–∞–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑ –∑–∞ —Å–µ—Å—Å–∏—é)
        self._cached_form_ids: Optional[Dict[str, str]] = None
        self._cache_initialized: bool = False
        self._cache_lock: asyncio.Lock = asyncio.Lock()

    async def prepare_search_form(self, session: aiohttp.ClientSession) -> tuple:
        """
        –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ñ–æ—Ä–º—ã –ø–æ–∏—Å–∫–∞
        
        - ViewState: –∏–∑–≤–ª–µ–∫–∞–µ—Ç—Å—è –ö–ê–ñ–î–´–ô —Ä–∞–∑ (—É–Ω–∏–∫–∞–ª–µ–Ω –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞)
        - Form IDs: –∏–∑–≤–ª–µ–∫–∞—é—Ç—Å—è –û–î–ò–ù —Ä–∞–∑ –∏ –∫–µ—à–∏—Ä—É—é—Ç—Å—è
        
        Returns:
            (viewstate, form_ids)
        """
        url = f"{self.base_url}/form/lawsuit/"
        headers = self._get_headers()
        
        try:
            async with session.get(url, headers=headers) as response:
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ HTTP –æ—à–∏–±–æ–∫
                if response.status in [400, 401, 403, 404]:
                    raise NonRetriableError(f"HTTP {response.status}: –ü–æ—Å—Ç–æ—è–Ω–Ω–∞—è –æ—à–∏–±–∫–∞")
                
                if response.status in [500, 502, 503, 504]:
                    raise aiohttp.ClientError(f"HTTP {response.status}: –°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
                
                if response.status != 200:
                    raise aiohttp.ClientError(f"HTTP {response.status}: –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞")
                
                html = await response.text()
                
                # ViewState ‚Äî –≤—Å–µ–≥–¥–∞ –∏–∑–≤–ª–µ–∫–∞–µ–º –∑–∞–Ω–æ–≤–æ
                viewstate = self._extract_viewstate(html)
                
                # Form IDs ‚Äî –∏–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑ (—Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π)
                async with self._cache_lock:
                    if not self._cache_initialized:
                        self._cached_form_ids = self._extract_form_ids(html)
                        self._cache_initialized = True
                        
                        self.logger.info("üìã ID —Ñ–æ—Ä–º—ã –∏–∑–≤–ª–µ—á–µ–Ω—ã –∏ –∑–∞–∫–µ—à–∏—Ä–æ–≤–∞–Ω—ã:")
                        for key, value in self._cached_form_ids.items():
                            self.logger.info(f"   {key}: {value}")
                
                return viewstate, self._cached_form_ids
        
        except (aiohttp.ClientError, NonRetriableError):
            raise
        
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ —Ñ–æ—Ä–º—ã: {e}")
            raise aiohttp.ClientError(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ —Ñ–æ—Ä–º—ã: {e}")

    def reset_cache(self):
        """
        –°–±—Ä–æ—Å –∫–µ—à–∞ ID —Ñ–æ—Ä–º—ã
        
        –í—ã–∑—ã–≤–∞—Ç—å –ø—Ä–∏:
        - –ü–µ—Ä–µ–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        - –û—à–∏–±–∫–∞—Ö, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–º–∏ ID
        """
        # –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: —ç—Ç–æ—Ç –º–µ—Ç–æ–¥ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π, –Ω–æ –±–µ–∑–æ–ø–∞—Å–µ–Ω
        # —Ç.–∫. –ø—Ä–æ—Å—Ç–æ —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Ñ–ª–∞–≥–∏ (–∞—Ç–æ–º–∞—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ Python)
        self._cached_form_ids = None
        self._cache_initialized = False
        self.logger.debug("–ö–µ—à ID —Ñ–æ—Ä–º—ã —Å–±—Ä–æ—à–µ–Ω")
    
    async def select_region(self, session: aiohttp.ClientSession, 
                           viewstate: str, region_id: str, 
                           form_ids: Dict[str, str]):
        """–í—ã–±–æ—Ä —Ä–µ–≥–∏–æ–Ω–∞ –≤ —Ñ–æ—Ä–º–µ"""
        url = f"{self.base_url}/form/lawsuit/index.xhtml"
        form_base = form_ids.get('form_base', 'j_idt45:j_idt46')
        
        data = {
            form_base: form_base,
            f'{form_base}:edit-district': region_id,
            f'{form_base}:edit-district-hide': '',
            f'{form_base}:edit-court': '',
            f'{form_base}:edit-year': '',
            f'{form_base}:edit-iin': '',
            f'{form_base}:edit-num': '',
            f'{form_base}:edit-fio': '',
            'javax.faces.ViewState': viewstate,
            'javax.faces.source': f'{form_base}:edit-district',
            'javax.faces.partial.event': 'change',
            'javax.faces.partial.execute': f'{form_base}:edit-district @component',
            'javax.faces.partial.render': '@component',
            'javax.faces.behavior.event': 'change',
            'org.richfaces.ajax.component': f'{form_base}:edit-district',
            'rfExt': 'null',
            'AJAX:EVENTS_COUNT': '1',
            'javax.faces.partial.ajax': 'true'
        }
        
        headers = self._get_ajax_headers()
        
        try:
            async with session.post(url, data=data, headers=headers) as response:
                if response.status in [400, 401, 403, 404]:
                    raise NonRetriableError(f"HTTP {response.status}")
                
                if response.status in [500, 502, 503, 504]:
                    raise aiohttp.ClientError(f"HTTP {response.status}")
                
                if response.status != 200:
                    raise aiohttp.ClientError(f"HTTP {response.status}")
                
                self.logger.debug(f"–†–µ–≥–∏–æ–Ω –≤—ã–±—Ä–∞–Ω: {region_id}")
        
        except (aiohttp.ClientError, NonRetriableError):
            raise
        
        except Exception as e:
            raise aiohttp.ClientError(f"–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞ —Ä–µ–≥–∏–æ–Ω–∞: {e}")
    
    def _extract_viewstate(self, html: str) -> Optional[str]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ ViewState"""
        return ViewStateExtractor.extract(html)
    
    def _extract_form_ids(self, html: str) -> Dict[str, str]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ ID —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ñ–æ—Ä–º—ã"""
        parser = HTMLParser(html)
        ids = {}
        
        # –ü–æ–∏—Å–∫ –±–∞–∑–æ–≤–æ–≥–æ ID —Ñ–æ—Ä–º—ã
        form = parser.css_first('form')
        if form and form.attributes and form.attributes.get('id'):
            ids['form_id'] = form.attributes['id']
        
        # –ü–æ–∏—Å–∫ –ø–æ–ª–µ–π —Ñ–æ—Ä–º—ã
        field_mappings = ['edit-district', 'edit-court', 'edit-year', 'edit-num']
        
        for field in field_mappings:
            elements = parser.css(f'[id*="{field}"]')
            for element in elements:
                if element.attributes and element.attributes.get('id'):
                    ids[field] = element.attributes['id']
                    name = element.attributes.get('name', '')
                    if ':' in name:
                        ids['form_base'] = ':'.join(name.split(':')[:-1])
                    break
        
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ ID –∫–Ω–æ–ø–∫–∏ –ø–æ–∏—Å–∫–∞
        search_button = self._extract_search_button_id(html, ids.get('form_base', ''))
        if search_button:
            ids['search_button'] = search_button
        else:
            self.logger.warning("ID –∫–Ω–æ–ø–∫–∏ –ø–æ–∏—Å–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω, –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω fallback")
        
        return ids
    
    def _extract_search_button_id(self, html: str, form_base: str) -> Optional[str]:
        """
        –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ ID –∫–Ω–æ–ø–∫–∏ –ø–æ–∏—Å–∫–∞ –∏–∑ RichFaces —Å–∫—Ä–∏–ø—Ç–∞
        
        –ò—â–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω: goNext = function(...) { RichFaces.ajax("ID", ...)
        """
        import re
        
        pattern = r'goNext\s*=\s*function\s*\([^)]*\)\s*\{\s*RichFaces\.ajax\s*\(\s*["\']([^"\']+)["\']'
        match = re.search(pattern, html)
        
        if match:
            button_id = match.group(1)
            
            # –í–∞–ª–∏–¥–∞—Ü–∏—è: ID –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å form_base
            if form_base and not button_id.startswith(form_base):
                self.logger.warning(
                    f"ID '{button_id}' –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç form_base '{form_base}'"
                )
                return None
            
            return button_id
        
        return None
    
    def _get_headers(self) -> Dict[str, str]:
        """–ë–∞–∑–æ–≤—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏"""
        return HttpHeaders.get_base()

    def _get_ajax_headers(self) -> Dict[str, str]:
        """AJAX –∑–∞–≥–æ–ª–æ–≤–∫–∏"""
        return HttpHeaders.get_ajax()


################################################################################
# –§–ê–ô–õ: parsers/court_parser/search/search_engine.py
################################################################################


"""
–ü–æ–∏—Å–∫–æ–≤—ã–π –¥–≤–∏–∂–æ–∫
"""
from typing import Dict
import asyncio
import aiohttp

from utils.logger import get_logger
from utils.retry import NonRetriableError
from utils.http_utils import HttpHeaders


class SearchEngine:
    """–î–≤–∏–∂–æ–∫ –¥–ª—è –ø–æ–∏—Å–∫–∞ –¥–µ–ª"""
    
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.logger = get_logger('search_engine')
    
    async def search_case(
        self, 
        session: aiohttp.ClientSession,
        viewstate: str, 
        region_id: str, 
        court_id: str,
        year: str, 
        sequence_number: int,
        form_ids: Dict[str, str]
    ) -> str:
        """
        –ü–æ–∏—Å–∫ –¥–µ–ª–∞ –ø–æ –ø–æ—Ä—è–¥–∫–æ–≤–æ–º—É –Ω–æ–º–µ—Ä—É
        
        Args:
            sequence_number: –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä (1, 2, 3, ...)
        
        Returns:
            HTML —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏
        """
        await self._send_search_request(
            session, viewstate, region_id, court_id,
            year, sequence_number, form_ids
        )
        
        await asyncio.sleep(0.5)
        
        results_html = await self._get_results(session)
        
        self.logger.debug(f"–ü–æ–∏—Å–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω –¥–ª—è –Ω–æ–º–µ—Ä–∞: {sequence_number}")
        return results_html
    
    async def _send_search_request(
        self, 
        session: aiohttp.ClientSession,
        viewstate: str, 
        region_id: str, 
        court_id: str,
        year: str, 
        sequence_number: int,
        form_ids: Dict[str, str]
    ):
        """
        –û—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ–∏—Å–∫–æ–≤–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
        
        –í edit-num –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä
        """
        url = f"{self.base_url}/form/lawsuit/index.xhtml"
        form_base = form_ids.get('form_base', 'j_idt45:j_idt46')
        
        search_button = form_ids.get('search_button')
        if not search_button:
            search_button = f'{form_base}:j_idt83'
            self.logger.warning(f"Fallback ID –∫–Ω–æ–ø–∫–∏: {search_button}")
        
        # –í—Å–µ–≥–¥–∞ –ø–µ—Ä–µ–¥–∞—ë–º —Ç–æ–ª—å–∫–æ –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä
        search_number = str(sequence_number)
        
        data = {
            form_base: form_base,
            f'{form_base}:edit-district': region_id,
            f'{form_base}:edit-district-hide': region_id,
            f'{form_base}:edit-court': court_id,
            f'{form_base}:edit-year': year,
            f'{form_base}:edit-iin': '',
            f'{form_base}:edit-num': search_number,
            f'{form_base}:edit-fio': '',
            'javax.faces.ViewState': viewstate,
            'javax.faces.source': search_button,
            'javax.faces.partial.execute': f'{search_button} @component',
            'javax.faces.partial.render': '@component',
            'param1': f'{form_base}:edit-num',
            'org.richfaces.ajax.component': search_button,
            search_button: search_button,
            'rfExt': 'null',
            'AJAX:EVENTS_COUNT': '1',
            'javax.faces.partial.ajax': 'true'
        }
        
        self.logger.debug(f"üîç –ü–æ–∏—Å–∫: —Ä–µ–≥–∏–æ–Ω={region_id}, —Å—É–¥={court_id}, –≥–æ–¥={year}, –Ω–æ–º–µ—Ä={search_number}")
        
        headers = self._get_ajax_headers()
        
        try:
            async with session.post(url, data=data, headers=headers) as response:
                if response.status in [400, 401, 403, 404]:
                    raise NonRetriableError(f"HTTP {response.status}")
                
                if response.status in [500, 502, 503, 504]:
                    raise aiohttp.ClientError(f"HTTP {response.status}")
                
                if response.status != 200:
                    raise aiohttp.ClientError(f"HTTP {response.status}")
                
                await response.text()
        
        except (aiohttp.ClientError, NonRetriableError):
            raise
        except Exception as e:
            raise aiohttp.ClientError(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {e}")
    
    async def _get_results(self, session: aiohttp.ClientSession) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏"""
        url = f"{self.base_url}/lawsuit/lawsuitList.xhtml"
        headers = self._get_headers()
        
        try:
            async with session.get(url, headers=headers) as response:
                if response.status in [400, 401, 403, 404]:
                    raise NonRetriableError(f"HTTP {response.status}")
                
                if response.status in [500, 502, 503, 504]:
                    raise aiohttp.ClientError(f"HTTP {response.status}")
                
                if response.status != 200:
                    raise aiohttp.ClientError(f"HTTP {response.status}")
                
                return await response.text()
        
        except (aiohttp.ClientError, NonRetriableError):
            raise
        except Exception as e:
            raise aiohttp.ClientError(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: {e}")
    
    def _get_headers(self) -> Dict[str, str]:
        """–ë–∞–∑–æ–≤—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏"""
        return HttpHeaders.get_base()

    def _get_ajax_headers(self) -> Dict[str, str]:
        """AJAX –∑–∞–≥–æ–ª–æ–≤–∫–∏"""
        return HttpHeaders.get_ajax()


################################################################################
# –§–ê–ô–õ: parsers/court_parser/core/__init__.py
################################################################################


from core.parser import CourtParser
from core.session import SessionManager
from core.region_worker import RegionWorker


################################################################################
# –§–ê–ô–õ: parsers/court_parser/core/parser.py
################################################################################


"""
–ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å –ø–∞—Ä—Å–µ—Ä–∞ —Å retry –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ–º
"""
from typing import Dict, Any, Optional, List, Tuple
import asyncio
import aiohttp

from config.settings import Settings
from core.session import SessionManager
from auth.authenticator import Authenticator
from search.form_handler import FormHandler
from search.search_engine import SearchEngine
from parsing.html_parser import ResultsParser
from database.db_manager import DatabaseManager
from database.models import CaseData, SearchResult
from utils.text_processor import TextProcessor
from utils.logger import get_logger
from utils.retry import RetryStrategy, RetryConfig, NonRetriableError
from utils.constants import CaseStatus
import traceback

class CourtParser:
    """–ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å –ø–∞—Ä—Å–µ—Ä–∞"""
    
    def __init__(self, config_path: Optional[str] = None):
        # –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        self.settings = Settings(config_path)
        
        # Retry –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        self.retry_config = self.settings.config.get('retry_settings', {})
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        self.session_manager = SessionManager(
            timeout=30,
            retry_config=self.retry_config
        )
        
        self.authenticator = Authenticator(
            self.settings.base_url,
            self.settings.auth,
            retry_config=self.retry_config
        )
        
        self.form_handler = FormHandler(self.settings.base_url)
        self.search_engine = SearchEngine(self.settings.base_url)
        self.results_parser = ResultsParser()
        self.db_manager = DatabaseManager(self.settings.database)
        self.text_processor = TextProcessor()
        
        # Lock –¥–ª—è stateful –æ–ø–µ—Ä–∞—Ü–∏–π
        self.form_lock = asyncio.Lock()
        
        # –°—á—ë—Ç—á–∏–∫–∏ –æ—à–∏–±–æ–∫
        self.session_error_count = 0
        self.max_session_errors = 10
        self.reauth_count = 0
        self.max_reauth = self.retry_config.get('session_recovery', {}).get(
            'max_reauth_attempts', 2
        )
        
        
        self.logger = get_logger('court_parser')
        self.logger.info("üöÄ –ü–∞—Ä—Å–µ—Ä –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

    async def search_case_by_number(self, case_number: str) -> Tuple[Optional[str], List[CaseData]]:
        """
        –ü–æ–∏—Å–∫ –¥–µ–ª–∞ –ø–æ –Ω–æ–º–µ—Ä—É
        
        Args:
            case_number: –ø–æ–ª–Ω—ã–π –Ω–æ–º–µ—Ä –¥–µ–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä '7599-25-00-4–∞/215')
        
        Returns:
            (results_html, parsed_cases) ‚Äî HTML –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –∏ —Å–ø–∏—Å–æ–∫ –¥–µ–ª
            (None, []) ‚Äî –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–≥–∏–æ–Ω
        """
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–µ–≥–∏–æ–Ω –∏ —Å—É–¥ –ø–æ –Ω–æ–º–µ—Ä—É –¥–µ–ª–∞
        case_info = self.text_processor.find_region_and_court_by_case_number(
            case_number, self.settings.regions
        )
        
        if not case_info:
            self.logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–≥–∏–æ–Ω: {case_number}")
            return None, []
        
        region_config = self.settings.get_region(case_info['region_key'])
        court_config = self.settings.get_court(case_info['region_key'], case_info['court_key'])
        
        # –ü–æ–∏—Å–∫ —á–µ—Ä–µ–∑ —Ñ–æ—Ä–º—É
        async with self.form_lock:
            session = await self.session_manager.get_session()
            
            viewstate, form_ids = await self.form_handler.prepare_search_form(session)
            
            await self.form_handler.select_region(
                session, viewstate, region_config['id'], form_ids
            )
            
            await asyncio.sleep(1)
            
            results_html = await self.search_engine.search_case(
                session, viewstate,
                region_config['id'],
                court_config['id'],
                case_info['year'],
                int(case_info['sequence']),
                form_ids
            )
        
        # –ü–∞—Ä—Å–∏–Ω–≥
        cases = self.results_parser.parse(results_html)
        
        return results_html, cases
    
    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è"""
        try:
            await self.db_manager.connect()
            await self.authenticator.authenticate(self.session_manager)
            self.logger.info("‚úÖ –ü–∞—Ä—Å–µ—Ä –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ")
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
            self.logger.debug(f"Traceback:\n{traceback.format_exc()}")
            await self.cleanup()
            raise
    
    async def cleanup(self):
        """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤"""
        try:
            await self.db_manager.disconnect()
        except:
            pass
        
        try:
            await self.session_manager.close()
        except:
            pass
        
        self.logger.info("–†–µ—Å—É—Ä—Å—ã –æ—á–∏—â–µ–Ω—ã")
    
    async def search_and_save(
        self, 
        region_key: str, 
        court_key: str,
        sequence_number: int, 
        year: str = "2025"
    ) -> Dict[str, Any]:
        """
        –ü–æ–∏—Å–∫ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–µ–ª–∞
        
        Args:
            region_key: –∫–ª—é—á —Ä–µ–≥–∏–æ–Ω–∞ ('astana')
            court_key: –∫–ª—é—á —Å—É–¥–∞ ('smas', 'appellate')
            sequence_number: –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä (1, 2, 3, ...)
            year: –≥–æ–¥ ('2025')
        
        Returns:
            {
                'success': True/False,
                'saved': True/False,
                'case_number': '6294-25-00-4/215',
                'error': None –∏–ª–∏ —Å—Ç—Ä–æ–∫–∞
            }
        """
        search_retry_config = self.retry_config.get('search_case', {})
        
        if not search_retry_config:
            return await self._do_search_and_save(
                region_key, court_key, sequence_number, year
            )
        
        # –° retry
        retry_cfg = RetryConfig(search_retry_config)
        strategy = RetryStrategy(retry_cfg, self.session_manager.circuit_breaker)
        
        async def _search_with_recovery():
            try:
                return await self._do_search_and_save(
                    region_key, court_key, sequence_number, year
                )
            except Exception as e:
                if await self._handle_session_recovery(e):
                    return await self._do_search_and_save(
                        region_key, court_key, sequence_number, year
                    )
                raise
        
        try:
            result = await strategy.execute_with_retry(
                _search_with_recovery,
                error_context=f"–ü–æ–∏—Å–∫ –¥–µ–ª–∞ #{sequence_number}"
            )
            self.session_error_count = 0
            return result
        
        except NonRetriableError as e:
            return {
                'success': False,
                'saved': False,
                'case_number': None,
                'error': str(e)
            }
        
        except Exception as e:
            self.session_error_count += 1
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {e}")
            return {
                'success': False,
                'saved': False,
                'case_number': None,
                'error': str(e)
            }
    
    async def _do_search_and_save(
        self, 
        region_key: str, 
        court_key: str,
        sequence_number: int, 
        year: str
    ) -> Dict[str, Any]:
        """
        –û–¥–∏–Ω —Ü–∏–∫–ª –ø–æ–∏—Å–∫–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        """
        region_config = self.settings.get_region(region_key)
        court_config = self.settings.get_court(region_key, court_key)
        
        target_case_number = self.text_processor.generate_case_number(
            region_config, court_config, year, sequence_number
        )
        
        self.logger.info(f"üîç –ò—â—É –¥–µ–ª–æ: {target_case_number}")
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—â–∏–π –º–µ—Ç–æ–¥ –ø–æ–∏—Å–∫–∞
        results_html, cases = await self.search_case_by_number(target_case_number)
        
        if results_html is None:
            return {
                'success': False,
                'saved': False,
                'case_number': target_case_number,
                'error': CaseStatus.REGION_NOT_FOUND
            }
        
        if not cases:
            self.logger.info(f"‚ùå –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ: {target_case_number}")
            return {
                'success': False,
                'saved': False,
                'case_number': target_case_number,
                'error': CaseStatus.NO_RESULTS
            }
        
        # –í—ã–±–æ—Ä –¥–µ–ª–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        case_to_save = self._select_case_to_save(
            cases, court_key, target_case_number
        )
        
        if not case_to_save:
            self.logger.warning(f"‚ö†Ô∏è –¶–µ–ª–µ–≤–æ–µ –¥–µ–ª–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ: {target_case_number}")
            return {
                'success': False,
                'saved': False,
                'case_number': target_case_number,
                'error': CaseStatus.TARGET_NOT_FOUND
            }
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        save_result = await self.db_manager.save_case(case_to_save)
        
        if save_result['status'] in [CaseStatus.SAVED, CaseStatus.UPDATED]:
            judge_info = "‚úÖ —Å—É–¥—å—è" if case_to_save.judge else "‚ö†Ô∏è –±–µ–∑ —Å—É–¥—å–∏"
            parties = len(case_to_save.plaintiffs) + len(case_to_save.defendants)
            events = len(case_to_save.events)
            
            self.logger.info(
                f"‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {case_to_save.case_number} "
                f"({judge_info}, {parties} —Å—Ç–æ—Ä–æ–Ω, {events} —Å–æ–±—ã—Ç–∏–π)"
            )
            
            return {
                'success': True,
                'saved': True,
                'case_number': case_to_save.case_number,
                'results_html': results_html  # –î–æ–±–∞–≤–ª—è–µ–º –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
            }
        
        return {
            'success': False,
            'saved': False,
            'case_number': target_case_number,
            'error': CaseStatus.SAVE_FAILED
        }
    
    def _select_case_to_save(
        self, 
        cases: List[CaseData], 
        court_key: str, 
        target_case_number: str
    ) -> Optional[CaseData]:
        """
        –í—ã–±–æ—Ä –¥–µ–ª–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ —Ç–æ—á–Ω–æ–º—É —Å–æ–≤–ø–∞–¥–µ–Ω–∏—é –Ω–æ–º–µ—Ä–∞
        """
        result = next(
            (case for case in cases if case.case_number == target_case_number), 
            None
        )
        
        if result is None and cases:
            self.logger.debug(
                f"–ü–æ–ª—É—á–µ–Ω–æ {len(cases)} –¥–µ–ª, —Ü–µ–ª–µ–≤–æ–µ {target_case_number} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ: "
                f"{[c.case_number for c in cases]}"
            )
        
        return result
    
    async def _handle_session_recovery(self, error: Exception) -> bool:
        """–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ—Å—Å–∏–∏"""
        if not (isinstance(error, (aiohttp.ClientError, NonRetriableError)) 
                and '401' in str(error)):
            return False
        
        if self.reauth_count >= self.max_reauth:
            return False
        
        self.reauth_count += 1
        self.logger.warning(f"‚ö†Ô∏è –ü–µ—Ä–µ–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è ({self.reauth_count}/{self.max_reauth})...")
        
        try:
            await self.authenticator.authenticate(self.session_manager)
            self.form_handler.reset_cache()
            self.session_error_count = 0
            self.logger.info("‚úÖ –ü–µ—Ä–µ–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå –ü–µ—Ä–µ–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å: {e}")
            return False 
    
    async def __aenter__(self):
        await self.initialize()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.cleanup()
        return False


################################################################################
# –§–ê–ô–õ: parsers/court_parser/core/region_worker.py
################################################################################


"""
–ò–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤–æ—Ä–∫–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–¥–Ω–æ–≥–æ —Ä–µ–≥–∏–æ–Ω–∞
"""
import ssl
import asyncio
from typing import Dict, Any, Optional

import aiohttp

from config.settings import Settings
from auth.authenticator import Authenticator
from search.form_handler import FormHandler
from search.search_engine import SearchEngine
from parsing.html_parser import ResultsParser
from database.models import CaseData
from utils.text_processor import TextProcessor
from utils.logger import setup_worker_logger
from utils.constants import CaseStatus
import traceback


class RegionWorker:
    """
    –ò–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤–æ—Ä–∫–µ—Ä –¥–ª—è –æ–¥–Ω–æ–≥–æ —Ä–µ–≥–∏–æ–Ω–∞
    
    –ö–∞–∂–¥—ã–π –≤–æ—Ä–∫–µ—Ä –∏–º–µ–µ—Ç:
    - –°–≤–æ—é HTTP-—Å–µ—Å—Å–∏—é
    - –°–≤–æ–π FormHandler —Å –æ—Ç–¥–µ–ª—å–Ω—ã–º –∫–µ—à–µ–º
    - –°–≤–æ–π SearchEngine
    
    –≠—Ç–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ø–æ–ª–Ω—É—é –∏–∑–æ–ª—è—Ü–∏—é —Å–æ—Å—Ç–æ—è–Ω–∏—è —Ñ–æ—Ä–º—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.
    """
    
    def __init__(self, settings: Settings, region_key: str):
        self.settings = settings
        self.region_key = region_key
        self.logger = setup_worker_logger(region_key)
        
        self.session: Optional[aiohttp.ClientSession] = None
        self.form_handler: Optional[FormHandler] = None
        self.search_engine: Optional[SearchEngine] = None
        self.results_parser = ResultsParser()
        self.text_processor = TextProcessor()
        
        self.authenticated = False
        self.retry_config = settings.config.get('retry_settings', {})
    
    async def initialize(self) -> bool:
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–æ—Ä–∫–µ—Ä–∞: —Å–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏ –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
        
        Returns:
            True –µ—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ, False –ø—Ä–∏ –æ—à–∏–±–∫–µ
        """
        try:
            await self._create_session()
            
            self.form_handler = FormHandler(self.settings.base_url)
            self.search_engine = SearchEngine(self.settings.base_url)
            
            authenticator = Authenticator(
                self.settings.base_url,
                self.settings.auth,
                retry_config=self.retry_config
            )
            
            self.authenticated = await authenticator.authenticate(self)
            
            if self.authenticated:
                self.logger.info(f"–í–æ—Ä–∫–µ—Ä {self.region_key} –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω")
            
            return self.authenticated
            
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤–æ—Ä–∫–µ—Ä–∞ {self.region_key}: {e}")
            self.logger.debug(f"Traceback:\n{traceback.format_exc()}")
            return False
    
    async def _create_session(self):
        """–°–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π HTTP-—Å–µ—Å—Å–∏–∏"""
        if self.session and not self.session.closed:
            await self.session.close()
        
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        
        connector = aiohttp.TCPConnector(ssl=ssl_context, limit=5)
        timeout = aiohttp.ClientTimeout(total=30)
        
        self.session = aiohttp.ClientSession(
            timeout=timeout,
            connector=connector
        )
        
        self.logger.debug(f"–°–æ–∑–¥–∞–Ω–∞ —Å–µ—Å—Å–∏—è –¥–ª—è {self.region_key}")
    
    async def create_session(self):
        """–ü—É–±–ª–∏—á–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Å—Å–∏–∏ (–¥–ª—è Authenticator)"""
        await self._create_session()
    
    async def get_session(self) -> aiohttp.ClientSession:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–µ—Å—Å–∏—é (–¥–ª—è Authenticator)"""
        if not self.session or self.session.closed:
            await self._create_session()
        return self.session
    
    async def search_and_save(
        self,
        db_manager,
        court_key: str,
        sequence_number: int,
        year: str
    ) -> Dict[str, Any]:
        """
        –ü–æ–∏—Å–∫ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–µ–ª–∞
        
        Args:
            db_manager: –º–µ–Ω–µ–¥–∂–µ—Ä –ë–î (–æ–±—â–∏–π)
            court_key: –∫–ª—é—á —Å—É–¥–∞ ('smas', 'appellate')
            sequence_number: –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –¥–µ–ª–∞
            year: –≥–æ–¥
        
        Returns:
            {
                'success': True/False,
                'saved': True/False,
                'case_number': str,
                'error': str or None
            }
        """
        if not self.authenticated:
            return {
                'success': False,
                'saved': False,
                'case_number': None,
                'error': 'not_authenticated'
            }
        
        try:
            return await self._do_search_and_save(
                db_manager, court_key, sequence_number, year
            )
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ #{sequence_number}: {e}")
            return {
                'success': False,
                'saved': False,
                'case_number': None,
                'error': str(e)
            }
    
    async def _do_search_and_save(
        self,
        db_manager,
        court_key: str,
        sequence_number: int,
        year: str
    ) -> Dict[str, Any]:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è"""
        region_config = self.settings.get_region(self.region_key)
        court_config = self.settings.get_court(self.region_key, court_key)
        
        target_case_number = self.text_processor.generate_case_number(
            region_config, court_config, year, sequence_number
        )
        
        self.logger.debug(f"–ü–æ–∏—Å–∫: {target_case_number}")
        
        results_html, cases = await self._search_case(
            region_config, court_config, year, sequence_number
        )
        
        if results_html is None:
            return {
                'success': False,
                'saved': False,
                'case_number': target_case_number,
                'error': CaseStatus.REGION_NOT_FOUND
            }
        
        if not cases:
            self.logger.debug(f"–ù–µ –Ω–∞–π–¥–µ–Ω–æ: {target_case_number}")
            return {
                'success': False,
                'saved': False,
                'case_number': target_case_number,
                'error': CaseStatus.NO_RESULTS
            }
        
        case_to_save = next(
            (c for c in cases if c.case_number == target_case_number),
            None
        )
        
        if not case_to_save:
            self.logger.debug(f"–¶–µ–ª–µ–≤–æ–µ –¥–µ–ª–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å—Ä–µ–¥–∏ {len(cases)} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤")
            return {
                'success': False,
                'saved': False,
                'case_number': target_case_number,
                'error': CaseStatus.TARGET_NOT_FOUND
            }
        
        save_result = await db_manager.save_case(case_to_save)
        
        if save_result['status'] in [CaseStatus.SAVED, CaseStatus.UPDATED]:
            self.logger.info(
                f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {case_to_save.case_number} | "
                f"—Å—É–¥—å—è: {'–¥–∞' if case_to_save.judge else '–Ω–µ—Ç'} | "
                f"—Å—Ç–æ—Ä–æ–Ω: {len(case_to_save.plaintiffs) + len(case_to_save.defendants)} | "
                f"—Å–æ–±—ã—Ç–∏–π: {len(case_to_save.events)}"
            )
            
            return {
                'success': True,
                'saved': True,
                'case_number': case_to_save.case_number,
                'results_html': results_html
            }
        
        return {
            'success': False,
            'saved': False,
            'case_number': target_case_number,
            'error': CaseStatus.SAVE_FAILED
        }
    
    async def _search_case(
        self,
        region_config: Dict,
        court_config: Dict,
        year: str,
        sequence_number: int
    ) -> tuple:
        """
        –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –¥–µ–ª–∞
        
        Returns:
            (results_html, [CaseData, ...])
        """
        viewstate, form_ids = await self.form_handler.prepare_search_form(
            self.session
        )
        
        await self.form_handler.select_region(
            self.session,
            viewstate,
            region_config['id'],
            form_ids
        )
        
        await asyncio.sleep(0.5)
        
        results_html = await self.search_engine.search_case(
            self.session,
            viewstate,
            region_config['id'],
            court_config['id'],
            year,
            sequence_number,
            form_ids
        )
        
        cases = self.results_parser.parse(results_html)
        
        return results_html, cases
    
    async def search_case_by_number(self, case_number: str) -> tuple:
        """
        –ü–æ–∏—Å–∫ –¥–µ–ª–∞ –ø–æ –Ω–æ–º–µ—Ä—É
        
        Args:
            case_number: –ø–æ–ª–Ω—ã–π –Ω–æ–º–µ—Ä –¥–µ–ª–∞
        
        Returns:
            (results_html, [CaseData, ...])
        """
        case_info = self.text_processor.find_region_and_court_by_case_number(
            case_number, self.settings.regions
        )
        
        if not case_info:
            self.logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–≥–∏–æ–Ω: {case_number}")
            return None, []
        
        region_config = self.settings.get_region(case_info['region_key'])
        court_config = self.settings.get_court(
            case_info['region_key'], 
            case_info['court_key']
        )
        
        return await self._search_case(
            region_config,
            court_config,
            case_info['year'],
            int(case_info['sequence'])
        )
    
    async def cleanup(self):
        """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –≤–æ—Ä–∫–µ—Ä–∞"""
        if self.session and not self.session.closed:
            await self.session.close()
            self.logger.debug(f"–°–µ—Å—Å–∏—è {self.region_key} –∑–∞–∫—Ä—ã—Ç–∞")
        
        self.authenticated = False
    
    async def __aenter__(self):
        await self.initialize()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.cleanup()
        return False


################################################################################
# –§–ê–ô–õ: parsers/court_parser/core/session.py
################################################################################


"""
–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ HTTP —Å–µ—Å—Å–∏—è–º–∏ —Å retry
"""
from typing import Dict, Any, Optional
import ssl
import asyncio
import aiohttp

from utils.logger import get_logger
from utils.retry import RetryStrategy, RetryConfig, CircuitBreaker, NonRetriableError


class SessionManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä HTTP —Å–µ—Å—Å–∏–π —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º retry"""
    
    def __init__(self, timeout: int = 30, retry_config: Optional[Dict] = None):
        self.timeout = aiohttp.ClientTimeout(total=timeout)
        self.session: Optional[aiohttp.ClientSession] = None
        self.logger = get_logger('session_manager')
        
        # Retry –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        self.retry_config = retry_config or {}
        self.circuit_breaker = None
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Circuit Breaker
        if 'circuit_breaker' in self.retry_config:
            self.circuit_breaker = CircuitBreaker(self.retry_config['circuit_breaker'])
    
    async def create_session(self) -> aiohttp.ClientSession:
        """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π —Å–µ—Å—Å–∏–∏"""
        if self.session and not self.session.closed:
            await self.session.close()
        
        # SSL –∫–æ–Ω—Ç–µ–∫—Å—Ç –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        
        connector = aiohttp.TCPConnector(ssl=ssl_context, limit=10)
        
        self.session = aiohttp.ClientSession(
            timeout=self.timeout,
            connector=connector
        )
        
        self.logger.debug("–°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è HTTP —Å–µ—Å—Å–∏—è")
        return self.session
    
    async def get_session(self) -> aiohttp.ClientSession:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é —Å–µ—Å—Å–∏—é"""
        if not self.session or self.session.closed:
            return await self.create_session()
        return self.session
    
    async def request(self, method: str, url: str, **kwargs) -> Dict[str, Any]:
        """
        HTTP –∑–∞–ø—Ä–æ—Å —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º retry
        
        Args:
            method: HTTP –º–µ—Ç–æ–¥ (GET, POST, etc)
            url: URL
            **kwargs: –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è aiohttp
        
        Returns:
            {'status': int, 'text': str, 'headers': dict}
        
        Raises:
            NonRetriableError: –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ –Ω–µ –ø–æ–¥–ª–µ–∂–∏—Ç retry (400, 401, 404, etc)
        """
        session = await self.get_session()
        
        # –ü–æ–ª—É—á–∞–µ–º retry config
        http_retry_config = self.retry_config.get('http_request', {})
        
        async def _do_request() -> Dict[str, Any]:
            async with session.request(method, url, **kwargs) as response:
                # –ß–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ –î–û –≤—ã—Ö–æ–¥–∞ –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞
                text = await response.text()
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ non-retriable —Å—Ç–∞—Ç—É—Å—ã
                if response.status in [400, 401, 403, 404]:
                    raise NonRetriableError(f"HTTP {response.status}")
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ retriable —Å—Ç–∞—Ç—É—Å—ã
                if http_retry_config and response.status in http_retry_config.get('retriable_status_codes', [500, 502, 503, 504]):
                    raise aiohttp.ClientError(f"HTTP {response.status}")
                
                return {
                    'status': response.status,
                    'text': text,
                    'headers': dict(response.headers)
                }
        
        if not http_retry_config:
            return await _do_request()
        
        # Retry —Å—Ç—Ä–∞—Ç–µ–≥–∏—è
        retry_cfg = RetryConfig(http_retry_config)
        strategy = RetryStrategy(retry_cfg, self.circuit_breaker)
        
        error_context = f"{method} {url}"
        return await strategy.execute_with_retry(_do_request, error_context=error_context)

    async def get(self, url: str, **kwargs) -> Dict[str, Any]:
        """GET –∑–∞–ø—Ä–æ—Å —Å retry"""
        return await self.request('GET', url, **kwargs)

    async def post(self, url: str, **kwargs) -> Dict[str, Any]:
        """POST –∑–∞–ø—Ä–æ—Å —Å retry"""
        return await self.request('POST', url, **kwargs)
    
    async def close(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ —Å–µ—Å—Å–∏–∏"""
        if self.session and not self.session.closed:
            await self.session.close()
            self.logger.debug("–°–µ—Å—Å–∏—è –∑–∞–∫—Ä—ã—Ç–∞")
    
    async def __aenter__(self):
        await self.create_session()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()


################################################################################
# –§–ê–ô–õ: parsers/court_parser/__init__.py
################################################################################


"""
Court Parser - –ü–∞—Ä—Å–µ—Ä —Å—É–¥–µ–±–Ω—ã—Ö –¥–µ–ª –ö–∞–∑–∞—Ö—Å—Ç–∞–Ω–∞
"""
__version__ = "2.0.0"
__author__ = "Your Name"

from core.parser import CourtParser

__all__ = ['CourtParser']


################################################################################
# –§–ê–ô–õ: parsers/court_parser/main.py
################################################################################


"""
–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –ø–∞—Ä—Å–µ—Ä–∞
"""
import sys
import asyncio
import traceback
from typing import List, Optional, Dict

from core.parser import CourtParser
from core.region_worker import RegionWorker
from config.settings import Settings
from database.db_manager import DatabaseManager
from search.document_handler import DocumentHandler
from utils.logger import setup_logger, get_logger, init_logging
from utils.progress import ProgressDisplay
from datetime import datetime
from utils.stats_reporter import StatsReporter


async def parse_all_regions_from_config() -> dict:
    """–ü–∞—Ä—Å–∏–Ω–≥ –≤—Å–µ—Ö —Ä–µ–≥–∏–æ–Ω–æ–≤ —Å –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –≤–æ—Ä–∫–µ—Ä–∞–º–∏"""
    logger = get_logger('main')
    
    settings = Settings()
    ps = settings.parsing_settings
    
    year = ps.get('year', '2025')
    court_types = ps.get('court_types', ['smas'])
    start_from = ps.get('start_from', 1)
    max_number = ps.get('max_number', 9999)
    max_consecutive_empty = ps.get('max_consecutive_empty', 200)
    delay_between_requests = ps.get('delay_between_requests', 2)
    max_parallel_regions = ps.get('max_parallel_regions', 1)
    
    region_retry_max_attempts = ps.get('region_retry_max_attempts', 3)
    region_retry_delay = ps.get('region_retry_delay_seconds', 5)
    
    limit_regions = settings.get_limit_regions()
    limit_cases_per_region = settings.get_limit_cases_per_region()
    
    all_regions = settings.get_target_regions()
    
    if limit_regions:
        regions_to_process = all_regions[:limit_regions]
    else:
        regions_to_process = all_regions
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Å—Å–∏–∏
    session_stats = {
        'start_time': datetime.now(),
        'end_time': None,
        'year': year,
        'regions_total': len(regions_to_process),
        'regions_processed': 0,
        'regions_failed': 0,
        'total_queries': 0,
        'total_cases_saved': 0,
        'gaps_filled': 0,
        'regions': {}
    }
    
    stats_lock = asyncio.Lock()
    semaphore = asyncio.Semaphore(max_parallel_regions)
    
    regions_display = {
        key: settings.get_region (key)['name'] 
        for key in regions_to_process
    }
    progress = ProgressDisplay(regions_display, court_types)
    
    db_manager = DatabaseManager(settings.database)
    await db_manager.connect()
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–ø–æ—Ä—Ç–µ—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    stats_reporter = StatsReporter(db_manager, settings)
    
    try:
        # === –ù–ê–ß–ê–õ–¨–ù–´–ô –û–¢–ß–Å–¢ ===
        plan = {
            'mode': 'parse',
            'year': year,
            'court_types': court_types,
            'target_regions': regions_to_process,
            'max_consecutive_empty': max_consecutive_empty,
        }
        await stats_reporter.print_start_report(plan)
        
        print()  # –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –ø–µ—Ä–µ–¥ –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
        await progress.start()
        
        async def process_region_with_retry(region_key: str):
            async with semaphore:
                region_config = settings.get_region(region_key)
                region_session = {}
                
                for attempt in range(1, region_retry_max_attempts + 1):
                    worker = None
                    try:
                        worker = RegionWorker(settings, region_key)
                        
                        if not await worker.initialize():
                            raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤–æ—Ä–∫–µ—Ä")
                        
                        logger.info(f"–†–µ–≥–∏–æ–Ω {region_config['name']}: —Å—Ç–∞—Ä—Ç (–ø–æ–ø—ã—Ç–∫–∞ {attempt})")
                        
                        region_stats = await process_region_all_courts_with_worker(
                            worker=worker,
                            db_manager=db_manager,
                            settings=settings,
                            region_key=region_key,
                            court_types=court_types,
                            year=year,
                            start_from=start_from,
                            max_number=max_number,
                            max_consecutive_empty=max_consecutive_empty,
                            delay_between_requests=delay_between_requests,
                            limit_cases=limit_cases_per_region,
                            progress=progress,
                            logger=logger,
                            region_session=region_session
                        )
                        
                        await progress.set_region_done(region_key)
                        
                        async with stats_lock:
                            session_stats['regions_processed'] += 1
                            session_stats['total_queries'] += region_stats['total_queries']
                            session_stats['total_cases_saved'] += region_stats['total_cases_saved']
                            session_stats['regions'][region_key] = region_session
                        
                        logger.info(
                            f"–†–µ–≥–∏–æ–Ω {region_config['name']}: –∑–∞–≤–µ—Ä—à—ë–Ω | "
                            f"–∑–∞–ø—Ä–æ—Å–æ–≤: {region_stats['total_queries']} | "
                            f"—Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {region_stats['total_cases_saved']}"
                        )
                        
                        return region_stats
                        
                    except Exception as e:
                        logger.error(f"–†–µ–≥–∏–æ–Ω {region_config['name']}: –æ—à–∏–±–∫–∞ - {e}")
                        
                        # –ü–æ–º–µ—á–∞–µ–º –æ—à–∏–±–∫—É –≤ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ
                        for court_key in court_types:
                            if court_key not in region_session:
                                region_session[court_key] = {
                                    'queries': 0,
                                    'saved': 0,
                                    'time': '',
                                    'stop_reason': 'error',
                                    'consecutive_empty': 0
                                }
                            else:
                                region_session[court_key]['stop_reason'] = 'error'
                        
                        if attempt < region_retry_max_attempts:
                            await asyncio.sleep(region_retry_delay)
                        else:
                            await progress.set_region_error(region_key)
                            async with stats_lock:
                                session_stats['regions_failed'] += 1
                                session_stats['regions'][region_key] = region_session
                            return None
                            
                    finally:
                        if worker:
                            await worker.cleanup()
        
        tasks = [process_region_with_retry(r) for r in regions_to_process]
        await asyncio.gather(*tasks, return_exceptions=True)
        
        await progress.finish()
        
        session_stats['end_time'] = datetime.now()
        
        # === –§–ò–ù–ê–õ–¨–ù–´–ô –û–¢–ß–Å–¢ ===
        print()  # –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –ø–æ—Å–ª–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        await stats_reporter.print_end_report(session_stats)
        
    except KeyboardInterrupt:
        session_stats['end_time'] = datetime.now()
        logger.warning("–ü—Ä–µ—Ä–≤–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
        
        # –ü–æ–º–µ—á–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ä–µ–≥–∏–æ–Ω—ã –∫–∞–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –≤—Ä—É—á–Ω—É—é
        for region_key in regions_to_process:
            if region_key in session_stats['regions']:
                for court_key in session_stats['regions'][region_key]:
                    if not session_stats['regions'][region_key][court_key].get('stop_reason'):
                        session_stats['regions'][region_key][court_key]['stop_reason'] = 'manual'
        
        await stats_reporter.print_end_report(session_stats)
        
    finally:
        await db_manager.disconnect()
    
    return session_stats


async def process_region_all_courts_with_worker(
    worker: RegionWorker,
    db_manager,
    settings: Settings,
    region_key: str,
    court_types: List[str],
    year: str,
    start_from: int,
    max_number: int,
    max_consecutive_empty: int,
    delay_between_requests: float,
    limit_cases: Optional[int],
    progress: ProgressDisplay,
    logger,
    region_session: Dict  # –ù–æ–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è —Å–±–æ—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
) -> dict:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö —Å—É–¥–æ–≤ —Ä–µ–≥–∏–æ–Ω–∞ —á–µ—Ä–µ–∑ –≤–æ—Ä–∫–µ—Ä"""
    region_config = settings.get_region(region_key)
    
    region_stats = {
        'region_key': region_key,
        'courts_processed': 0,
        'total_queries': 0,
        'total_cases_saved': 0,
        'courts_stats': {}
    }
    
    for court_key in court_types:
        court_config = region_config['courts'].get(court_key)
        if not court_config:
            logger.warning(f"–°—É–¥ {court_key} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ä–µ–≥–∏–æ–Ω–µ {region_key}")
            continue
        
        logger.info(f"–†–µ–≥–∏–æ–Ω {region_key}, —Å—É–¥ {court_key}: —Å—Ç–∞—Ä—Ç")
        
        await progress.update(
            region_key, 
            court=court_key, 
            saved=0, 
            queries=0, 
            consecutive_empty=0
        )
        
        court_start_time = datetime.now()
        
        try:
            court_stats = await parse_court_with_worker(
                worker=worker,
                db_manager=db_manager,
                settings=settings,
                region_key=region_key,
                court_key=court_key,
                year=year,
                start_from=start_from,
                max_number=max_number,
                max_consecutive_empty=max_consecutive_empty,
                delay_between_requests=delay_between_requests,
                limit_cases=limit_cases,
                progress=progress,
                logger=logger
            )
            
            await progress.set_court_done(region_key, court_key)
            
            court_end_time = datetime.now()
            court_duration = court_end_time - court_start_time
            minutes, seconds = divmod(int(court_duration.total_seconds()), 60)
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∏—á–∏–Ω—É –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
            if court_stats['consecutive_empty'] >= max_consecutive_empty:
                stop_reason = 'empty_limit'
            elif limit_cases and court_stats['queries_made'] >= limit_cases:
                stop_reason = 'query_limit'
            else:
                stop_reason = 'completed'
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å—É–¥–∞ –¥–ª—è –æ—Ç—á—ë—Ç–∞
            region_session[court_key] = {
                'queries': court_stats['queries_made'],
                'saved': court_stats['cases_saved'],
                'time': f"{minutes}:{seconds:02d}",
                'stop_reason': stop_reason,
                'consecutive_empty': court_stats['consecutive_empty']
            }
            
            region_stats['courts_processed'] += 1
            region_stats['total_queries'] += court_stats['queries_made']
            region_stats['total_cases_saved'] += court_stats['cases_saved']
            region_stats['courts_stats'][court_key] = court_stats
            
            logger.info(
                f"–†–µ–≥–∏–æ–Ω {region_key}, —Å—É–¥ {court_key}: –∑–∞–≤–µ—Ä—à—ë–Ω | "
                f"–∑–∞–ø—Ä–æ—Å–æ–≤: {court_stats['queries_made']} | "
                f"—Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {court_stats['cases_saved']}"
            )
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å—É–¥–∞ {court_key} –≤ —Ä–µ–≥–∏–æ–Ω–µ {region_key}: {e}")
            
            court_end_time = datetime.now()
            court_duration = court_end_time - court_start_time
            minutes, seconds = divmod(int(court_duration.total_seconds()), 60)
            
            region_session[court_key] = {
                'queries': 0,
                'saved': 0,
                'time': f"{minutes}:{seconds:02d}",
                'stop_reason': 'error',
                'consecutive_empty': 0
            }
            continue
    
    return region_stats


async def parse_court_with_worker(
    worker: RegionWorker,
    db_manager,
    settings: Settings,
    region_key: str,
    court_key: str,
    year: str,
    start_from: int,
    max_number: int,
    max_consecutive_empty: int,
    delay_between_requests: float,
    limit_cases: Optional[int],
    progress: ProgressDisplay,
    logger
) -> dict:
    """–ü–∞—Ä—Å–∏–Ω–≥ –æ–¥–Ω–æ–≥–æ —Å—É–¥–∞ —á–µ—Ä–µ–∑ –≤–æ—Ä–∫–µ—Ä"""
    
    stats = {
        'missing_found': 0,
        'missing_filled': 0,
        'missing_not_found': 0,
        'new_queries': 0,
        'new_saved': 0,
        'consecutive_empty': 0
    }
    
    existing = await db_manager.get_existing_case_numbers(
        region_key, court_key, year, settings
    )
    
    last_in_db = await db_manager.get_last_sequence_number(
        region_key, court_key, year, settings
    )
    
    logger.info(f"{region_key}/{court_key}: —Å—É—â–µ—Å—Ç–≤—É–µ—Ç {len(existing)}, –ø–æ—Å–ª–µ–¥–Ω–∏–π #{last_in_db}")
    
    total_saved = 0
    total_queries = 0
    
    if last_in_db > 0:
        full_range = set(range(start_from, last_in_db + 1))
        missing = sorted(full_range - existing)
        stats['missing_found'] = len(missing)
        
        if missing:
            logger.info(f"{region_key}/{court_key}: –ø—Ä–æ–ø—É—Å–∫–æ–≤ {len(missing)}")
            
            for seq_num in missing:
                if limit_cases and total_queries >= limit_cases:
                    break
                
                result = await worker.search_and_save(
                    db_manager=db_manager,
                    court_key=court_key,
                    sequence_number=seq_num,
                    year=year
                )
                
                total_queries += 1
                
                if result['success'] and result.get('saved'):
                    stats['missing_filled'] += 1
                    total_saved += 1
                else:
                    stats['missing_not_found'] += 1
                
                await progress.update(
                    region_key,
                    court=court_key,
                    saved=total_saved,
                    queries=total_queries,
                    consecutive_empty=stats['consecutive_empty']
                )
                
                await asyncio.sleep(delay_between_requests)
    
    actual_start = last_in_db + 1 if last_in_db > 0 else start_from
    
    if actual_start <= max_number:
        logger.info(f"{region_key}/{court_key}: –Ω–æ–≤—ã–µ –¥–µ–ª–∞ —Å #{actual_start}")
        
        current_number = actual_start
        
        while current_number <= max_number:
            if limit_cases and total_queries >= limit_cases:
                logger.info(f"{region_key}/{court_key}: –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ {limit_cases}")
                break
            
            if stats['consecutive_empty'] >= max_consecutive_empty:
                logger.info(f"{region_key}/{court_key}: –ª–∏–º–∏—Ç –ø—É—Å—Ç—ã—Ö {max_consecutive_empty}")
                break
            
            result = await worker.search_and_save(
                db_manager=db_manager,
                court_key=court_key,
                sequence_number=current_number,
                year=year
            )
            
            stats['new_queries'] += 1
            total_queries += 1
            
            if result['success'] and result.get('saved'):
                stats['new_saved'] += 1
                total_saved += 1
                stats['consecutive_empty'] = 0
            elif result.get('error') == 'no_results':
                stats['consecutive_empty'] += 1
            elif result.get('error') == 'target_not_found' and court_key != 'smas':
                stats['consecutive_empty'] += 1
            
            await progress.update(
                region_key,
                court=court_key,
                saved=total_saved,
                queries=total_queries,
                consecutive_empty=stats['consecutive_empty']
            )
            
            current_number += 1
            await asyncio.sleep(delay_between_requests)
    
    return {
        'queries_made': total_queries,
        'cases_saved': total_saved,
        'consecutive_empty': stats['consecutive_empty'],
        'missing_filled': stats['missing_filled'],
        'new_saved': stats['new_saved']
    }


async def update_cases_history():
    """–†–µ–∂–∏–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: —Å–æ–±—ã—Ç–∏—è + –¥–æ–∫—É–º–µ–Ω—Ç—ã"""
    logger = get_logger('main')
    
    settings = Settings()
    update_config = settings.config.get('update_settings', {})
    docs_config = settings.config.get('documents_settings', {})
    
    if not update_config.get('enabled', True):
        logger.warning("Update Mode –æ—Ç–∫–ª—é—á–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö")
        return
    
    interval_days = update_config.get('update_interval_days', 2)
    filters = update_config.get('filters', {})
    
    storage_dir = docs_config.get('storage_dir', './documents')
    download_delay = docs_config.get('download_delay', 2.0)
    
    logger.info("=" * 70)
    logger.info("–†–ï–ñ–ò–ú –û–ë–ù–û–í–õ–ï–ù–ò–Ø: –°–û–ë–´–¢–ò–Ø + –î–û–ö–£–ú–ï–ù–¢–´")
    logger.info("=" * 70)
    logger.info(f"–ò–Ω—Ç–µ—Ä–≤–∞–ª: {interval_days} –¥–Ω–µ–π")
    if filters.get('defendant_keywords'):
        logger.info(f"–§–∏–ª—å—Ç—Ä –ø–æ –æ—Ç–≤–µ—Ç—á–∏–∫—É: {filters['defendant_keywords']}")
    if filters.get('exclude_event_types'):
        logger.info(f"–ò—Å–∫–ª—é—á–∏—Ç—å —Å–æ–±—ã—Ç–∏—è: {filters['exclude_event_types']}")
    
    stats = {
        'cases_updated': 0,
        'events_added': 0,
        'documents_downloaded': 0,
        'errors': 0,
        'skipped': 0
    }
    
    async with CourtParser() as parser:
        doc_handler = DocumentHandler(
            base_url=settings.base_url,
            storage_dir=storage_dir,
            regions_config=settings.regions
        )
        
        logger.info("–≠—Ç–∞–ø 1: –î–µ–ª–∞ –°–ú–ê–° –±–µ–∑ —Å—É–¥—å–∏")
        
        smas_cases = await parser.db_manager.get_smas_cases_without_judge(settings, interval_days)
        logger.info(f"–ù–∞–π–¥–µ–Ω–æ –¥–µ–ª –°–ú–ê–° –±–µ–∑ —Å—É–¥—å–∏: {len(smas_cases)}")
        
        for case_number in smas_cases:
            result = await _process_single_case(
                parser, doc_handler, case_number, download_delay, logger
            )
            _update_stats(stats, result)
        
        logger.info("–≠—Ç–∞–ø 2: –î–µ–ª–∞ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º")
        
        keyword_cases = await parser.db_manager.get_cases_for_update({
            'defendant_keywords': filters.get('defendant_keywords', []),
            'exclude_event_types': filters.get('exclude_event_types', []),
            'update_interval_days': interval_days
        })
        logger.info(f"–ù–∞–π–¥–µ–Ω–æ –¥–µ–ª –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º: {len(keyword_cases)}")
        
        for case_number in keyword_cases:
            result = await _process_single_case(
                parser, doc_handler, case_number, download_delay, logger
            )
            _update_stats(stats, result)
    
    logger.info("=" * 70)
    logger.info("–ò–¢–û–ì–ò –û–ë–ù–û–í–õ–ï–ù–ò–Ø:")
    logger.info(f"  –û–±–Ω–æ–≤–ª–µ–Ω–æ –¥–µ–ª: {stats['cases_updated']}")
    logger.info(f"  –î–æ–±–∞–≤–ª–µ–Ω–æ —Å–æ–±—ã—Ç–∏–π: {stats['events_added']}")
    logger.info(f"  –°–∫–∞—á–∞–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤: {stats['documents_downloaded']}")
    logger.info(f"  –ü—Ä–æ–ø—É—â–µ–Ω–æ: {stats['skipped']}")
    logger.info(f"  –û—à–∏–±–æ–∫: {stats['errors']}")
    logger.info("=" * 70)


async def _process_single_case(parser, doc_handler, case_number: str, delay: float, logger) -> dict:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–≥–æ –¥–µ–ª–∞: –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π + –¥–æ–∫—É–º–µ–Ω—Ç—ã"""
    result = {'updated': False, 'events_added': 0, 'documents': 0, 'error': False, 'skipped': False}
    
    try:
        logger.info(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–µ–ª–∞: {case_number}")
        
        results_html, cases = await parser.search_case_by_number(case_number)
        
        if not results_html or not cases:
            logger.warning(f"–î–µ–ª–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∞ —Å–∞–π—Ç–µ: {case_number}")
            result['skipped'] = True
            return result
        
        target_case = next((c for c in cases if c.case_number == case_number), None)
        
        if not target_case or target_case.result_index is None:
            logger.warning(f"–ò–Ω–¥–µ–∫—Å –Ω–µ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω: {case_number}")
            result['skipped'] = True
            return result
        
        save_result = await parser.db_manager.update_case(target_case)
        
        if save_result.get('events_added', 0) > 0:
            result['events_added'] = save_result['events_added'] 
            result['updated'] = True
            logger.info(f"–î–æ–±–∞–≤–ª–µ–Ω–æ —Å–æ–±—ã—Ç–∏–π: {result['events_added']} –¥–ª—è {case_number}")
        
        case_id = save_result.get('case_id') or await parser.db_manager.get_case_id(case_number)
        
        if case_id:
            session = await parser.session_manager.get_session()
            existing_keys = await parser.db_manager.get_document_keys(case_id)
            
            downloaded = await doc_handler.fetch_all_documents(
                session=session,
                results_html=results_html,
                case_number=case_number,
                case_index=target_case.result_index,
                existing_keys=existing_keys,
                delay=delay
            )
            
            if downloaded:
                await parser.db_manager.save_documents(case_id, downloaded)
                result['documents'] = len(downloaded)
                result['updated'] = True
                logger.info(f"–°–∫–∞—á–∞–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤: {len(downloaded)} –¥–ª—è {case_number}")
            
            await parser.db_manager.mark_documents_downloaded(case_id)
        
        await asyncio.sleep(delay)
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–µ–ª–∞ {case_number}: {e}")
        result['error'] = True
    
    return result


def _update_stats(stats: dict, result: dict):
    """–û–±–Ω–æ–≤–∏—Ç—å –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
    if result.get('error'):
        stats['errors'] += 1
    elif result.get('skipped'):
        stats['skipped'] += 1
    elif result.get('updated'):
        stats['cases_updated'] += 1
        stats['events_added'] += result.get('events_added', 0)
        stats['documents_downloaded'] += result.get('documents', 0)
    else:
        stats['skipped'] += 1


def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –ª–æ–≥–≥–µ—Ä–æ–≤ –û–î–ò–ù —Ä–∞–∑ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
    init_logging(log_dir="logs", level="DEBUG")
    logger = get_logger('main')
    
    logger.info("=" * 70)
    logger.info("–ü–ê–†–°–ï–† –°–£–î–ï–ë–ù–´–• –î–ï–õ –ö–ê–ó–ê–•–°–¢–ê–ù–ê v2.1")
    logger.info("=" * 70)
    
    mode = 'parse'
    
    if '--mode' in sys.argv:
        idx = sys.argv.index('--mode')
        if idx + 1 < len(sys.argv):
            mode = sys.argv[idx + 1]
    
    try:
        if mode == 'parse':
            asyncio.run(parse_all_regions_from_config())
        
        elif mode == 'update':
            asyncio.run(update_cases_history())
        
        else:
            logger.error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º: {mode}")
            sys.exit(1)
            
    except KeyboardInterrupt:
        logger.warning("–ü—Ä–µ—Ä–≤–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
        sys.exit(0)
    except Exception as e:
        logger.critical(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        logger.debug(traceback.format_exc())
        sys.exit(1)


if __name__ == '__main__':
    main()

################################################################################
#                           –ö–û–ù–ï–¶ –°–ë–û–†–ö–ò
################################################################################
#
# –í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: 30
# –í—Å–µ–≥–æ —Å—Ç—Ä–æ–∫: 6,389
# –†–∞–∑–º–µ—Ä: 248,421 –±–∞–π—Ç (242.6 KB)
#
################################################################################

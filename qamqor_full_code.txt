================================================================================
QAMQOR PARSER - COMPLETE CODE
================================================================================
Project: court_project
Module: parsers/qamqor
Generated: 2025-10-20 20:19:57
================================================================================

STRUCTURE:
parsers/qamqor/
‚îú‚îÄ‚îÄ qamqor_parser.py
‚îú‚îÄ‚îÄ qamqor_updater.py
‚îî‚îÄ‚îÄ core/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ api_validator.py
    ‚îú‚îÄ‚îÄ config.py
    ‚îú‚îÄ‚îÄ database.py
    ‚îú‚îÄ‚îÄ data_processor.py
    ‚îú‚îÄ‚îÄ log_manager.py
    ‚îú‚îÄ‚îÄ tab_manager.py
    ‚îî‚îÄ‚îÄ web_client.py
================================================================================


================================================================================
FILE: core\__init__.py
================================================================================

"""
QAMQOR Parser - –û–±—â–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã.
"""

from .api_validator import APIValidator
from .config import Config
from .data_processor import DataProcessor
from .database import DatabaseManager
from .enums import (
    APIResponseCode,
    APIResponseStatus,
    CheckStatus,
    ParserMode,
    TableName,
)
from .log_manager import LogManager
from .stealth import StealthTabManager, apply_stealth
from .tab_manager import TabManager
from .web_client import WebClient

__all__ = [
    'APIValidator',
    'APIResponseCode',
    'APIResponseStatus',
    'CheckStatus',
    'Config',
    'DataProcessor',
    'DatabaseManager',
    'LogManager',
    'ParserMode',
    'StealthTabManager',
    'TableName',
    'TabManager',
    'WebClient',
    'apply_stealth',
]

================================================================================
FILE: core\api_validator.py
================================================================================

"""–í–∞–ª–∏–¥–∞—Ç–æ—Ä –æ—Ç–≤–µ—Ç–æ–≤ –æ—Ç API."""

import logging
from typing import Dict, Optional, Tuple

from .enums import APIResponseCode, APIResponseStatus


class APIValidator:
    """
    –í–∞–ª–∏–¥–∞—Ç–æ—Ä –æ—Ç–≤–µ—Ç–æ–≤ –æ—Ç API QAMQOR.
    
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –æ—Ç–≤–µ—Ç–∞, –∫–æ–¥—ã —Å–æ—Å—Ç–æ—è–Ω–∏—è
    –∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å –æ—à–∏–±–æ–∫.
    """
    
    def __init__(self, logger: logging.Logger):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞.
        
        Args:
            logger: –õ–æ–≥–≥–µ—Ä –¥–ª—è –≤—ã–≤–æ–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
        """
        self.logger = logger
    
    def validate_response(
        self,
        response_data: Optional[Dict],
        context: str = ""
    ) -> Tuple[bool, Optional[str]]:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –æ—Ç–≤–µ—Ç–∞ API.
        
        Args:
            response_data: –î–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç–∞ –æ—Ç API
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–æ–º–µ—Ä –∑–∞–ø–∏—Å–∏)
            
        Returns:
            –ö–æ—Ä—Ç–µ–∂ (is_valid, error_message):
                - is_valid: True –µ—Å–ª–∏ –æ—Ç–≤–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω
                - error_message: –û–ø–∏—Å–∞–Ω–∏–µ –æ—à–∏–±–∫–∏ –∏–ª–∏ None
        """
        if not response_data:
            return False, "–ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç"
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ code
        code = response_data.get('code', '').upper()
        
        # –ò–ì–ù–û–†–ò–†–£–ï–ú CONTROLLER::RECAPTCHA (–ª–æ–∂–Ω–∞—è –∑–∞—â–∏—Ç–∞)
        if code == APIResponseCode.RECAPTCHA.value:
            self.logger.warning(
                "‚ö†Ô∏è %s | API –≤–µ—Ä–Ω—É–ª CAPTCHA, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º",
                context
            )
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –¥–∞–Ω–Ω—ã—Ö
            data_obj = response_data.get('data')
            
            if data_obj is not None and isinstance(data_obj, dict):
                items = data_obj.get('items', [])
                if items and len(items) > 0:
                    # –î–∞–Ω–Ω—ã–µ –µ—Å—Ç—å - —Å—á–∏—Ç–∞–µ–º —É—Å–ø–µ—à–Ω—ã–º
                    self.logger.info(
                        "‚úÖ %s | –î–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ CAPTCHA",
                        context
                    )
                    return True, None
            
            # –î–∞–Ω–Ω—ã—Ö –Ω–µ—Ç - —ç—Ç–æ –ø—É—Å—Ç–∞—è –∑–∞–ø–∏—Å—å (–Ω–µ –æ—à–∏–±–∫–∞)
            self.logger.debug(
                "‚ÑπÔ∏è %s | CAPTCHA –±–µ–∑ –¥–∞–Ω–Ω—ã—Ö - –ø—É—Å—Ç–∞—è –∑–∞–ø–∏—Å—å",
                context
            )
            return True, None
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π code
        if code != APIResponseCode.OK.value:
            error_msg = f"–ù–µ–≤–µ—Ä–Ω—ã–π code: {code}"
            if context:
                error_msg = f"{context} | {error_msg}"
            return False, error_msg
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ status
        status = response_data.get('status', '').lower()
        if status != APIResponseStatus.SUCCESS.value:
            error_msg = f"–ù–µ–≤–µ—Ä–Ω—ã–π status: {status}"
            if context:
                error_msg = f"{context} | {error_msg}"
            return False, error_msg
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã data
        if 'data' not in response_data:
            return False, f"{context} | –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–ª–µ 'data'"
        
        return True, None
    
    def is_critical_error(self, response_data: Optional[Dict]) -> bool:
        """
        –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—à–∏–±–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π.
        
        –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏ —Ç—Ä–µ–±—É—é—Ç –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–∞—Ä—Å–µ—Ä–∞:
        - MAINTENANCE (—Ç–µ—Ö–æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ)
        - SERVER_ERROR (—Å–µ—Ä–≤–µ—Ä–Ω–∞—è –æ—à–∏–±–∫–∞)
        - INTERNAL_ERROR (–≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞)
        - SERVICE_UNAVAILABLE (—Å–µ—Ä–≤–∏—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)
        
        CONTROLLER::RECAPTCHA –ù–ï —è–≤–ª—è–µ—Ç—Å—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–æ–π.
        
        Args:
            response_data: –î–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç–∞ –æ—Ç API
            
        Returns:
            True –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è
        """
        if not response_data:
            return False
        
        code = response_data.get('code', '').upper()
        
        # CAPTCHA - –ù–ï –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞
        if code == APIResponseCode.RECAPTCHA.value:
            return False
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–≤–æ–π—Å—Ç–≤–æ enum
        try:
            api_code = APIResponseCode(code)
            return api_code.is_critical
        except ValueError:
            # –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–æ–¥ - –Ω–µ —Å—á–∏—Ç–∞–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–º
            return False

================================================================================
FILE: core\config.py
================================================================================

"""–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–∞—Ä—Å–µ—Ä–∞."""

import os
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Set


@dataclass
class Config:
    """
    –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–∞—Ä—Å–µ—Ä–∞ QAMQOR.
    
    –°–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã –ø–∞—Ä—Å–µ—Ä–∞: API endpoints,
    –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏, —Ç–∞–π–º–∞—É—Ç—ã, –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ë–î,
    –º–∞–ø–ø–∏–Ω–≥ –ø–æ–ª–µ–π –∏ —Å–ø–∏—Å–æ–∫ —Ä–µ–≥–∏–æ–Ω–æ–≤.
    """
    
    # API –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    BASE_URL: str = "https://qamqor.gov.kz"
    SEARCH_URL: str = "https://qamqor.gov.kz/check"
    API_ENDPOINT: str = "/api/public/check_status"
    
    # –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
    MAX_CONCURRENT_TABS: int = 3
    MAX_EMPTY_SEQUENCE: int = 5
    BATCH_SIZE: int = 50
    
    # –¢–∞–π–º–∞—É—Ç—ã (–º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã –¥–ª—è PAGE_TIMEOUT, —Å–µ–∫—É–Ω–¥—ã –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö)
    PAGE_TIMEOUT: int = 90_000
    RESPONSE_TIMEOUT: int = 25
    
    # Retry –ª–æ–≥–∏–∫–∞
    MAX_RETRIES: int = 3
    RETRY_DELAY: float = 3.0
    REGION_RETRY_LIMIT: int = 3
    
    # –ó–∞–¥–µ—Ä–∂–∫–∏ (—Å–µ–∫—É–Ω–¥—ã) –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ —á–µ–ª–æ–≤–µ–∫–∞
    NATURAL_DELAY_MIN: float = 0.3
    NATURAL_DELAY_MAX: float = 0.8
    TYPING_DELAY_MIN: float = 0.2
    TYPING_DELAY_MAX: float = 0.5
    
    # –ü–∞—Ä—Å–∏–Ω–≥
    START_NUMBER: int = 1
    MAX_NUMBER: int = 99_999
    NUMBER_PADDING: int = 5
    
    # –ü–æ—Ä–æ–≥–∏ –¥–ª—è –±–∞—Ç—á–µ–π
    BULK_COPY_THRESHOLD: int = 1_000
    EXECUTE_VALUES_PAGE_SIZE: int = 500
    
    # Exponential backoff
    RETRY_BACKOFF_BASE: int = 2
    
    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    LOG_DIR: Path = field(default_factory=lambda: Path("logs"))
    LOG_LEVEL: str = "INFO"
    SCREENSHOT_DIR: Path = field(default_factory=lambda: Path("screenshots"))
    
    # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
    DB_HOST: str = field(
        default_factory=lambda: os.getenv("QAMQOR_DB_HOST", "localhost")
    )
    DB_PORT: str = field(
        default_factory=lambda: os.getenv("QAMQOR_DB_PORT", "5432")
    )
    DB_NAME: str = field(
        default_factory=lambda: os.getenv("QAMQOR_DB_NAME", "qamqor")
    )
    DB_USER: str = field(
        default_factory=lambda: os.getenv("QAMQOR_DB_USER", "postgres")
    )
    DB_PASSWORD: str = field(
        default_factory=lambda: os.getenv("QAMQOR_DB_PASSWORD", "admin")
    )
    
    # –†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã
    MODE: str = "full"  # full | missing_only | update
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–ø–¥–µ–π—Ç–µ—Ä–∞
    UPDATE_BATCH_SIZE: int = 100
    UPDATE_MIN_AGE_DAYS: int = 7              # ‚¨ÖÔ∏è –ò–∑–º–µ–Ω–µ–Ω–æ: –±—ã–ª–æ 60
    UPDATE_MAX_AGE_DAYS: int = 180            # ‚¨ÖÔ∏è –ù–û–í–û–ï: –¥–æ–±–∞–≤–ª–µ–Ω –ª–∏–º–∏—Ç
    UPDATE_COOLDOWN_DAYS: int = 3             # ‚¨ÖÔ∏è –ò–∑–º–µ–Ω–µ–Ω–æ: –±—ã–ª–æ 7
    UPDATE_STATUSES: List[str] = field(default_factory=lambda: ["1"])
    UPDATE_TRACK_CHANGES: bool = True
    
    # –†–µ–≥–∏–æ–Ω—ã
    REGIONS: Dict[int, str] = field(default_factory=lambda: {
        1000000: "Abay",
        1100000: "Akmolinsk",
        1500000: "Aktobe",
        1900000: "Almaty_region",
        2300000: "Atyrau",
        2700000: "ZKO",
        3100000: "Zhambyl",
        3300000: "Zhetisu",
        3500000: "Karaganda",
        3900000: "Kostanay",
        4300000: "Kyzylorda",
        4700000: "Mangistau",
        5500000: "Pavlodar",
        5900000: "SKO",
        6100000: "Turkestan",
        6200000: "Ulytau",
        6300000: "VKO",
        7100000: "Astana",
        7500000: "Almaty",
        7900000: "Shymkent"
    })
    
    # –ú–∞–ø–ø–∏–Ω–≥ –ø–æ–ª–µ–π API ‚Üí –ë–î
    FIELD_MAPPING: Dict[str, str] = field(default_factory=lambda: {
        "registrationNum": "registration_number",
        "regDate": "reg_date",
        "checkDate": "act_date",
        "beginDate": "start_date",
        "endDate": "end_date",
        "tlnSuspendDate": "suspend_date",
        "tlnResumeDate": "resume_date",
        "tlnProlongBegin": "prolong_start",
        "tlnProlongEnd": "prolong_end"
    })
    
    # –ü–æ–ª—è —Å –¥–∞—Ç–∞–º–∏ (—Ç—Ä–µ–±—É—é—Ç –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏)
    DATE_FIELDS: Set[str] = field(default_factory=lambda: {
        "reg_date", "act_date", "start_date", "end_date",
        "suspend_date", "resume_date", "prolong_start", "prolong_end"
    })
    
    # –ò—Å–∫–ª—é—á–µ–Ω–Ω—ã–µ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –Ω–æ–º–µ—Ä–∞ (–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ)
    EXCLUDED_MISSING_NUMBERS: Dict[int, List[int]] = field(
        default_factory=lambda: {
            5900000: [1],
        }
    )
    
    # –¢–µ—Å—Ç–æ–≤—ã–π –Ω–æ–º–µ—Ä –¥–ª—è health check
    TEST_NUMBER: str = "2559000001701011/00002"
    
    def __post_init__(self) -> None:
        """
        –ü–æ—Å—Ç–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è: —Å–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
        
        Raises:
            ValueError: –ü—Ä–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏—è—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        """
        # –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
        self.LOG_DIR.mkdir(parents=True, exist_ok=True)
        self.SCREENSHOT_DIR.mkdir(parents=True, exist_ok=True)
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        self._validate_parameters()
    
    def _validate_parameters(self) -> None:
        """
        –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
        
        Raises:
            ValueError: –ü—Ä–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏—è—Ö
        """
        if self.MAX_CONCURRENT_TABS < 1:
            raise ValueError("MAX_CONCURRENT_TABS –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å >= 1")
        
        if self.BATCH_SIZE < 1:
            raise ValueError("BATCH_SIZE –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å >= 1")
        
        if self.MAX_RETRIES < 1:
            raise ValueError("MAX_RETRIES –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å >= 1")
        
        if self.PAGE_TIMEOUT < 1000:
            raise ValueError("PAGE_TIMEOUT –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å >= 1000ms")
        
        if self.RESPONSE_TIMEOUT < 1:
            raise ValueError("RESPONSE_TIMEOUT –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å >= 1s")
        
        if self.NATURAL_DELAY_MIN < 0 or self.NATURAL_DELAY_MAX < 0:
            raise ValueError("–ó–∞–¥–µ—Ä–∂–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å >= 0")
        
        if self.NATURAL_DELAY_MIN > self.NATURAL_DELAY_MAX:
            raise ValueError("MIN delay –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª—å—à–µ MAX")

================================================================================
FILE: core\data_processor.py
================================================================================

"""–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–∞–Ω–Ω—ã—Ö –æ—Ç API."""

import logging
from datetime import datetime
from typing import Dict, Optional

from .config import Config


class DataProcessor:
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–≤–µ—Ç–æ–≤ –æ—Ç API."""
    
    def __init__(self, config: Config, logger: logging.Logger):
        self.config = config
        self.logger = logger
    
    def process_api_response(self, response_data: Dict) -> Optional[Dict]:
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ –æ—Ç API.
        
        Args:
            response_data: –î–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç–∞ –æ—Ç API
            
        Returns:
            –û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ
        """
        try:
            data_obj = response_data.get('data')
            if not data_obj:
                return None
            
            items = data_obj.get('items', [])
            if not items:
                return None
            
            item = items[0]
            
            result = {}
            
            # –ú–∞–ø–ø–∏–Ω–≥ –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø–æ–ª–µ–π
            for api_field, db_field in self.config.FIELD_MAPPING.items():
                value = item.get(api_field)
                if db_field in self.config.DATE_FIELDS and value:
                    value = self._normalize_date(value)
                result[db_field] = value
            
            # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
            self._extract_organization_info(item, result)
            self._extract_subject_info(item, result)
            self._extract_audit_info(item, result)
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ–ª—è
            if not result.get('registration_number'):
                self.logger.warning("‚ö†Ô∏è –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç registration_number")
                return None
            
            return result
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö: {e}", exc_info=True)
            return None
    
    def _extract_organization_info(self, item: Dict, result: Dict):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏."""
        org = item.get('org', {})
        result['revenue_name'] = org.get('nameRu')
        
        org_kpssu = item.get('orgKpssu', {})
        result['kpssu_name'] = org_kpssu.get('nameRu')
        
        check_type = item.get('checkType', {})
        result['check_type'] = check_type.get('nameRu')
        
        status = item.get('status', {})
        result['status_id'] = str(status.get('id')) if status.get('id') is not None else None
        result['status'] = status.get('nameRu')
    
    def _extract_subject_info(self, item: Dict, result: Dict):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å—É–±—ä–µ–∫—Ç–µ."""
        subjects = item.get('subjects', [])
        if subjects:
            subject = subjects[0]
            result['subject_bin'] = subject.get('bin')
            result['subject_name'] = subject.get('nameRu')
            result['subject_address'] = subject.get('address')
    
    def _extract_audit_info(self, item: Dict, result: Dict):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞—É–¥–∏—Ç–µ."""
        queries = item.get('queries', [])
        for i, query in enumerate(queries[:2]):
            suffix = "" if i == 0 else "_1"
            query_check = query.get('queryCheck', {})
            theme_check = query.get('themeCheck', {})
            result[f'audit_theme{suffix}'] = query_check.get('nameRu')
            result[f'theme_check{suffix}'] = theme_check.get('nameRu')
    
    def _normalize_date(self, date_str: str) -> Optional[str]:
        """
        –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞—Ç—ã –≤ —Ñ–æ—Ä–º–∞—Ç PostgreSQL (YYYY-MM-DD).
        
        Args:
            date_str: –°—Ç—Ä–æ–∫–∞ —Å –¥–∞—Ç–æ–π
            
        Returns:
            –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –¥–∞—Ç–∞ –∏–ª–∏ None
        """
        if not date_str:
            return None
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–∞—Ç–∞ —É–∂–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
        if len(date_str) == 10 and date_str[4] == '-' and date_str[7] == '-':
            try:
                datetime.strptime(date_str, "%Y-%m-%d")
                return date_str
            except ValueError:
                pass
        
        # –ü—Ä–æ–±—É–µ–º —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥—Ä—É–≥–∏–µ —Ñ–æ—Ä–º–∞—Ç—ã
        for fmt in ("%d/%m/%Y", "%Y-%m-%d", "%d.%m.%Y"):
            try:
                return datetime.strptime(date_str, fmt).strftime("%Y-%m-%d")
            except ValueError:
                continue
        
        self.logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥–∞—Ç—É: {date_str}")
        return None

================================================================================
FILE: core\database.py
================================================================================

"""–ú–µ–Ω–µ–¥–∂–µ—Ä —Ä–∞–±–æ—Ç—ã —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö."""

import asyncio
import logging
import psycopg2
import psycopg2.extras
from contextlib import asynccontextmanager
from datetime import datetime
from typing import Dict, List, Optional, Tuple

from .config import Config


class DatabaseManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä —Ä–∞–±–æ—Ç—ã —Å PostgreSQL."""
    
    def __init__(self, config: Config, logger: logging.Logger):
        self.config = config
        self.logger = logger
        self._connection_retry_count = 3
        self._connection_retry_delay = 5.0
        
    def _get_connection_params(self) -> dict:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î."""
        return {
            'host': self.config.DB_HOST,
            'port': self.config.DB_PORT,
            'database': self.config.DB_NAME,
            'user': self.config.DB_USER,
            'password': self.config.DB_PASSWORD,
            'connect_timeout': 10
        }
    
    @asynccontextmanager
    async def get_connection(self):
        """
        –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î —Å —Ä–µ—Ç—Ä–∞—è–º–∏ –ø—Ä–∏ —Å–µ—Ç–µ–≤—ã—Ö –æ—à–∏–±–∫–∞—Ö.
        
        Yields:
            psycopg2.connection
        """
        conn = None
        
        for attempt in range(1, self._connection_retry_count + 1):
            try:
                conn = psycopg2.connect(**self._get_connection_params())
                conn.autocommit = False
                
                yield conn
                
                # –ö–æ–º–º–∏—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –±—ã–ª–æ –∏—Å–∫–ª—é—á–µ–Ω–∏–π
                if conn and not conn.closed:
                    conn.commit()
                break
                
            except (psycopg2.OperationalError, psycopg2.InterfaceError) as e:
                # –°–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏ - retry
                if conn:
                    try:
                        conn.rollback()
                        conn.close()
                    except Exception:
                        pass
                    conn = None
                
                if attempt < self._connection_retry_count:
                    delay = self._connection_retry_delay * attempt
                    self.logger.warning(
                        f"‚ö†Ô∏è –ë–î –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ (–ø–æ–ø—ã—Ç–∫–∞ {attempt}/{self._connection_retry_count}). "
                        f"–ü–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ {delay}—Å..."
                    )
                    await asyncio.sleep(delay)
                else:
                    self.logger.error(
                        f"‚ùå –ë–î –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –ø–æ—Å–ª–µ {self._connection_retry_count} –ø–æ–ø—ã—Ç–æ–∫"
                    )
                    raise
                    
            except Exception as e:
                # –î—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏ - rollback –∏ raise
                if conn:
                    try:
                        conn.rollback()
                    except Exception:
                        pass
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ë–î: {e}", exc_info=True)
                raise
                
            finally:
                # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                if conn and not conn.closed:
                    try:
                        conn.close()
                    except Exception as e:
                        self.logger.debug(f"–û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: {e}")
    
    async def initialize_tables(self):
        """–°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π."""
        create_table_sql = """
        CREATE TABLE IF NOT EXISTS {table_name} (
            registration_number TEXT PRIMARY KEY,
            reg_date DATE,
            act_date DATE,
            start_date DATE,
            end_date DATE,
            suspend_date DATE,
            resume_date DATE,
            prolong_start DATE,
            prolong_end DATE,
            revenue_name TEXT,
            kpssu_name TEXT,
            check_type TEXT,
            subject_bin TEXT,
            subject_name TEXT,
            subject_address TEXT,
            status_id TEXT,
            status TEXT,
            audit_theme TEXT,
            audit_theme_1 TEXT,
            theme_check TEXT,
            theme_check_1 TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        
        CREATE INDEX IF NOT EXISTS idx_{table_name}_reg_date ON {table_name}(reg_date);
        CREATE INDEX IF NOT EXISTS idx_{table_name}_bin ON {table_name}(subject_bin);
        CREATE INDEX IF NOT EXISTS idx_{table_name}_status ON {table_name}(status_id);
        CREATE INDEX IF NOT EXISTS idx_{table_name}_updated ON {table_name}(updated_at);
        CREATE INDEX IF NOT EXISTS idx_{table_name}_region_seq ON {table_name}(
            CAST(SUBSTRING(registration_number, 3, 7) AS INTEGER),
            CAST(SPLIT_PART(registration_number, '/', 2) AS INTEGER)
        );
        
        CREATE OR REPLACE FUNCTION update_{table_name}_timestamp()
        RETURNS TRIGGER AS $$
        BEGIN
            NEW.updated_at = NOW();
            RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
        
        DROP TRIGGER IF EXISTS trigger_update_{table_name}_timestamp ON {table_name};
        CREATE TRIGGER trigger_update_{table_name}_timestamp
        BEFORE UPDATE ON {table_name}
        FOR EACH ROW
        EXECUTE FUNCTION update_{table_name}_timestamp();
        """
        
        create_audit_log_sql = """
        CREATE TABLE IF NOT EXISTS audit_log (
            id SERIAL PRIMARY KEY,
            registration_number TEXT NOT NULL,
            table_name TEXT NOT NULL,
            changed_fields TEXT[],
            old_values JSONB,
            new_values JSONB,
            changed_at TIMESTAMP DEFAULT NOW()
        );
        
        CREATE INDEX IF NOT EXISTS idx_audit_log_reg_num ON audit_log(registration_number);
        CREATE INDEX IF NOT EXISTS idx_audit_log_changed_at ON audit_log(changed_at);
        CREATE INDEX IF NOT EXISTS idx_audit_log_table ON audit_log(table_name);
        """
        
        add_updated_at_sql = """
        DO $$ 
        BEGIN
            IF NOT EXISTS (
                SELECT 1 FROM information_schema.columns 
                WHERE table_name=%s AND column_name='updated_at'
            ) THEN
                EXECUTE 'ALTER TABLE ' || %s || ' ADD COLUMN updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP';
            END IF;
        END $$;
        """
        
        async with self.get_connection() as conn:
            cursor = conn.cursor()
            
            # –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü
            cursor.execute(create_table_sql.format(table_name="qamqor_tax"))
            cursor.execute(create_table_sql.format(table_name="qamqor_customs"))
            cursor.execute(create_audit_log_sql)
            
            # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ updated_at –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º —Ç–∞–±–ª–∏—Ü–∞–º
            for table in ['qamqor_tax', 'qamqor_customs']:
                cursor.execute(add_updated_at_sql, (table, table))
            
            self.logger.debug("‚úÖ –¢–∞–±–ª–∏—Ü—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")
    
    async def get_region_state(self) -> Dict[int, int]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤ –∏–∑ –ë–î.
        
        Returns:
            –°–ª–æ–≤–∞—Ä—å {region_code: next_number}
        """
        region_state = {}
        
        async with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT region_code, COALESCE(MAX(seq_number), 0) + 1 as next_number
                FROM (
                    SELECT 
                        CAST(SUBSTRING(registration_number, 3, 7) AS INTEGER) as region_code,
                        CAST(SPLIT_PART(registration_number, '/', 2) AS INTEGER) as seq_number
                    FROM qamqor_tax 
                    WHERE registration_number ~ '^25[0-9]{7}170101[12]/[0-9]{5}$'
                    UNION ALL
                    SELECT 
                        CAST(SUBSTRING(registration_number, 3, 7) AS INTEGER) as region_code,
                        CAST(SPLIT_PART(registration_number, '/', 2) AS INTEGER) as seq_number
                    FROM qamqor_customs 
                    WHERE registration_number ~ '^25[0-9]{7}170101[12]/[0-9]{5}$'
                ) combined 
                GROUP BY region_code
            """)
            
            for region_code, next_number in cursor.fetchall():
                region_state[region_code] = next_number
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—Ç–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Ä–µ–≥–∏–æ–Ω–æ–≤ –±–µ–∑ –¥–∞–Ω–Ω—ã—Ö
        for region_code in self.config.REGIONS.keys():
            region_state.setdefault(region_code, self.config.START_NUMBER)
        
        return region_state
    
    async def get_region_stats(self) -> Dict[int, Dict]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ —Ä–µ–≥–∏–æ–Ω–∞–º.
        
        Returns:
            –°–ª–æ–≤–∞—Ä—å —Å–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π –ø–æ –∫–∞–∂–¥–æ–º—É —Ä–µ–≥–∏–æ–Ω—É
        """
        stats = {}
        
        async with self.get_connection() as conn:
            cursor = conn.cursor()
            
            for region_code in self.config.REGIONS.keys():
                pattern = f'^25{region_code}170101[12]/[0-9]{{5}}$'
                
                # –ü–æ–¥—Å—á–µ—Ç –∑–∞–ø–∏—Å–µ–π
                cursor.execute("""
                    SELECT COUNT(*) FROM (
                        SELECT registration_number FROM qamqor_tax WHERE registration_number ~ %s
                        UNION ALL
                        SELECT registration_number FROM qamqor_customs WHERE registration_number ~ %s
                    ) combined
                """, (pattern, pattern))
                total_count = cursor.fetchone()[0]
                
                # –°–ª–µ–¥—É—é—â–∏–π –Ω–æ–º–µ—Ä
                cursor.execute("""
                    SELECT COALESCE(MAX(seq_number), 0) + 1
                    FROM (
                        SELECT CAST(SPLIT_PART(registration_number, '/', 2) AS INTEGER) as seq_number
                        FROM qamqor_tax WHERE registration_number ~ %s
                        UNION ALL
                        SELECT CAST(SPLIT_PART(registration_number, '/', 2) AS INTEGER) as seq_number
                        FROM qamqor_customs WHERE registration_number ~ %s
                    ) combined
                """, (pattern, pattern))
                next_number = cursor.fetchone()[0]
                
                # –ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –Ω–æ–º–µ—Ä–∞
                cursor.execute("""
                    SELECT CAST(SPLIT_PART(registration_number, '/', 2) AS INTEGER) as seq_num
                    FROM (
                        SELECT registration_number FROM qamqor_tax WHERE registration_number ~ %s
                        UNION 
                        SELECT registration_number FROM qamqor_customs WHERE registration_number ~ %s
                    ) combined 
                    ORDER BY seq_num
                """, (pattern, pattern))
                
                existing_numbers = {row[0] for row in cursor.fetchall()}
                missing_count = 0
                
                if existing_numbers:
                    max_num = max(existing_numbers)
                    expected_numbers = set(range(1, max_num + 1))
                    missing_count = len(expected_numbers - existing_numbers)
                
                stats[region_code] = {
                    'total_records': total_count,
                    'next_number': max(next_number, 1),
                    'missing_count': missing_count,
                    'found_new': 0  # –ë—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –≤–æ –≤—Ä–µ–º—è –ø–∞—Ä—Å–∏–Ω–≥–∞
                }
        
        return stats
    
    async def find_missing_numbers(self) -> Dict[int, List[int]]:
        """
        –ü–æ–∏—Å–∫ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤ –≤ –ë–î.
        
        Returns:
            –°–ª–æ–≤–∞—Ä—å {region_code: [missing_numbers]}
        """
        missing_numbers = {}
        
        async with self.get_connection() as conn:
            cursor = conn.cursor()
            
            for region_code in self.config.REGIONS.keys():
                pattern = f'^25{region_code}170101[12]/[0-9]{{5}}$'
                
                cursor.execute("""
                    SELECT CAST(SPLIT_PART(registration_number, '/', 2) AS INTEGER) as seq_num
                    FROM (
                        SELECT registration_number FROM qamqor_tax WHERE registration_number ~ %s
                        UNION 
                        SELECT registration_number FROM qamqor_customs WHERE registration_number ~ %s
                    ) combined 
                    ORDER BY seq_num
                """, (pattern, pattern))
                
                existing_numbers = {row[0] for row in cursor.fetchall()}
                
                if existing_numbers:
                    max_num = max(existing_numbers)
                    expected_numbers = set(range(1, max_num + 1))
                    region_missing = sorted(list(expected_numbers - existing_numbers))
                    
                    # –ò—Å–∫–ª—é—á–∞–µ–º –Ω–æ–º–µ—Ä–∞ –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
                    if region_code in self.config.EXCLUDED_MISSING_NUMBERS:
                        excluded = set(self.config.EXCLUDED_MISSING_NUMBERS[region_code])
                        region_missing = [num for num in region_missing if num not in excluded]
                    
                    if region_missing:
                        missing_numbers[region_code] = region_missing
        
        return missing_numbers
    
    async def bulk_insert_data(
        self, 
        data_batch: List[Dict], 
        silent: bool = False
    ) -> Tuple[int, int]:
        """–ú–∞—Å—Å–æ–≤–∞—è –≤—Å—Ç–∞–≤–∫–∞ —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π."""
        if not data_batch:
            return 0, 0
        
        # ‚úÖ –ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –í–ù–ï —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        tax_data = []
        customs_data = []
        
        for item in data_batch:
            reg_num = item.get('registration_number', '')
            if not reg_num or '/' not in reg_num:
                continue
            
            try:
                prefix, _ = reg_num.split('/')
                check_type = int(prefix[-1])
                values = self._prepare_db_values(item)
                
                if check_type == 1:
                    tax_data.append(values)
                elif check_type == 2:
                    customs_data.append(values)
            except (ValueError, IndexError):
                continue
        
        if not tax_data and not customs_data:
            return 0, 0
        
        # ‚úÖ Retry —Å —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –∑–∞–¥–µ—Ä–∂–∫–æ–π
        for attempt in range(1, 4):
            try:
                async with self.get_connection() as conn:
                    cursor = conn.cursor()
                    tax_inserted = customs_inserted = 0
                    
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º COPY –¥–ª—è –±–æ–ª—å—à–∏—Ö –±–∞—Ç—á–µ–π
                    if len(tax_data) > self.config.BULK_COPY_THRESHOLD:
                        tax_inserted = await self._bulk_copy(cursor, "qamqor_tax", tax_data)
                    elif tax_data:
                        tax_inserted = await self._bulk_execute_values(
                            cursor, "qamqor_tax", tax_data
                        )

                    if len(customs_data) > self.config.BULK_COPY_THRESHOLD:
                        customs_inserted = await self._bulk_copy(
                            cursor, "qamqor_customs", customs_data
                        )
                    elif customs_data:
                        customs_inserted = await self._bulk_execute_values(
                            cursor, "qamqor_customs", customs_data
                        )
                    
                    if not silent and (tax_inserted > 0 or customs_inserted > 0):
                        self.logger.info(f"üíæ TAX: +{tax_inserted}, CUSTOMS: +{customs_inserted}")
                    
                    return tax_inserted, customs_inserted
                
            except (psycopg2.OperationalError, psycopg2.InterfaceError) as e:
                if attempt < 3:
                    delay = self.config.RETRY_BACKOFF_BASE ** attempt
                    self.logger.warning(f"‚ö†Ô∏è DB retry {attempt}/3 —á–µ—Ä–µ–∑ {delay}s")
                    await asyncio.sleep(delay)
                else:
                    self.logger.error(f"‚ùå DB –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –ø–æ—Å–ª–µ 3 –ø–æ–ø—ã—Ç–æ–∫")
                    raise
            
            except Exception as e:
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤—Å—Ç–∞–≤–∫–∏: {e}", exc_info=True)
                raise
        
        return 0, 0

    async def _bulk_execute_values(self, cursor, table_name: str, data: List[Tuple]) -> int:
        """–í—Å—Ç–∞–≤–∫–∞ —á–µ—Ä–µ–∑ execute_values."""
        insert_sql = f"""
            INSERT INTO {table_name} (
                registration_number, reg_date, act_date, start_date, end_date,
                suspend_date, resume_date, prolong_start, prolong_end,
                revenue_name, kpssu_name, check_type, subject_bin, subject_name,
                subject_address, status_id, status, audit_theme, audit_theme_1,
                theme_check, theme_check_1
            ) VALUES %s 
            ON CONFLICT (registration_number) DO NOTHING
        """
        
        psycopg2.extras.execute_values(
            cursor, insert_sql, data, page_size=self.config.EXECUTE_VALUES_PAGE_SIZE
        )
        return cursor.rowcount
    
    def _prepare_db_values(self, item: Dict) -> Tuple:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏."""
        return (
            item.get('registration_number'),
            self._parse_date(item.get('reg_date')),
            self._parse_date(item.get('act_date')),
            self._parse_date(item.get('start_date')),
            self._parse_date(item.get('end_date')),
            self._parse_date(item.get('suspend_date')),
            self._parse_date(item.get('resume_date')),
            self._parse_date(item.get('prolong_start')),
            self._parse_date(item.get('prolong_end')),
            item.get('revenue_name'),
            item.get('kpssu_name'),
            item.get('check_type'),
            item.get('subject_bin'),
            item.get('subject_name'),
            item.get('subject_address'),
            item.get('status_id'),
            item.get('status'),
            item.get('audit_theme'),
            item.get('audit_theme_1'),
            item.get('theme_check'),
            item.get('theme_check_1')
        )
    
    def _parse_date(self, date_str: Optional[str]) -> Optional[str]:
        """–ü–∞—Ä—Å–∏–Ω–≥ –¥–∞—Ç—ã –≤ —Ñ–æ—Ä–º–∞—Ç PostgreSQL."""
        if not date_str:
            return None
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É–∂–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ YYYY-MM-DD
        if len(date_str) == 10 and date_str[4] == '-' and date_str[7] == '-':
            try:
                datetime.strptime(date_str, "%Y-%m-%d")
                return date_str
            except ValueError:
                pass
        
        # –ü–∞—Ä—Å–∏–º –¥—Ä—É–≥–∏–µ —Ñ–æ—Ä–º–∞—Ç—ã
        for fmt in ("%d/%m/%Y", "%d.%m.%Y", "%Y-%m-%d"):
            try:
                return datetime.strptime(date_str, fmt).strftime("%Y-%m-%d")
            except ValueError:
                continue
        
        return None
    
    async def get_summary_stats(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–∑ –ë–î."""
        async with self.get_connection() as conn:
            cursor = conn.cursor()
            stats = {}
            
            for table in ['qamqor_tax', 'qamqor_customs']:
                cursor.execute(f"""
                    SELECT 
                        COUNT(*) as total,
                        MIN(reg_date) as earliest,
                        MAX(reg_date) as latest
                    FROM {table}
                """)
                row = cursor.fetchone()
                stats[table] = {
                    'total': row[0],
                    'earliest': row[1],
                    'latest': row[2]
                }
            
            return stats
    
    async def get_records_to_update(
        self,
        statuses: Optional[List[str]] = None,
        min_age_days: Optional[int] = None,
        max_age_days: Optional[int] = None,          # ‚¨ÖÔ∏è –ù–û–í–û–ï
        cooldown_days: Optional[int] = None,
        force: bool = False
    ) -> Dict[str, List[str]]:
        """
        –ü–æ–ª—É—á–∏—Ç—å registration_numbers –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.
        
        –°—Ç—Ä–∞—Ç–µ–≥–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:
        - 0-7 –¥–Ω–µ–π: –ù–µ –æ–±–Ω–æ–≤–ª—è–µ–º (–ø–µ—Ä–∏–æ–¥ "—Å–æ–∑—Ä–µ–≤–∞–Ω–∏—è")
        - 7-180 –¥–Ω–µ–π: –ê–∫—Ç–∏–≤–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º (–∫–∞–∂–¥—ã–µ 3 –¥–Ω—è)
        - >180 –¥–Ω–µ–π: –ù–µ –æ–±–Ω–æ–≤–ª—è–µ–º (–∞—Ä—Ö–∏–≤–Ω—ã–µ/–∑–∞–≤–∏—Å—à–∏–µ)
        
        Args:
            statuses: –°–ø–∏—Å–æ–∫ —Å—Ç–∞—Ç—É—Å–æ–≤ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
            min_age_days: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç –∑–∞–ø–∏—Å–∏ –æ—Ç reg_date
            max_age_days: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç (–ø—Ä–µ–∫—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª—è—Ç—å)  # ‚¨ÖÔ∏è –ù–û–í–û–ï
            cooldown_days: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏
            force: –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã –ø–æ –≤–æ–∑—Ä–∞—Å—Ç—É
            
        Returns:
            {"tax": [...], "customs": [...]}
        """
        if statuses is None:
            statuses = self.config.UPDATE_STATUSES
        
        if min_age_days is None:
            min_age_days = self.config.UPDATE_MIN_AGE_DAYS
        
        if max_age_days is None:                                       # ‚¨ÖÔ∏è –ù–û–í–û–ï
            max_age_days = self.config.UPDATE_MAX_AGE_DAYS             # ‚¨ÖÔ∏è –ù–û–í–û–ï
        
        if cooldown_days is None:
            cooldown_days = self.config.UPDATE_COOLDOWN_DAYS
        
        result = {"tax": [], "customs": []}
        
        async with self.get_connection() as conn:
            cursor = conn.cursor()
            
            for table_name, key in [("qamqor_tax", "tax"), ("qamqor_customs", "customs")]:
                sql = f"""
                    SELECT registration_number 
                    FROM {table_name}
                    WHERE status_id = ANY(%s)
                    AND reg_date IS NOT NULL
                """
                
                params = [statuses]
                
                if not force:
                    # –ö–†–ò–¢–ï–†–ò–ô 2: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç (–Ω–∞—á–∏–Ω–∞–µ–º –æ–±–Ω–æ–≤–ª—è—Ç—å)
                    sql += f" AND reg_date < CURRENT_DATE - INTERVAL '{min_age_days} days'"
                    
                    # ‚¨ÖÔ∏è –ù–û–í–û–ï: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç (–ø—Ä–µ–∫—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª—è—Ç—å)
                    sql += f" AND reg_date >= CURRENT_DATE - INTERVAL '{max_age_days} days'"
                    
                    # –ö–†–ò–¢–ï–†–ò–ô 3: Cooldown (–Ω–µ –æ–±–Ω–æ–≤–ª—è–ª–∏—Å—å –Ω–µ–¥–∞–≤–Ω–æ)
                    sql += f"""
                        AND (
                            updated_at IS NULL 
                            OR updated_at < NOW() - INTERVAL '{cooldown_days} days'
                            OR updated_at = created_at
                        )
                    """
                
                sql += " ORDER BY reg_date DESC"  # ‚¨ÖÔ∏è –ò–∑–º–µ–Ω–µ–Ω–æ: DESC (—Å–Ω–∞—á–∞–ª–∞ —Å–≤–µ–∂–∏–µ)
                
                cursor.execute(sql, params)
                result[key] = [row[0] for row in cursor.fetchall()]
        
        return result

    async def bulk_update_data(
        self, 
        data_batch: List[Dict], 
        silent: bool = False
    ) -> Tuple[int, int, List[Dict]]:
        """
        –ú–∞—Å—Å–æ–≤–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–µ–π —Å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–π.
        
        Args:
            data_batch: –°–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            silent: –ù–µ –ª–æ–≥–∏—Ä–æ–≤–∞—Ç—å —É—Å–ø–µ—à–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            
        Returns:
            (tax_updated, customs_updated, changes_log)
        """
        if not data_batch:
            return 0, 0, []
        
        # –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ tax –∏ customs
        tax_data = []
        customs_data = []
        
        for item in data_batch:
            reg_num = item.get('registration_number', '')
            if not reg_num or '/' not in reg_num:
                continue
            
            try:
                prefix = reg_num.split('/')[0]
                check_type = int(prefix[-1])
                values = self._prepare_db_values(item)
                
                if check_type == 1:
                    tax_data.append(values)
                elif check_type == 2:
                    customs_data.append(values)
            except (ValueError, IndexError):
                continue
        
        changes_log = []
        
        # Retry-–ª–æ–≥–∏–∫–∞
        max_attempts = 3
        for attempt in range(1, max_attempts + 1):
            try:
                async with self.get_connection() as conn:
                    cursor = conn.cursor()
                    tax_updated = customs_updated = 0
                    
                    # UPDATE SQL —Å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–π
                    update_sql = """
                        WITH old_data AS (
                            SELECT status_id, status, end_date, registration_number
                            FROM {table_name} 
                            WHERE registration_number = %s
                        )
                        UPDATE {table_name} SET
                            reg_date = %s,
                            act_date = %s,
                            start_date = %s,
                            end_date = %s,
                            suspend_date = %s,
                            resume_date = %s,
                            prolong_start = %s,
                            prolong_end = %s,
                            revenue_name = %s,
                            kpssu_name = %s,
                            check_type = %s,
                            subject_bin = %s,
                            subject_name = %s,
                            subject_address = %s,
                            status_id = %s,
                            status = %s,
                            audit_theme = %s,
                            audit_theme_1 = %s,
                            theme_check = %s,
                            theme_check_1 = %s
                        WHERE registration_number = %s
                        RETURNING 
                            (SELECT status_id FROM old_data) as old_status_id,
                            (SELECT status FROM old_data) as old_status,
                            (SELECT end_date FROM old_data) as old_end_date,
                            status_id as new_status_id,
                            status as new_status,
                            end_date as new_end_date,
                            registration_number
                    """
                    
                    if tax_data:
                        for values in tax_data:
                            reg_num = values[0]
                            params = (reg_num,) + values[1:] + (reg_num,)
                            
                            cursor.execute(
                                update_sql.format(table_name="qamqor_tax"),
                                params
                            )
                            
                            result = cursor.fetchone()
                            if result:
                                tax_updated += 1
                                
                                if self.config.UPDATE_TRACK_CHANGES:
                                    changes = self._detect_changes(result)
                                    if changes:
                                        changes_log.append({
                                            'table': 'qamqor_tax',
                                            'registration_number': result[6],
                                            'changes': changes
                                        })
                        
                        if tax_updated > 0 and not silent:
                            self.logger.info(f"üîÑ TAX: ~{tax_updated}")
                    
                    if customs_data:
                        for values in customs_data:
                            reg_num = values[0]
                            params = (reg_num,) + values[1:] + (reg_num,)
                            
                            cursor.execute(
                                update_sql.format(table_name="qamqor_customs"),
                                params
                            )
                            
                            result = cursor.fetchone()
                            if result:
                                customs_updated += 1
                                
                                if self.config.UPDATE_TRACK_CHANGES:
                                    changes = self._detect_changes(result)
                                    if changes:
                                        changes_log.append({
                                            'table': 'qamqor_customs',
                                            'registration_number': result[6],
                                            'changes': changes
                                        })
                        
                        if customs_updated > 0 and not silent:
                            self.logger.info(f"üîÑ CUSTOMS: ~{customs_updated}")
                    
                    # –ó–∞–ø–∏—Å–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ audit_log
                    if changes_log:
                        await self._log_changes(cursor, changes_log)
                    
                    return tax_updated, customs_updated, changes_log
                
            except (psycopg2.OperationalError, psycopg2.InterfaceError) as e:
                if attempt < max_attempts:
                    self.logger.warning(
                        f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è (–ø–æ–ø—ã—Ç–∫–∞ {attempt}/{max_attempts}): {e}"
                    )
                    await asyncio.sleep(2 * attempt)
                else:
                    self.logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ—Å–ª–µ {max_attempts} –ø–æ–ø—ã—Ç–æ–∫")
                    raise
            
            except Exception as e:
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {e}", exc_info=True)
                raise
        
        return 0, 0, []

    def _detect_changes(self, result: Tuple) -> Optional[Dict]:
        """–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–µ–∂–¥—É —Å—Ç–∞—Ä—ã–º–∏ –∏ –Ω–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏."""
        (old_status_id, old_status, old_end_date, 
         new_status_id, new_status, new_end_date, reg_num) = result
        
        changes = {}
        
        if old_status_id != new_status_id:
            changes['status_id'] = {'old': old_status_id, 'new': new_status_id}
        
        if old_status != new_status:
            changes['status'] = {'old': old_status, 'new': new_status}
        
        if old_end_date != new_end_date:
            changes['end_date'] = {
                'old': str(old_end_date) if old_end_date else None,
                'new': str(new_end_date) if new_end_date else None
            }
        
        return changes if changes else None

    async def _log_changes(self, cursor, changes_log: List[Dict]):
        """–ó–∞–ø–∏—Å–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ç–∞–±–ª–∏—Ü—É audit_log."""
        if not changes_log:
            return
        
        insert_sql = """
            INSERT INTO audit_log (
                registration_number, 
                table_name, 
                changed_fields, 
                old_values, 
                new_values
            ) VALUES %s
        """
        
        values = []
        for change in changes_log:
            changed_fields = list(change['changes'].keys())
            old_values = {k: v['old'] for k, v in change['changes'].items()}
            new_values = {k: v['new'] for k, v in change['changes'].items()}
            
            values.append((
                change['registration_number'],
                change['table'],
                changed_fields,
                psycopg2.extras.Json(old_values),
                psycopg2.extras.Json(new_values)
            ))
        
        psycopg2.extras.execute_values(cursor, insert_sql, values)

    async def get_update_summary(self, since: datetime) -> Dict:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–≤–æ–¥–∫—É –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –∑–∞ –ø–µ—Ä–∏–æ–¥."""
        async with self.get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT 
                    table_name,
                    COUNT(*) as total_changes,
                    COUNT(DISTINCT registration_number) as unique_records,
                    array_agg(DISTINCT unnest(changed_fields)) as fields_changed
                FROM audit_log
                WHERE changed_at >= %s
                GROUP BY table_name
            """, (since,))
            
            results = cursor.fetchall()
            
            summary = {}
            for table_name, total, unique, fields in results:
                summary[table_name] = {
                    'total_changes': total,
                    'unique_records': unique,
                    'fields_changed': [f for f in fields if f is not None]
                }
            
            return summary

================================================================================
FILE: core\enums.py
================================================================================

"""–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –¥–ª—è —Ç–∏–ø–∏–∑–∞—Ü–∏–∏ –∏ –∏–∑–±–µ–∂–∞–Ω–∏—è magic strings."""

from enum import Enum


class CheckStatus(str, Enum):
    """
    –°—Ç–∞—Ç—É—Å—ã –ø—Ä–æ–≤–µ—Ä–æ–∫ –≤ —Å–∏—Å—Ç–µ–º–µ QAMQOR.
    
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∑–∞–ø–∏—Å–µ–π –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏.
    """
    IN_PROGRESS = "1"
    COMPLETED = "2"
    CANCELLED = "3"
    
    def __str__(self) -> str:
        """–°—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ."""
        return self.value


class APIResponseCode(str, Enum):
    """
    –ö–æ–¥—ã –æ—Ç–≤–µ—Ç–æ–≤ API QAMQOR.
    
    –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø –æ—Ç–≤–µ—Ç–∞ –∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫.
    """
    OK = "OK"
    RECAPTCHA = "CONTROLLER::RECAPTCHA"
    MAINTENANCE = "MAINTENANCE"
    SERVER_ERROR = "SERVER_ERROR"
    INTERNAL_ERROR = "INTERNAL_ERROR"
    SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE"
    
    def __str__(self) -> str:
        """–°—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ."""
        return self.value
    
    @property
    def is_critical(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç–∏ –æ—à–∏–±–∫–∏."""
        return self in {
            self.MAINTENANCE,
            self.SERVER_ERROR,
            self.INTERNAL_ERROR,
            self.SERVICE_UNAVAILABLE
        }


class APIResponseStatus(str, Enum):
    """–°—Ç–∞—Ç—É—Å—ã HTTP –æ—Ç–≤–µ—Ç–æ–≤ API."""
    SUCCESS = "success"
    ERROR = "error"
    
    def __str__(self) -> str:
        """–°—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ."""
        return self.value


class ParserMode(str, Enum):
    """–†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã –ø–∞—Ä—Å–µ—Ä–∞."""
    FULL = "full"
    MISSING_ONLY = "missing_only"
    UPDATE = "update"
    
    def __str__(self) -> str:
        """–°—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ."""
        return self.value


class TableName(str, Enum):
    """–ù–∞–∑–≤–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü –≤ –ë–î."""
    TAX = "qamqor_tax"
    CUSTOMS = "qamqor_customs"
    AUDIT_LOG = "audit_log"
    
    def __str__(self) -> str:
        """–°—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ."""
        return self.value

================================================================================
FILE: core\log_manager.py
================================================================================

"""–ú–µ–Ω–µ–¥–∂–µ—Ä –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è."""

import logging
from datetime import datetime
from typing import Dict

from .config import Config


class LogManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏."""
    
    def __init__(self, config: Config, name: str = "qamqor"):
        self.config = config
        self.logger = self._setup_logger(name)
        self.metrics = {
            'start_time': datetime.now(),
            'records_processed': 0,
            'api_requests': 0,
            'api_errors': 0,
            'db_inserts': 0,
            'db_updates': 0,
            'regions_completed': 0
        }
        
    def _setup_logger(self, name: str) -> logging.Logger:
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞."""
        self.config.LOG_DIR.mkdir(exist_ok=True)
        
        logger = logging.getLogger(name)
        logger.setLevel(getattr(logging, self.config.LOG_LEVEL))
        logger.handlers.clear()
        logger.propagate = False  # ‚úÖ –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
        
        formatter = logging.Formatter(
            '%(asctime)s | %(levelname)-8s | %(message)s',
            datefmt='%H:%M:%S'
        )
        
        # –§–∞–π–ª–æ–≤—ã–π —Ö–µ–Ω–¥–ª–µ—Ä
        log_file = self.config.LOG_DIR / f"{name}_{datetime.now():%Y%m%d_%H%M%S}.log"
        fh = logging.FileHandler(log_file, encoding='utf-8')
        fh.setFormatter(formatter)
        fh.setLevel(logging.DEBUG)
        
        # –ö–æ–Ω—Å–æ–ª—å–Ω—ã–π —Ö–µ–Ω–¥–ª–µ—Ä
        ch = logging.StreamHandler()
        ch.setFormatter(formatter)
        ch.setLevel(getattr(logging, self.config.LOG_LEVEL))
        
        logger.addHandler(fh)
        logger.addHandler(ch)
        
        return logger
    
    def increment_metric(self, metric_name: str, delta: int = 1):
        """–ò–Ω–∫—Ä–µ–º–µ–Ω—Ç –º–µ—Ç—Ä–∏–∫–∏."""
        if metric_name in self.metrics:
            self.metrics[metric_name] += delta
        else:
            self.logger.warning(f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –º–µ—Ç—Ä–∏–∫–∞: {metric_name}")
    
    def get_metrics_summary(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–∫–∏ –º–µ—Ç—Ä–∏–∫."""
        elapsed = (datetime.now() - self.metrics['start_time']).total_seconds()
        records_per_sec = (
            self.metrics['records_processed'] / elapsed 
            if elapsed > 0 
            else 0
        )
        
        return {
            **self.metrics,
            'elapsed_seconds': round(elapsed, 2),
            'records_per_second': round(records_per_sec, 2)
        }

================================================================================
FILE: core\stealth.py
================================================================================

"""
Stealth utilities –¥–ª—è –æ–±—Ö–æ–¥–∞ –¥–µ—Ç–µ–∫—Ü–∏–∏ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ –±—Ä–∞—É–∑–µ—Ä–∞.
"""

import asyncio
import logging
from contextlib import asynccontextmanager
from typing import List, Set

from playwright.async_api import BrowserContext, Page, Route

from .config import Config


async def apply_stealth(page: Page) -> bool:
    """
    –ú–∞—Å–∫–∏—Ä–æ–≤–∫–∞ –±—Ä–∞—É–∑–µ—Ä–∞ –ø–æ–¥ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    
    –£–¥–∞–ª—è–µ—Ç –ø—Ä–∏–∑–Ω–∞–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ (webdriver —Ñ–ª–∞–≥, –¥–æ–±–∞–≤–ª—è–µ—Ç chrome –æ–±—ä–µ–∫—Ç,
    –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç permissions, plugins –∏ languages).
    
    Args:
        page: –°—Ç—Ä–∞–Ω–∏—Ü–∞ Playwright –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è stealth
        
    Returns:
        True –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏, False –ø—Ä–∏ –æ—à–∏–±–∫–µ
    """
    try:
        await page.add_init_script("""
            // –£–¥–∞–ª—è–µ–º webdriver
            Object.defineProperty(navigator, 'webdriver', {
                get: () => undefined
            });
            
            // Chrome –æ–±—ä–µ–∫—Ç
            window.navigator.chrome = {
                runtime: {},
                loadTimes: function() {},
                csi: function() {}
            };
            
            // Permissions
            const originalQuery = window.navigator.permissions.query;
            window.navigator.permissions.query = (parameters) => (
                parameters.name === 'notifications' ?
                    Promise.resolve({ state: Notification.permission }) :
                    originalQuery(parameters)
            );
            
            // Plugins
            Object.defineProperty(navigator, 'plugins', {
                get: () => [1, 2, 3, 4, 5]
            });
            
            // Languages
            Object.defineProperty(navigator, 'languages', {
                get: () => ['ru-RU', 'ru', 'en-US', 'en']
            });
        """)
        return True
    except Exception:
        return False


class StealthTabManager:
    """
    –ú–µ–Ω–µ–¥–∂–µ—Ä –ø—É–ª–∞ –≤–∫–ª–∞–¥–æ–∫ –±—Ä–∞—É–∑–µ—Ä–∞ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º stealth.
    
    –£–ø—Ä–∞–≤–ª—è–µ—Ç –ø—É–ª–æ–º –≤–∫–ª–∞–¥–æ–∫ —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π –Ω–µ–Ω—É–∂–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ (–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è,
    —Å—Ç–∏–ª–∏, —à—Ä–∏—Ñ—Ç—ã) –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ–º –ø—Ä–∏ —Å–±–æ—è—Ö.
    """
    
    # –¢–∏–ø—ã —Ä–µ—Å—É—Ä—Å–æ–≤ –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
    BLOCKED_RESOURCE_TYPES: Set[str] = {"image", "stylesheet", "font", "media"}
    
    def __init__(
        self,
        context: BrowserContext,
        config: Config,
        logger: logging.Logger
    ):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –≤–∫–ª–∞–¥–æ–∫.
        
        Args:
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç –±—Ä–∞—É–∑–µ—Ä–∞ Playwright
            config: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–∞—Ä—Å–µ—Ä–∞
            logger: –õ–æ–≥–≥–µ—Ä –¥–ª—è –≤—ã–≤–æ–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
        """
        self.context = context
        self.config = config
        self.logger = logger
        self.available_tabs: asyncio.Queue[Page] = asyncio.Queue()
        self.all_tabs: List[Page] = []
        self._lock = asyncio.Lock()
        self._closed = False
    
    async def initialize(self) -> None:
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É–ª–∞ –≤–∫–ª–∞–¥–æ–∫.
        
        –°–æ–∑–¥–∞–µ—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∫–ª–∞–¥–æ–∫,
        –ø—Ä–∏–º–µ–Ω—è–µ—Ç stealth –∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫—É —Ä–µ—Å—É—Ä—Å–æ–≤ –∫ –∫–∞–∂–¥–æ–π.
        
        Raises:
            Exception: –ü—Ä–∏ –æ—à–∏–±–∫–µ —Å–æ–∑–¥–∞–Ω–∏—è –≤–∫–ª–∞–¥–æ–∫
        """
        self.logger.debug(
            "üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è %d –≤–∫–ª–∞–¥–æ–∫...",
            self.config.MAX_CONCURRENT_TABS
        )
        
        for i in range(self.config.MAX_CONCURRENT_TABS):
            try:
                page = await self._create_configured_page()
                await apply_stealth(page)
                
                self.all_tabs.append(page)
                await self.available_tabs.put(page)
                
                self.logger.debug("‚úÖ –í–∫–ª–∞–¥–∫–∞ %d (stealth) —Å–æ–∑–¥–∞–Ω–∞", i + 1)
            except Exception as e:
                self.logger.error("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≤–∫–ª–∞–¥–∫–∏ %d: %s", i + 1, e)
                await self.close_all()
                raise
        
        self.logger.debug("‚úÖ –ü—É–ª –≤–∫–ª–∞–¥–æ–∫ (stealth) –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    async def _create_configured_page(self) -> Page:
        """
        –°–æ–∑–¥–∞–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π –≤–∫–ª–∞–¥–∫–∏ —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π —Ä–µ—Å—É—Ä—Å–æ–≤.
        
        Returns:
            –ù–∞—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è –≤–∫–ª–∞–¥–∫–∞ Playwright
        """
        page = await self.context.new_page()
        
        async def route_handler(route: Route) -> None:
            """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –º–∞—Ä—à—Ä—É—Ç–æ–≤ –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤."""
            try:
                if route.request.resource_type in self.BLOCKED_RESOURCE_TYPES:
                    await route.abort()
                else:
                    await route.continue_()
            except Exception:
                try:
                    await route.abort()
                except Exception:
                    pass
        
        await page.route("**/*", route_handler)
        return page
    
    @asynccontextmanager
    async def get_tab(self):
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –≤–∫–ª–∞–¥–∫–∏ –∏–∑ –ø—É–ª–∞ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ–º.
        
        –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –∏ –≤–æ–∑–≤—Ä–∞—Ç–∞
        –≤–∫–ª–∞–¥–∫–∏ –≤ –ø—É–ª. –ü—Ä–∏ –∑–∞–∫—Ä—ã—Ç–æ–π –≤–∫–ª–∞–¥–∫–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é.
        
        Yields:
            Page: –í–∫–ª–∞–¥–∫–∞ –±—Ä–∞—É–∑–µ—Ä–∞
            
        Raises:
            RuntimeError: –ï—Å–ª–∏ TabManager —É–∂–µ –∑–∞–∫—Ä—ã—Ç
        """
        if self._closed:
            raise RuntimeError("TabManager –∑–∞–∫—Ä—ã—Ç")
        
        page = await self.available_tabs.get()
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ–π –≤–∫–ª–∞–¥–∫–∏
        if page.is_closed():
            async with self._lock:
                # Double-check –ø–æ–¥ lock'–æ–º
                if page.is_closed():
                    self.logger.warning("‚ö†Ô∏è –í–∫–ª–∞–¥–∫–∞ –∑–∞–∫—Ä—ã—Ç–∞, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é")
                    try:
                        new_page = await self._create_configured_page()
                        await apply_stealth(new_page)
                        
                        # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞
                        try:
                            idx = self.all_tabs.index(page)
                            self.all_tabs[idx] = new_page
                        except ValueError:
                            self.all_tabs.append(new_page)
                        
                        page = new_page
                    except Exception as e:
                        self.logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≤–∫–ª–∞–¥–∫—É: %s", e)
                        await self.available_tabs.put(page)
                        raise
        
        try:
            yield page
        except Exception as e:
            self.logger.error("‚ùå –û—à–∏–±–∫–∞ —Ä–∞–±–æ—Ç—ã —Å –≤–∫–ª–∞–¥–∫–æ–π: %s", e)
            
            # –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
            async with self._lock:
                try:
                    if not page.is_closed():
                        await page.close()
                except Exception:
                    pass
                
                try:
                    page = await self._create_configured_page()
                    await apply_stealth(page)
                    self.logger.info("‚úÖ –í–∫–ª–∞–¥–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ—Å–ª–µ –æ—à–∏–±–∫–∏")
                except Exception as create_error:
                    self.logger.critical(
                        "üö® –ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–∫–ª–∞–¥–∫—É: %s",
                        create_error
                    )
                    raise
            raise
        finally:
            # –í–æ–∑–≤—Ä–∞—Ç –≤–∫–ª–∞–¥–∫–∏ –≤ –ø—É–ª
            if not page.is_closed():
                await self.available_tabs.put(page)
            else:
                # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ
                asyncio.create_task(self._restore_pool_tab(page))
    
    async def _restore_pool_tab(self, closed_page: Page) -> None:
        """
        –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∫–ª–∞–¥–∫–∏ –≤ –ø—É–ª–µ.
        
        Args:
            closed_page: –ó–∞–∫—Ä—ã—Ç–∞—è –≤–∫–ª–∞–¥–∫–∞ –¥–ª—è –∑–∞–º–µ–Ω—ã
        """
        async with self._lock:
            try:
                new_page = await self._create_configured_page()
                await apply_stealth(new_page)
                await self.available_tabs.put(new_page)
                
                # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞
                try:
                    idx = self.all_tabs.index(closed_page)
                    self.all_tabs[idx] = new_page
                except ValueError:
                    self.all_tabs.append(new_page)
            except Exception as e:
                self.logger.critical("üö® –ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—É–ª: %s", e)
    
    async def close_all(self) -> None:
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –≤–∫–ª–∞–¥–æ–∫ –≤ –ø—É–ª–µ."""
        self._closed = True
        
        async with self._lock:
            for i, page in enumerate(self.all_tabs):
                try:
                    if not page.is_closed():
                        await page.close()
                except Exception:
                    pass

================================================================================
FILE: core\tab_manager.py
================================================================================

"""–ú–µ–Ω–µ–¥–∂–µ—Ä –ø—É–ª–∞ –≤–∫–ª–∞–¥–æ–∫ –±—Ä–∞—É–∑–µ—Ä–∞."""

import asyncio
import logging
from contextlib import asynccontextmanager
from typing import List

from playwright.async_api import BrowserContext, Page

from .config import Config


class TabManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –ø—É–ª–∞ –≤–∫–ª–∞–¥–æ–∫ –±—Ä–∞—É–∑–µ—Ä–∞."""
    
    def __init__(self, context: BrowserContext, config: Config, logger: logging.Logger):
        self.context = context
        self.config = config
        self.logger = logger
        self.available_tabs: asyncio.Queue[Page] = asyncio.Queue()
        self.all_tabs: List[Page] = []
        self._lock = asyncio.Lock()
        self._closed = False
        
    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É–ª–∞ –≤–∫–ª–∞–¥–æ–∫."""
        self.logger.debug(f"üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è {self.config.MAX_CONCURRENT_TABS} –≤–∫–ª–∞–¥–æ–∫...")
        
        for i in range(self.config.MAX_CONCURRENT_TABS):
            try:
                page = await self._create_configured_page()
                self.all_tabs.append(page)
                await self.available_tabs.put(page)
                self.logger.debug(f"‚úÖ –í–∫–ª–∞–¥–∫–∞ {i+1}/{self.config.MAX_CONCURRENT_TABS} —Å–æ–∑–¥–∞–Ω–∞")
            except Exception as e:
                self.logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≤–∫–ª–∞–¥–∫—É {i+1}: {e}")
                # –ó–∞–∫—Ä—ã–≤–∞–µ–º —É–∂–µ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –≤–∫–ª–∞–¥–∫–∏
                await self.close_all()
                raise
        
        self.logger.debug("‚úÖ –ü—É–ª –≤–∫–ª–∞–¥–æ–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    async def _create_configured_page(self) -> Page:
        """
        –°–æ–∑–¥–∞–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π –≤–∫–ª–∞–¥–∫–∏ —Å –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π –ª–∏—à–Ω–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤.
        
        Returns:
            –ù–∞—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è –≤–∫–ª–∞–¥–∫–∞
        """
        page = await self.context.new_page()
        
        # ‚úÖ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –Ω–µ–Ω—É–∂–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
        blocked_types = {"image", "stylesheet", "font", "media"}
        
        async def route_handler(route):
            """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –º–∞—Ä—à—Ä—É—Ç–æ–≤."""
            try:
                if route.request.resource_type in blocked_types:
                    await route.abort()
                else:
                    await route.continue_()
            except Exception as e:
                self.logger.debug(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–∞—Ä—à—Ä—É—Ç–∞: {e}")
                try:
                    await route.abort()
                except Exception:
                    pass
        
        await page.route("**/*", route_handler)
        
        return page
    
    @asynccontextmanager
    async def get_tab(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤–∫–ª–∞–¥–∫–∏ —Å –±–µ–∑–æ–ø–∞—Å–Ω—ã–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ–º."""
        if self._closed:
            raise RuntimeError("TabManager —É–∂–µ –∑–∞–∫—Ä—ã—Ç")
        
        page = await self.available_tabs.get()
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–¥ –æ–¥–Ω–∏–º lock'–æ–º
        if page.is_closed():
            async with self._lock:
                # ‚úÖ Double-check –ø–æ–¥ lock'–æ–º
                if page.is_closed():
                    self.logger.warning("‚ö†Ô∏è –í–∫–ª–∞–¥–∫–∞ –∑–∞–∫—Ä—ã—Ç–∞, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é")
                    try:
                        new_page = await self._create_configured_page()
                        
                        # ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞
                        try:
                            idx = self.all_tabs.index(page)
                            self.all_tabs[idx] = new_page
                        except ValueError:
                            # –°—Ç–∞—Ä–∞—è –≤–∫–ª–∞–¥–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é
                            self.all_tabs.append(new_page)
                        
                        page = new_page
                        
                    except Exception as e:
                        self.logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≤–∫–ª–∞–¥–∫—É: {e}")
                        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —á—Ç–æ-—Ç–æ –≤ –ø—É–ª, —á—Ç–æ–±—ã –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å
                        await self.available_tabs.put(page)
                        raise
        
        try:
            yield page
            
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞–±–æ—Ç—ã —Å –≤–∫–ª–∞–¥–∫–æ–π: {e}")
            
            # –ü—Ä–∏ –æ—à–∏–±–∫–µ –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–∫–ª–∞–¥–∫—É
            async with self._lock:
                try:
                    if not page.is_closed():
                        await page.close()
                except Exception:
                    pass
                
                # –°–æ–∑–¥–∞–µ–º –∑–∞–º–µ–Ω—É
                try:
                    page = await self._create_configured_page()
                    self.logger.info("‚úÖ –í–∫–ª–∞–¥–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ—Å–ª–µ –æ—à–∏–±–∫–∏")
                except Exception as create_error:
                    self.logger.critical(f"üö® –ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–∫–ª–∞–¥–∫—É: {create_error}")
                    try:
                        page = await self.context.new_page()
                    except Exception:
                        raise RuntimeError("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≤–∫–ª–∞–¥–∫—É") from create_error
            
            raise
            
        finally:
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤–∫–ª–∞–¥–∫—É –≤ –ø—É–ª
            if not page.is_closed():
                await self.available_tabs.put(page)
            else:
                # ‚úÖ –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª–∞
                asyncio.create_task(self._restore_pool_tab(page))

    async def _restore_pool_tab(self, closed_page: Page):
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∫–ª–∞–¥–∫–∏ –≤ –ø—É–ª–µ."""
        async with self._lock:
            try:
                new_page = await self._create_configured_page()
                await self.available_tabs.put(new_page)
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫
                try:
                    idx = self.all_tabs.index(closed_page)
                    self.all_tabs[idx] = new_page
                except ValueError:
                    self.all_tabs.append(new_page)
                    
            except Exception as e:
                self.logger.critical(f"üö® –ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—É–ª –≤–∫–ª–∞–¥–æ–∫: {e}")
    
    async def close_all(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –≤–∫–ª–∞–¥–æ–∫."""
        self._closed = True
        
        self.logger.debug("üîß –ó–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –≤–∫–ª–∞–¥–æ–∫...")
        
        async with self._lock:
            for i, page in enumerate(self.all_tabs):
                try:
                    if not page.is_closed():
                        await page.close()
                        self.logger.debug(f"‚úÖ –í–∫–ª–∞–¥–∫–∞ {i+1} –∑–∞–∫—Ä—ã—Ç–∞")
                except Exception as e:
                    self.logger.debug(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è –≤–∫–ª–∞–¥–∫–∏ {i+1}: {e}")
        
        self.logger.debug("‚úÖ –í—Å–µ –≤–∫–ª–∞–¥–∫–∏ –∑–∞–∫—Ä—ã—Ç—ã")

================================================================================
FILE: core\web_client.py
================================================================================

"""–ö–ª–∏–µ–Ω—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–µ—Ä–≤–∏—Å–∞."""

import asyncio
import logging
from typing import Optional

from playwright.async_api import Page, Response

from .config import Config
from .api_validator import APIValidator


class WebClient:
    """–ö–ª–∏–µ–Ω—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–µ—Ä–≤–∏—Å–∞."""
    
    def __init__(self, config: Config, logger: logging.Logger, validator: APIValidator):
        self.config = config
        self.logger = logger
        self.validator = validator
    
    async def check_api_health_with_page(self, page: Page) -> bool:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ API —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –≤–∫–ª–∞–¥–∫–∏.
        
        Args:
            page: –í–∫–ª–∞–¥–∫–∞ –±—Ä–∞—É–∑–µ—Ä–∞
            
        Returns:
            True –µ—Å–ª–∏ API —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
        """
        try:
            self.logger.info("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ API...")
            
            test_number = self.config.TEST_NUMBER
            response_future: asyncio.Future[Response] = asyncio.Future()
            
            def handle_response(response: Response):
                """–°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–≤–µ—Ç–∞."""
                if self.config.API_ENDPOINT in response.url:
                    if not response_future.done():
                        response_future.set_result(response)
            
            page.on("response", handle_response)
            
            try:
                # –ó–∞–ø–æ–ª–Ω—è–µ–º –ø–æ–ª–µ
                await page.fill(
                    'input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]', 
                    test_number
                )
                
                # –ö–ª–∏–∫–∞–µ–º
                await page.click("button.btn.btn-primary:has-text('–Ü–∑–¥–µ—É')")
                
                # –ñ–¥–µ–º Response –æ–±—ä–µ–∫—Ç
                response = await asyncio.wait_for(
                    response_future,
                    timeout=self.config.RESPONSE_TIMEOUT
                )
                
                # –ü–∞—Ä—Å–∏–º JSON –≤–Ω–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞
                response_data = await response.json()
                
                if not response_data:
                    self.logger.error("‚ùå API –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª")
                    return False
                
                # –í–∞–ª–∏–¥–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞
                is_valid, error_msg = self.validator.validate_response(
                    response_data, 
                    context="–ü—Ä–æ–≤–µ—Ä–∫–∞ API"
                )
                
                if not is_valid:
                    self.logger.error(f"‚ùå API –≤–µ—Ä–Ω—É–ª –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç: {error_msg}")
                    self.logger.debug(f"   –û—Ç–≤–µ—Ç: {response_data}")
                    return False
                
                self.logger.info("‚úÖ API —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ")
                return True
                
            finally:
                # –£–¥–∞–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
                try:
                    page.remove_listener("response", handle_response)
                except Exception:
                    pass
                
        except asyncio.TimeoutError:
            self.logger.error("‚ùå –¢–∞–π–º–∞—É—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ API")
            return False
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ API: {e}", exc_info=True)
            return False

================================================================================
FILE: qamqor_parser.py
================================================================================

"""
QAMQOR Parser - –û—Å–Ω–æ–≤–Ω–æ–π –ø–∞—Ä—Å–µ—Ä —Å –æ–±—Ö–æ–¥–æ–º reCAPTCHA –∏ —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –∑–∞–¥–µ—Ä–∂–∫–∞–º–∏.
–ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å stealth-—Ä–µ–∂–∏–º–æ–º –∏ –≤–∏–∑—É–∞–ª—å–Ω–æ–π –æ—Ç–ª–∞–¥–∫–æ–π.
"""

import asyncio
import argparse
import signal
import sys
import random
from types import FrameType
from typing import Any, Dict, List, Optional, Tuple
from contextlib import asynccontextmanager, suppress
from signal import Signals
from datetime import datetime

from playwright.async_api import async_playwright, Page, Response

from .core import (
    Config,
    DatabaseManager,
    DataProcessor,
    APIValidator,
    WebClient,
    StealthTabManager,
    LogManager,
    apply_stealth
)

class QamqorParser:
    """–û—Å–Ω–æ–≤–Ω–æ–π –ø–∞—Ä—Å–µ—Ä QAMQOR —Å –æ–±—Ö–æ–¥–æ–º CAPTCHA –∏ —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –∑–∞–¥–µ—Ä–∂–∫–∞–º–∏."""
    
    def __init__(self, mode: str = "full") -> None:
        self.config = Config()
        self.config.MODE = mode
        
        self.log_manager = LogManager(self.config, name="qamqor_parser")
        self.logger = self.log_manager.logger
        
        self.db_manager = DatabaseManager(self.config, self.logger)
        self.data_processor = DataProcessor(self.config, self.logger)
        self.api_validator = APIValidator(self.logger)
        self.web_client = WebClient(self.config, self.logger, self.api_validator)
        
        self.data_queue: asyncio.Queue = asyncio.Queue()
        self.shutdown_event = asyncio.Event()
        self.active_workers: List[asyncio.Task] = []
        
        self.region_stats: Dict = {}
        
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum: Signals, frame: Optional[FrameType]) -> None:
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è."""
        self.logger.warning(f"‚ö†Ô∏è –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª {signum}, –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã...")
        self.shutdown_event.set()
    
    async def _graceful_shutdown(self, timeout: float = 30.0):
        """–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã."""
        if not self.active_workers:
            return
        
        self.logger.warning(f"‚ö†Ô∏è Graceful shutdown: {len(self.active_workers)} –≤–æ—Ä–∫–µ—Ä–æ–≤...")
        self.shutdown_event.set()
        
        try:
            await asyncio.wait_for(
                asyncio.gather(*self.active_workers, return_exceptions=True),
                timeout=timeout
            )
            self.logger.info("‚úÖ –í—Å–µ –≤–æ—Ä–∫–µ—Ä—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã")
        except asyncio.TimeoutError:
            self.logger.warning(f"‚ö†Ô∏è –¢–∞–π–º–∞—É—Ç {timeout}s, –æ—Ç–º–µ–Ω–∞ –∑–∞–¥–∞—á...")
            for task in self.active_workers:
                if not task.done():
                    task.cancel()
            await asyncio.gather(*self.active_workers, return_exceptions=True)
        finally:
            self.active_workers.clear()
    
    async def run(self) -> bool:
        """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –ø–∞—Ä—Å–µ—Ä–∞."""
        try:
            self.logger.info("=" * 80)
            self.logger.info("üöÄ –ó–ê–ü–£–°–ö –ü–ê–†–°–ï–†–ê QAMQOR | –†–µ–∂–∏–º: %s", self.config.MODE.upper())
            self.logger.info("=" * 80)
            
            await self.db_manager.initialize_tables()
            self.region_stats = await self.db_manager.get_region_stats()
            
            if self.config.MODE == "missing_only":
                self.logger.info("üîç –†–µ–∂–∏–º: –¢–û–õ–¨–ö–û –ü–†–û–ü–£–©–ï–ù–ù–´–ï –ù–û–ú–ï–†–ê")
                await self._run_missing_numbers_search()
            else:
                region_state = await self.db_manager.get_region_state()
                self.logger.info("üì° –†–µ–∂–∏–º: –ü–û–õ–ù–´–ô –ü–ê–†–°–ò–ù–ì")
                await self._run_parsing(region_state)
                
                if not self.shutdown_event.is_set():
                    self.logger.info("")
                    self.logger.info("=" * 80)
                    self.logger.info("üîç –§–ê–ó–ê 2: –ü–û–ò–°–ö –ü–†–û–ü–£–©–ï–ù–ù–´–• –ù–û–ú–ï–†–û–í")
                    self.logger.info("=" * 80)
                    await self._run_missing_numbers_search()
            
            await self._print_final_table()
            
            self.logger.info("=" * 80)
            self.logger.info("‚úÖ –ü–ê–†–°–ò–ù–ì –ó–ê–í–ï–†–®–ï–ù")
            self.logger.info("=" * 80)
            return True
            
        except KeyboardInterrupt:
            self.logger.warning("‚ö†Ô∏è –ü—Ä–µ—Ä–≤–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
            return False
        except Exception as e:
            self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}", exc_info=True)
            return False
    
    async def _run_parsing(self, region_state: Dict[int, int]):
        """–ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞."""
        async with async_playwright() as playwright:
            self.logger.info("üîß –ó–∞–ø—É—Å–∫ –±—Ä–∞—É–∑–µ—Ä–∞...")
            browser = await playwright.chromium.launch(
                headless=True,
                args=[
                    "--disable-blink-features=AutomationControlled",
                    "--disable-dev-shm-usage",
                    "--no-sandbox",
                    "--disable-setuid-sandbox",
                    "--disable-gpu",
                    "--disable-software-rasterizer",
                    "--disable-extensions",
                    "--disable-background-networking",
                    "--disable-background-timer-throttling",
                    "--disable-backgrounding-occluded-windows",
                    "--disable-breakpad",
                    "--disable-component-extensions-with-background-pages",
                    "--disable-features=TranslateUI,BlinkGenPropertyTrees",
                    "--disable-ipc-flooding-protection",
                    "--disable-renderer-backgrounding",
                    "--enable-features=NetworkService,NetworkServiceInProcess",
                    "--force-color-profile=srgb",
                    "--hide-scrollbars",
                    "--metrics-recording-only",
                    "--mute-audio",
                    "--no-first-run",
                    "--disable-infobars",
                    "--window-size=1920,1080"
                ]
            )
            
            self.logger.info("üîß –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞...")
            context = await browser.new_context(
                viewport={"width": 1920, "height": 1080},
                user_agent=(
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                    "AppleWebKit/537.36 (KHTML, like Gecko) "
                    "Chrome/120.0.0.0 Safari/537.36"
                ),
                locale="ru-RU,ru",
                timezone_id="Asia/Almaty",
                geolocation={"longitude": 76.8512, "latitude": 43.2220},
                permissions=["geolocation"],
                color_scheme="light",
                device_scale_factor=1,
                has_touch=False,
                is_mobile=False,
                extra_http_headers={
                    "Accept-Language": "ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7",
                    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
                    "Accept-Encoding": "gzip, deflate, br",
                    "DNT": "1",
                    "Connection": "keep-alive",
                    "Upgrade-Insecure-Requests": "1",
                    "Sec-Fetch-Dest": "document",
                    "Sec-Fetch-Mode": "navigate",
                    "Sec-Fetch-Site": "none",
                    "Sec-Fetch-User": "?1"
                }
            )
            
            # Health check
            self.logger.info("üè• –ó–∞–ø—É—Å–∫ Health Check...")
            health_check_page = await context.new_page()
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º stealth
            await apply_stealth(health_check_page)
            
            # –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
            async def health_route_handler(route):
                if route.request.resource_type in ["image", "stylesheet", "font", "media"]:
                    await route.abort()
                else:
                    await route.continue_()
            
            await health_check_page.route("**/*", health_route_handler)
            
            try:
                self.logger.info(f"üåê –ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {self.config.SEARCH_URL}")
                
                await health_check_page.goto(
                    self.config.SEARCH_URL,
                    timeout=self.config.PAGE_TIMEOUT,
                    wait_until="domcontentloaded"
                )
                
                # –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫—É –ø–æ–ª—è –≤–≤–æ–¥–∞
                await health_check_page.wait_for_selector(
                    'input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]',
                    state="visible",
                    timeout=10000
                )
                
                self.logger.info("‚úÖ –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ API
                if not await self.web_client.check_api_health_with_page(health_check_page):
                    self.logger.error("‚ùå API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
                    return
                
                self.logger.info("‚úÖ Health Check –ø—Ä–æ–π–¥–µ–Ω —É—Å–ø–µ—à–Ω–æ")
                    
            except Exception as e:
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ health check: {e}", exc_info=True)
                return
                
            finally:
                await health_check_page.close()
            
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TabManager
            self.logger.info("üîß –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TabManager...")
            tab_manager = StealthTabManager(context, self.config, self.logger)
            await tab_manager.initialize()
            
            # –ó–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –¥–∞–Ω–Ω—ã—Ö
            data_handler_task = asyncio.create_task(
                self._data_handler(),
                name="data_handler"
            )
            
            # –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—á–µ—Ä–µ–¥–∏ —Ä–µ–≥–∏–æ–Ω–æ–≤
            region_queue: asyncio.Queue = asyncio.Queue()
            for region_code, start_pos in region_state.items():
                region_name = self.config.REGIONS[region_code]
                await region_queue.put((region_code, region_name, start_pos))
            
            self.logger.info("üìã –í –æ—á–µ—Ä–µ–¥–∏ %d —Ä–µ–≥–∏–æ–Ω–æ–≤", len(self.config.REGIONS))
            
            # –ó–∞–ø—É—Å–∫ –≤–æ—Ä–∫–µ—Ä–æ–≤
            self.active_workers = [
                asyncio.create_task(
                    self._region_worker(worker_id, region_queue, tab_manager),
                    name=f"region_worker_{worker_id}"
                )
                for worker_id in range(self.config.MAX_CONCURRENT_TABS)
            ]
            
            self.logger.info("üë∑ –ó–∞–ø—É—â–µ–Ω–æ %d –≤–æ—Ä–∫–µ—Ä–æ–≤", len(self.active_workers))
            
            try:
                await asyncio.gather(*self.active_workers, return_exceptions=True)
                
                if self.shutdown_event.is_set():
                    await self._graceful_shutdown(timeout=30.0)
            
            except KeyboardInterrupt:
                self.logger.warning("‚ö†Ô∏è KeyboardInterrupt - graceful shutdown...")
                await self._graceful_shutdown(timeout=30.0)
            
            finally:
                # –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –¥–∞–Ω–Ω—ã—Ö
                try:
                    self.logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –¥–∞–Ω–Ω—ã—Ö...")
                    await self.data_queue.put(None)
                    await asyncio.wait_for(data_handler_task, timeout=15.0)
                    self.logger.info("‚úÖ Data handler –∑–∞–≤–µ—Ä—à–µ–Ω")
                except asyncio.TimeoutError:
                    self.logger.warning("‚ö†Ô∏è –¢–∞–π–º–∞—É—Ç data_handler (15s)")
                    data_handler_task.cancel()
                    try:
                        await data_handler_task
                    except asyncio.CancelledError:
                        pass
                
                # –ó–∞–∫—Ä—ã—Ç–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤
                await tab_manager.close_all()
                await browser.close()
                self.logger.info("üîí –ë—Ä–∞—É–∑–µ—Ä –∑–∞–∫—Ä—ã—Ç")
    
    async def _run_missing_numbers_search(self):
        """–ü–æ–∏—Å–∫ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤."""
        missing_numbers = await self.db_manager.find_missing_numbers()
        
        if not missing_numbers:
            self.logger.info("‚úÖ –ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
            return
        
        total_missing = sum(len(nums) for nums in missing_numbers.values())
        self.logger.info("üìã –ù–∞–π–¥–µ–Ω–æ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤: %d", total_missing)
        
        async with async_playwright() as playwright:
            browser = await playwright.chromium.launch(
                headless=True,
                args=["--disable-dev-shm-usage", "--no-sandbox", "--disable-gpu"]
            )
            
            context = await browser.new_context(
                viewport={"width": 1920, "height": 1080},
                user_agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
            )
            
            tab_manager = StealthTabManager(context, self.config, self.logger)
            await tab_manager.initialize()
            
            data_handler_task = asyncio.create_task(
                self._data_handler(),
                name="missing_data_handler"
            )
            
            missing_queue: asyncio.Queue = asyncio.Queue()
            for region_code, numbers in missing_numbers.items():
                region_name = self.config.REGIONS[region_code]
                await missing_queue.put((region_code, region_name, numbers))
            
            self.active_workers = [
                asyncio.create_task(
                    self._missing_numbers_worker(worker_id, missing_queue, tab_manager),
                    name=f"missing_worker_{worker_id}"
                )
                for worker_id in range(self.config.MAX_CONCURRENT_TABS)
            ]
            
            try:
                await asyncio.gather(*self.active_workers, return_exceptions=True)
            finally:
                try:
                    await self.data_queue.put(None)
                    await asyncio.wait_for(data_handler_task, timeout=15.0)
                except asyncio.TimeoutError:
                    data_handler_task.cancel()
                
                await tab_manager.close_all()
                await browser.close()
    
    async def _region_worker(
        self,
        worker_id: int,
        region_queue: asyncio.Queue[Tuple[int, str, int]],
        tab_manager: StealthTabManager
    ) -> None:
        """–í–æ—Ä–∫–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ä–µ–≥–∏–æ–Ω–∞."""
        self.logger.debug(f"‚úÖ W{worker_id} –∑–∞–ø—É—â–µ–Ω")
        
        while not self.shutdown_event.is_set():
            try:
                try:
                    region_data = await asyncio.wait_for(
                        region_queue.get(),
                        timeout=1.0
                    )
                except asyncio.TimeoutError:
                    if region_queue.empty():
                        self.logger.debug(f"‚úÖ W{worker_id} –∑–∞–≤–µ—Ä—à–µ–Ω (–æ—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞)")
                        break
                    continue
                
                region_code, region_name, start_pos = region_data
                
            except asyncio.CancelledError:
                self.logger.debug(f"üõë W{worker_id} –æ—Ç–º–µ–Ω–µ–Ω")
                break
            except Exception as e:
                self.logger.error(f"‚ùå W{worker_id} –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
                break
            
            if self.shutdown_event.is_set():
                self.logger.warning(f"‚ö†Ô∏è W{worker_id} | {region_name} –ø—Ä–æ–ø—É—â–µ–Ω (shutdown)")
                region_queue.task_done()
                continue
            
            success = False
            for attempt in range(1, self.config.REGION_RETRY_LIMIT + 1):
                try:
                    async with tab_manager.get_tab() as page:
                        await self._parse_region(
                            page, region_code, region_name, start_pos, worker_id
                        )
                    
                    success = True
                    break
                    
                except Exception as e:
                    if self.shutdown_event.is_set():
                        self.logger.error(f"‚ùå W{worker_id} | {region_name} –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
                        break
                    
                    if attempt < self.config.REGION_RETRY_LIMIT:
                        delay = self.config.RETRY_DELAY * attempt
                        self.logger.warning(
                            f"‚ö†Ô∏è W{worker_id} | {region_name} "
                            f"–ø–æ–ø—ã—Ç–∫–∞ {attempt}/{self.config.REGION_RETRY_LIMIT}, "
                            f"–ø–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ {delay}s: {e}"
                        )
                        await asyncio.sleep(delay)
                    else:
                        self.logger.error(f"‚ùå W{worker_id} | {region_name} –û–®–ò–ë–ö–ê")
            
            region_queue.task_done()
            
            if not success:
                self.logger.warning(f"‚ö†Ô∏è {region_name} –Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω –ø–æ–ª–Ω–æ—Å—Ç—å—é")
        
        self.logger.debug(f"‚úÖ W{worker_id} –∑–∞–≤–µ—Ä—à–µ–Ω")
    
    async def _missing_numbers_worker(
        self,
        worker_id: int,
        missing_queue: asyncio.Queue[Tuple[int, str, List[int]]],
        tab_manager: StealthTabManager
    ) -> None:
        """–í–æ—Ä–∫–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤."""
        self.logger.debug(f"‚úÖ MW{worker_id} –∑–∞–ø—É—â–µ–Ω (missing)")
        
        while not self.shutdown_event.is_set():
            try:
                try:
                    region_data = await asyncio.wait_for(
                        missing_queue.get(),
                        timeout=1.0
                    )
                except asyncio.TimeoutError:
                    if missing_queue.empty():
                        break
                    continue
                
                region_code, region_name, numbers = region_data
                    
            except asyncio.CancelledError:
                self.logger.debug(f"üõë MW{worker_id} –æ—Ç–º–µ–Ω–µ–Ω")
                break
            
            if self.shutdown_event.is_set():
                self.logger.warning(f"‚ö†Ô∏è MW{worker_id} | {region_name} (missing) –ø—Ä–æ–ø—É—â–µ–Ω")
                missing_queue.task_done()
                continue
            
            for attempt in range(1, self.config.REGION_RETRY_LIMIT + 1):
                try:
                    async with tab_manager.get_tab() as page:
                        await self._process_missing_numbers(
                            page, region_code, region_name, numbers, worker_id
                        )
                    break
                    
                except Exception as e:
                    if self.shutdown_event.is_set():
                        break
                    
                    if attempt < self.config.REGION_RETRY_LIMIT:
                        delay = self.config.RETRY_DELAY * attempt
                        self.logger.warning(f"‚ö†Ô∏è MW{worker_id} | {region_name} retry {attempt}")
                        await asyncio.sleep(delay)
            
            missing_queue.task_done()
        
        self.logger.debug(f"‚úÖ MW{worker_id} –∑–∞–≤–µ—Ä—à–µ–Ω (missing)")
    
    async def _parse_region(
        self,
        page: Page,
        region_code: int,
        region_name: str,
        start_position: int,
        worker_id: int
    ):
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ä–µ–≥–∏–æ–Ω–∞ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –æ–∂–∏–¥–∞–Ω–∏–µ–º –∑–∞–≥—Ä—É–∑–∫–∏."""
        await page.goto(
            self.config.SEARCH_URL,
            timeout=self.config.PAGE_TIMEOUT,
            wait_until="domcontentloaded"
        )
        
        await page.wait_for_selector(
            'input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]',
            state="visible",
            timeout=10000
        )
        
        # –°–ª—É—á–∞–π–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏
        await asyncio.sleep(
            random.uniform(self.config.NATURAL_DELAY_MIN, self.config.NATURAL_DELAY_MAX)
        )
        
        current_position = start_position
        empty_count = 0
        found_count = 0
        
        input_selector = 'input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]'
        button_selector = "button.btn.btn-primary:has-text('–Ü–∑–¥–µ—É')"
        
        while current_position <= self.config.MAX_NUMBER and not self.shutdown_event.is_set():
            found_in_position = False
            
            for check_type in [1, 2]:
                if self.shutdown_event.is_set():
                    break
                
                reg_num = f"25{region_code}170101{check_type}/{current_position:05d}"
                
                try:
                    result = await self._try_number_safe(
                        page, reg_num, worker_id, input_selector, button_selector
                    )
                    
                    if result:
                        await self.data_queue.put({
                            'data': result,
                            'region_code': region_code
                        })
                        found_in_position = True
                        found_count += 1
                        empty_count = 0
                        break
                except Exception:
                    pass
            
            if not found_in_position:
                empty_count += 1
                if empty_count >= self.config.MAX_EMPTY_SEQUENCE:
                    break
            
            current_position += 1
        
        if region_code in self.region_stats:
            self.region_stats[region_code]['found_new'] += found_count
        
        self.log_manager.increment_metric('regions_completed')
        self.logger.info("‚úÖ %s –∑–∞–≤–µ—Ä—à–µ–Ω (–Ω–∞–π–¥–µ–Ω–æ: %d)", region_name, found_count)
    
    async def _process_missing_numbers(
        self,
        page: Page,
        region_code: int,
        region_name: str,
        numbers: List[int],
        worker_id: int
    ):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ø–∏—Å–∫–∞ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –Ω–æ–º–µ—Ä–æ–≤."""
        await page.goto(
            self.config.SEARCH_URL,
            timeout=self.config.PAGE_TIMEOUT,
            wait_until="domcontentloaded"
        )
        
        await page.wait_for_selector(
            'input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]',
            state="visible",
            timeout=10000
        )
        
        found_count = 0
        
        for number in numbers:
            if self.shutdown_event.is_set():
                break
            
            for check_type in [1, 2]:
                reg_num = f"25{region_code}170101{check_type}/{number:05d}"
                
                try:
                    result = await self._try_number_safe(
                        page,
                        reg_num,
                        worker_id,
                        'input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]',
                        "button.btn.btn-primary:has-text('–Ü–∑–¥–µ—É')"
                    )
                    
                    if result:
                        await self.data_queue.put({
                            'data': result,
                            'region_code': region_code
                        })
                        found_count += 1
                        break
                        
                except Exception:
                    pass
        
        if region_code in self.region_stats:
            self.region_stats[region_code]['found_new'] += found_count
        
        self.logger.info(
            "‚úÖ %s: –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ (%d/%d)", 
            region_name, 
            found_count, 
            len(numbers)
        )
    
    async def _try_number_safe(
        self,
        page: Page,
        registration_number: str,
        worker_id: int,
        input_selector: str,
        button_selector: str
    ) -> Optional[Dict]:
        """–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–º–µ—Ä–∞ –ë–ï–ó race conditions."""
        self.log_manager.increment_metric('api_requests')
        
        for attempt in range(1, self.config.MAX_RETRIES + 1):
            try:
                if self.shutdown_event.is_set():
                    return None
                
                await page.wait_for_selector(input_selector, state="visible", timeout=5000)
                
                # –°–ª—É—á–∞–π–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ —á–µ–ª–æ–≤–µ–∫–∞
                await asyncio.sleep(
                    random.uniform(self.config.NATURAL_DELAY_MIN, self.config.NATURAL_DELAY_MAX)
                )

                await page.fill(input_selector, '')
                await page.fill(input_selector, registration_number)

                await asyncio.sleep(
                    random.uniform(self.config.TYPING_DELAY_MIN, self.config.TYPING_DELAY_MAX)
                )
                
                async with self._response_listener(page) as wait_response:
                    await page.click(button_selector)
                    response_data = await wait_response()
                
                if not response_data:
                    if attempt < self.config.MAX_RETRIES:
                        await asyncio.sleep(self.config.RETRY_DELAY)
                        continue
                    return None
                
                is_valid, error_msg = self.api_validator.validate_response(
                    response_data,
                    context=f"W{worker_id}:{registration_number}"
                )
                
                if not is_valid:
                    if self.api_validator.is_critical_error(response_data):
                        self.logger.critical(f"üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê API: {error_msg}")
                        self.shutdown_event.set()
                        return None
                    if attempt < self.config.MAX_RETRIES:
                        await asyncio.sleep(self.config.RETRY_DELAY)
                        continue
                    return None
                
                total_elements = response_data.get("data", {}).get("totalElements", 0)
                if total_elements == 0:
                    return None
                
                processed_data = self.data_processor.process_api_response(response_data)
                if processed_data:
                    self.log_manager.increment_metric('records_processed')
                
                return processed_data
                
            except asyncio.TimeoutError:
                if attempt < self.config.MAX_RETRIES:
                    await asyncio.sleep(self.config.RETRY_DELAY * attempt)
                else:
                    self.log_manager.increment_metric('api_errors')
                    return None
            except Exception as e:
                if self.shutdown_event.is_set():
                    return None
                if attempt < self.config.MAX_RETRIES:
                    await asyncio.sleep(self.config.RETRY_DELAY * attempt)
                else:
                    self.log_manager.increment_metric('api_errors')
                    return None
        
        return None
    
    @asynccontextmanager
    async def _response_listener(self, page: Page):
        """–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π —Ä–∞–±–æ—Ç—ã —Å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞–º–∏."""
        response_future: asyncio.Future[Dict] = asyncio.Future()
        
        async def handle_response(response: Response):
            try:
                if self.config.API_ENDPOINT in response.url and not response_future.done():
                    json_data = await response.json()
                    response_future.set_result(json_data)
            except Exception as e:
                if not response_future.done():
                    response_future.set_exception(e)
        
        page.on("response", handle_response)
        
        async def wait_response():
            try:
                return await asyncio.wait_for(
                    response_future,
                    timeout=self.config.RESPONSE_TIMEOUT
                )
            except:
                return None
        
        try:
            yield wait_response
        finally:
            with suppress(Exception):
                page.remove_listener("response", handle_response)
    
    async def _data_handler(self) -> None:
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—á–µ—Ä–µ–¥–∏ –¥–∞–Ω–Ω—ã—Ö —Å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º."""
        batch = []
        last_save_time = asyncio.get_event_loop().time()
        save_interval = 5.0
        total_saved = 0
        
        self.logger.info(f"üíæ Data handler –∑–∞–ø—É—â–µ–Ω (–±–∞—Ç—á={self.config.BATCH_SIZE})")
        
        while True:
            try:
                current_time = asyncio.get_event_loop().time()
                timeout = max(0.5, save_interval - (current_time - last_save_time))
                
                item = await asyncio.wait_for(self.data_queue.get(), timeout=timeout)
                
                if item is None:
                    self.logger.info("üõë –°–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è data handler")
                    break
                
                batch.append(item['data'])
                
                current_time = asyncio.get_event_loop().time()
                should_save = (
                    len(batch) >= self.config.BATCH_SIZE or
                    (current_time - last_save_time) >= save_interval
                )
                
                if should_save and batch:
                    try:
                        tax, customs = await self.db_manager.bulk_insert_data(batch, silent=True)
                        total_inserted = tax + customs
                        total_saved += total_inserted
                        
                        self.log_manager.increment_metric('db_inserts', total_inserted)
                        
                        if total_inserted > 0:
                            self.logger.info("üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: TAX=%d, CUSTOMS=%d, –≤—Å–µ–≥–æ=%d", tax, customs, total_saved)
                    except Exception as e:
                        self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
                    
                    batch.clear()
                    last_save_time = asyncio.get_event_loop().time()
                
            except asyncio.TimeoutError:
                if batch:
                    try:
                        tax, customs = await self.db_manager.bulk_insert_data(batch, silent=True)
                        total_saved += (tax + customs)
                        self.log_manager.increment_metric('db_inserts', tax + customs)
                        if tax + customs > 0:
                            self.logger.info(f"üíæ –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ: TAX={tax}, CUSTOMS={customs}")
                    except Exception as e:
                        self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
                    batch.clear()
                    last_save_time = asyncio.get_event_loop().time()
            
            except Exception as e:
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ data handler: {e}", exc_info=True)
                if batch:
                    try:
                        tax, customs = await self.db_manager.bulk_insert_data(batch, silent=False)
                        self.logger.info(f"üíæ –ê–≤–∞—Ä–∏–π–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ: {len(batch)} –∑–∞–ø–∏—Å–µ–π")
                    except Exception:
                        self.logger.critical(f"üö® –ü–û–¢–ï–†–Ø –î–ê–ù–ù–´–•: {len(batch)} –∑–∞–ø–∏—Å–µ–π")
                    batch.clear()
        
        # –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        if batch:
            try:
                tax, customs = await self.db_manager.bulk_insert_data(batch, silent=False)
                total_saved += (tax + customs)
                self.logger.info(f"üíæ –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ: TAX={tax}, CUSTOMS={customs}")
            except Exception as e:
                self.logger.critical(f"üö® –ü–û–¢–ï–†–Ø –î–ê–ù–ù–´–•: {len(batch)} –∑–∞–ø–∏—Å–µ–π: {e}")
        
        self.logger.info(f"‚úÖ Data handler –∑–∞–≤–µ—Ä—à–µ–Ω. –í—Å–µ–≥–æ: {total_saved} –∑–∞–ø–∏—Å–µ–π")
    
    async def _print_final_table(self) -> None:
        """–í—ã–≤–æ–¥ –∫—Ä–∞—Å–∏–≤–æ–π –∏—Ç–æ–≥–æ–≤–æ–π —Ç–∞–±–ª–∏—Ü—ã."""
        self.logger.info("")
        self.logger.info("=" * 120)
        self.logger.info("üìä –°–í–û–î–ù–ê–Ø –¢–ê–ë–õ–ò–¶–ê –ü–û –†–ï–ì–ò–û–ù–ê–ú")
        self.logger.info("=" * 120)
        
        header = f"{'–†–µ–≥–∏–æ–Ω':<20} | {'–ó–∞–ø–∏—Å–µ–π':>10} | {'–°–ª–µ–¥. –Ω–æ–º–µ—Ä':>12} | {'–ü—Ä–æ–ø—É—â–µ–Ω–æ':>11} | {'–ù–∞–π–¥–µ–Ω–æ':>10}"
        self.logger.info(header)
        self.logger.info("-" * 120)
        
        total_records = total_missing = total_found = 0
        
        for region_code in sorted(self.config.REGIONS.keys()):
            region_name = self.config.REGIONS[region_code]
            stats = self.region_stats.get(region_code, {
                'total_records': 0,
                'next_number': 1,
                'missing_count': 0,
                'found_new': 0
            })
            
            row = (
                f"{region_name:<20} | {stats['total_records']:>10} | "
                f"{stats['next_number']:>12} | {stats['missing_count']:>11} | "
                f"{stats['found_new']:>10}"
            )
            self.logger.info(row)
            
            total_records += stats['total_records']
            total_missing += stats['missing_count']
            total_found += stats['found_new']
        
        self.logger.info("=" * 120)
        summary = f"{'–ò–¢–û–ì–û':<20} | {total_records:>10} | {'-':>12} | {total_missing:>11} | {total_found:>10}"
        self.logger.info(summary)
        self.logger.info("=" * 120)
        
        metrics = self.log_manager.get_metrics_summary()
        self.logger.info("")
        self.logger.info("üìà –ú–ï–¢–†–ò–ö–ò:")
        self.logger.info(f"   ‚îî‚îÄ –í—Ä–µ–º—è: {metrics['elapsed_seconds']}s")
        self.logger.info(f"   ‚îî‚îÄ API –∑–∞–ø—Ä–æ—Å–æ–≤: {metrics['api_requests']}")
        self.logger.info(f"   ‚îî‚îÄ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {metrics['records_processed']}")
        self.logger.info(f"   ‚îî‚îÄ –°–∫–æ—Ä–æ—Å—Ç—å: {metrics['records_per_second']} –∑–∞–ø/—Å")

def parse_arguments():
    """–ü–∞—Ä—Å–∏–Ω–≥ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏."""
    parser = argparse.ArgumentParser(description='–ü–∞—Ä—Å–µ—Ä QAMQOR')
    parser.add_argument('--missing-only', action='store_true', help='–¢–æ–ª—å–∫–æ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ')
    return parser.parse_args()


async def main():
    """–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞."""
    args = parse_arguments()
    mode = "missing_only" if args.missing_only else "full"
    parser = QamqorParser(mode=mode)
    success = await parser.run()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è –ü—Ä–µ—Ä–≤–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
        sys.exit(1)

================================================================================
FILE: qamqor_updater.py
================================================================================

"""
QAMQOR Updater - –ê–ø–¥–µ–π—Ç–µ—Ä —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∑–∞–ø–∏—Å–µ–π.
–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –æ—Å–Ω–æ–≤–Ω—ã–º –ø–∞—Ä—Å–µ—Ä–æ–º.
"""

import asyncio
import argparse
import signal
import sys
import random
from datetime import datetime, timedelta
from types import FrameType
from typing import Any, Dict, List, Optional
from contextlib import asynccontextmanager, suppress
from signal import Signals

from playwright.async_api import async_playwright, Page, Response

from .core import (
    Config,
    DatabaseManager,
    DataProcessor,
    APIValidator,
    WebClient,
    StealthTabManager,
    LogManager,
    apply_stealth
)

class QamqorUpdater:
    """–ê–ø–¥–µ–π—Ç–µ—Ä —Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–µ–π –ø–∞—Ä—Å–µ—Ä–∞."""
    
    def __init__(
        self, 
        force: bool = False, 
        statuses: Optional[List[str]] = None,
        single_number: Optional[str] = None  # ‚úÖ –ù–æ–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
    ) -> None:
        self.config = Config()
        self.log_manager = LogManager(self.config, name="qamqor_updater")
        self.logger = self.log_manager.logger
        
        self.db_manager = DatabaseManager(self.config, self.logger)
        self.data_processor = DataProcessor(self.config, self.logger)
        self.api_validator = APIValidator(self.logger)
        self.web_client = WebClient(self.config, self.logger, self.api_validator)
        
        self.force = force
        self.statuses = statuses or self.config.UPDATE_STATUSES
        self.single_number = single_number  # ‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–º–µ—Ä
        
        # ... –æ—Å—Ç–∞–ª—å–Ω–æ–µ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
        
        self.update_queue: asyncio.Queue = asyncio.Queue()
        self.data_queue: asyncio.Queue = asyncio.Queue()
        self.shutdown_event = asyncio.Event()
        self.active_workers: List[asyncio.Task] = []
        
        self.stats = {
            'total_to_update': 0,
            'processed': 0,
            'updated': 0,
            'unchanged': 0,
            'not_found': 0,
            'errors': 0
        }
        
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum: Signals, frame: Optional[FrameType]) -> None:
        self.logger.warning(f"‚ö†Ô∏è –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª {signum}")
        self.shutdown_event.set()
    
    async def _graceful_shutdown(self, timeout: float = 30.0):
        """–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ."""
        if not self.active_workers:
            return
        
        self.logger.warning(f"‚ö†Ô∏è Graceful shutdown: {len(self.active_workers)} –≤–æ—Ä–∫–µ—Ä–æ–≤...")
        self.shutdown_event.set()
        
        try:
            await asyncio.wait_for(
                asyncio.gather(*self.active_workers, return_exceptions=True),
                timeout=timeout
            )
            self.logger.info("‚úÖ –í—Å–µ –≤–æ—Ä–∫–µ—Ä—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã")
        except asyncio.TimeoutError:
            self.logger.warning(f"‚ö†Ô∏è –¢–∞–π–º–∞—É—Ç {timeout}s, –æ—Ç–º–µ–Ω–∞ –∑–∞–¥–∞—á...")
            for task in self.active_workers:
                if not task.done():
                    task.cancel()
            await asyncio.gather(*self.active_workers, return_exceptions=True)
        finally:
            self.active_workers.clear()
    
    async def run(self) -> bool:
        """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è."""
        try:
            self.logger.info("=" * 80)
            self.logger.info("üîÑ –ó–ê–ü–£–°–ö –ê–ü–î–ï–ô–¢–ï–†–ê QAMQOR")
            self.logger.info("=" * 80)
            
            await self.db_manager.initialize_tables()
            
            # –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –Ω–æ–º–µ—Ä
            if self.single_number:
                self.logger.info("üéØ –†–µ–∂–∏–º: –û–ë–ù–û–í–õ–ï–ù–ò–ï –û–î–ù–û–ì–û –ù–û–ú–ï–†–ê")
                self.logger.info(f"   –ù–æ–º–µ—Ä: {self.single_number}")
                
                try:
                    check_type = self.single_number[15]
                    
                    if check_type == '1':
                        records = {'tax': [self.single_number], 'customs': []}
                        self.logger.info("   –¢–∏–ø: üìä –ù–∞–ª–æ–≥–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (TAX)")
                    elif check_type == '2':
                        records = {'tax': [], 'customs': [self.single_number]}
                        self.logger.info("   –¢–∏–ø: üö¢ –¢–∞–º–æ–∂–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (CUSTOMS)")
                    else:
                        self.logger.error(f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø –ø—Ä–æ–≤–µ—Ä–∫–∏: '{check_type}'")
                        return False
                        
                except (IndexError, ValueError) as e:
                    self.logger.error(f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞: {e}")
                    return False
                
                total = 1
                self.stats['total_to_update'] = total
            else:
                # –ú–∞—Å—Å–æ–≤–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
                self.logger.info("üìä –ö—Ä–∏—Ç–µ—Ä–∏–∏ –æ—Ç–±–æ—Ä–∞:")
                self.logger.info(f"   ‚îú‚îÄ –°—Ç–∞—Ç—É—Å—ã: {self.statuses}")
                self.logger.info(f"   ‚îú‚îÄ –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç: {self.config.UPDATE_MIN_AGE_DAYS} –¥–Ω–µ–π")
                self.logger.info(f"   ‚îú‚îÄ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç: {self.config.UPDATE_MAX_AGE_DAYS} –¥–Ω–µ–π")  # ‚¨ÖÔ∏è –ù–û–í–û–ï
                self.logger.info(f"   ‚îú‚îÄ Cooldown: {self.config.UPDATE_COOLDOWN_DAYS} –¥–Ω–µ–π")
                self.logger.info(f"   ‚îî‚îÄ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ: {'–î–∞' if self.force else '–ù–µ—Ç'}")
                
                records = await self.db_manager.get_records_to_update(
                    statuses=self.statuses,
                    force=self.force
                    # ‚¨ÖÔ∏è max_age_days –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —á–µ—Ä–µ–∑ Config
                )
                
                total = len(records['tax']) + len(records['customs'])
                self.stats['total_to_update'] = total
                
                if total > 0:
                    self.logger.info("")
                    self.logger.info("üìã –ù–∞–π–¥–µ–Ω–æ –∑–∞–ø–∏—Å–µ–π:")
                    self.logger.info(f"   ‚îú‚îÄ TAX: {len(records['tax'])}")
                    self.logger.info(f"   ‚îú‚îÄ CUSTOMS: {len(records['customs'])}")
                    self.logger.info(f"   ‚îî‚îÄ –í–°–ï–ì–û: {total}")
            
            if total == 0:
                self.logger.info("‚úÖ –ù–µ—Ç –∑–∞–ø–∏—Å–µ–π –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è")
                return True
            
            self.logger.info("")
            await self._run_update_process(records)
            await self._print_update_summary()
            
            self.logger.info("=" * 80)
            self.logger.info("‚úÖ –û–ë–ù–û–í–õ–ï–ù–ò–ï –ó–ê–í–ï–†–®–ï–ù–û")
            self.logger.info("=" * 80)
            return True
            
        except KeyboardInterrupt:
            self.logger.warning("‚ö†Ô∏è –ü—Ä–µ—Ä–≤–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
            return False
        except Exception as e:
            self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}", exc_info=True)
            return False
    
    async def _run_update_process(self, records: Dict[str, List[str]]):
        """–ü—Ä–æ—Ü–µ—Å—Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è."""
        all_numbers = records['tax'] + records['customs']
        
        # ‚úÖ –í–ê–ñ–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –µ—Å—Ç—å –Ω–æ–º–µ—Ä–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        if not all_numbers:
            self.logger.warning("‚ö†Ô∏è –ù–µ—Ç –Ω–æ–º–µ—Ä–æ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏")
            return
        
        async with async_playwright() as playwright:
            self.logger.info("üîß –ó–∞–ø—É—Å–∫ –±—Ä–∞—É–∑–µ—Ä–∞...")
            browser = await playwright.chromium.launch(
                headless=True,
                args=[
                    "--disable-blink-features=AutomationControlled",
                    "--disable-dev-shm-usage",
                    "--no-sandbox",
                    "--disable-gpu",
                    "--disable-software-rasterizer"
                ]
            )
            
            context = await browser.new_context(
                viewport={"width": 1920, "height": 1080},
                user_agent=(
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                    "AppleWebKit/537.36 (KHTML, like Gecko) "
                    "Chrome/120.0.0.0 Safari/537.36"
                ),
                locale="ru-RU,ru",
                timezone_id="Asia/Almaty",
                extra_http_headers={
                    "Accept-Language": "ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7",
                    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
                }
            )
            
            # Health check
            self.logger.info("üè• Health Check...")
            health_page = await context.new_page()
            
            await apply_stealth(health_page)
            
            try:
                await health_page.goto(
                    self.config.SEARCH_URL,
                    wait_until="domcontentloaded",
                    timeout=self.config.PAGE_TIMEOUT
                )
                
                await health_page.wait_for_selector(
                    'input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]',
                    state="visible",
                    timeout=10000
                )
                
                if not await self.web_client.check_api_health_with_page(health_page):
                    self.logger.error("‚ùå API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
                    return
                
                self.logger.info("‚úÖ Health Check –ø—Ä–æ–π–¥–µ–Ω")
                
            finally:
                await health_page.close()
            
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è TabManager —Å–æ stealth
            tab_manager = StealthTabManager(context, self.config, self.logger)
            await tab_manager.initialize()
            
            # –ó–∞–ø—É—Å–∫ data handler
            data_handler_task = asyncio.create_task(
                self._update_data_handler(),
                name="update_data_handler"
            )
            
            # ‚úÖ –ö–†–ò–¢–ò–ß–ù–û: –ó–∞–ø–æ–ª–Ω—è–µ–º –æ—á–µ—Ä–µ–¥—å –Ω–æ–º–µ—Ä–∞–º–∏ –î–û –∑–∞–ø—É—Å–∫–∞ –≤–æ—Ä–∫–µ—Ä–æ–≤
            self.logger.info(f"üìã –î–æ–±–∞–≤–ª–µ–Ω–∏–µ {len(all_numbers)} –Ω–æ–º–µ—Ä–æ–≤ –≤ –æ—á–µ—Ä–µ–¥—å...")
            for reg_num in all_numbers:
                await self.update_queue.put(reg_num)
            self.logger.info(f"‚úÖ –û—á–µ—Ä–µ–¥—å –∑–∞–ø–æ–ª–Ω–µ–Ω–∞: {self.update_queue.qsize()} –Ω–æ–º–µ—Ä–æ–≤")
            
            # –ó–∞–ø—É—Å–∫ –≤–æ—Ä–∫–µ—Ä–æ–≤
            self.active_workers = [
                asyncio.create_task(
                    self._update_worker(worker_id, tab_manager),
                    name=f"update_worker_{worker_id}"
                )
                for worker_id in range(self.config.MAX_CONCURRENT_TABS)
            ]
            
            self.logger.info("üë∑ –ó–∞–ø—É—â–µ–Ω–æ %d –≤–æ—Ä–∫–µ—Ä–æ–≤", len(self.active_workers))
            
            try:
                await asyncio.gather(*self.active_workers, return_exceptions=True)
                
                if self.shutdown_event.is_set():
                    await self._graceful_shutdown(timeout=30.0)
                    
            except KeyboardInterrupt:
                await self._graceful_shutdown(timeout=30.0)
                
            finally:
                try:
                    self.logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ data handler...")
                    await self.data_queue.put(None)
                    await asyncio.wait_for(data_handler_task, timeout=15.0)
                    self.logger.info("‚úÖ Data handler –∑–∞–≤–µ—Ä—à–µ–Ω")
                except asyncio.TimeoutError:
                    self.logger.warning("‚ö†Ô∏è –¢–∞–π–º–∞—É—Ç data_handler (15s)")
                    data_handler_task.cancel()
                    try:
                        await data_handler_task
                    except asyncio.CancelledError:
                        pass
                
                await tab_manager.close_all()
                await browser.close()
                self.logger.info("üîí –ë—Ä–∞—É–∑–µ—Ä –∑–∞–∫—Ä—ã—Ç")
    
    async def _update_worker(
        self, 
        worker_id: int, 
        tab_manager: StealthTabManager
    ) -> None:
        """–í–æ—Ä–∫–µ—Ä –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è."""
        self.logger.debug(f"‚úÖ UW{worker_id} –∑–∞–ø—É—â–µ–Ω")
        
        async with tab_manager.get_tab() as page:
            await page.goto(
                self.config.SEARCH_URL,
                wait_until="domcontentloaded",
                timeout=self.config.PAGE_TIMEOUT
            )
            
            await page.wait_for_selector(
                'input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]',
                state="visible",
                timeout=10000
            )
            
            # ‚úÖ –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê
            self.logger.info(f"üîç UW{worker_id}: –û—á–µ—Ä–µ–¥—å —Å–æ–¥–µ—Ä–∂–∏—Ç {self.update_queue.qsize()} –Ω–æ–º–µ—Ä–æ–≤")
            
            while not self.shutdown_event.is_set():
                try:
                    reg_num = await asyncio.wait_for(
                        self.update_queue.get(),
                        timeout=1.0
                    )
                    
                    # ‚úÖ –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê
                    self.logger.info(f"üîç UW{worker_id}: –ü–æ–ª—É—á–µ–Ω –Ω–æ–º–µ—Ä {reg_num}")
                    
                except asyncio.TimeoutError:
                    if self.update_queue.empty():
                        self.logger.debug(f"‚úÖ UW{worker_id}: –û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ")
                        break
                    continue
                except asyncio.CancelledError:
                    break
                
                try:
                    # ‚úÖ –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê
                    self.logger.info(f"üîç UW{worker_id}: –ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏ {reg_num}")
                    
                    result = await self._fetch_record_data(page, reg_num, worker_id)
                    if result:
                        await self.data_queue.put({'type': 'data', 'data': result})
                        self.stats['processed'] += 1
                        self.logger.info(f"‚úÖ UW{worker_id}: {reg_num} –æ–±—Ä–∞–±–æ—Ç–∞–Ω")
                    else:
                        self.stats['not_found'] += 1
                        self.logger.warning(f"‚ö†Ô∏è UW{worker_id}: {reg_num} –Ω–µ –Ω–∞–π–¥–µ–Ω")
                except Exception as e:
                    self.stats['errors'] += 1
                    self.logger.error("‚ùå UW%d | %s: %s", worker_id, reg_num, e, exc_info=True)
                finally:
                    self.update_queue.task_done()
        
        self.logger.debug(f"‚úÖ UW{worker_id} –∑–∞–≤–µ—Ä—à–µ–Ω")
    
    async def _fetch_record_data(
        self,
        page: Page,
        registration_number: str,
        worker_id: int
    ) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–∏."""
        self.log_manager.increment_metric('api_requests')
        
        for attempt in range(1, self.config.MAX_RETRIES + 1):
            try:
                if self.shutdown_event.is_set():
                    return None
                
                await page.wait_for_selector(
                    'input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]',
                    state="visible",
                    timeout=5000
                )
                
                # –°–ª—É—á–∞–π–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ —á–µ–ª–æ–≤–µ–∫–∞
                await asyncio.sleep(
                    random.uniform(self.config.NATURAL_DELAY_MIN, self.config.NATURAL_DELAY_MAX)
                )

                await page.fill('input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]', '')
                await page.fill('input[placeholder="–¢–µ–∫—Å–µ—Ä—É/ —Ç—ñ—Ä–∫–µ—É –Ω”©–º—ñ—Ä—ñ"]', registration_number)

                await asyncio.sleep(
                    random.uniform(self.config.TYPING_DELAY_MIN, self.config.TYPING_DELAY_MAX)
                )
                
                async with self._response_listener(page) as wait_response:
                    await page.click("button.btn.btn-primary:has-text('–Ü–∑–¥–µ—É')")
                    response_data = await wait_response()
                
                if not response_data:
                    if attempt < self.config.MAX_RETRIES:
                        await asyncio.sleep(self.config.RETRY_DELAY)
                        continue
                    return None
                
                is_valid, error_msg = self.api_validator.validate_response(
                    response_data,
                    context=f"UW{worker_id}:{registration_number}"
                )
                
                if not is_valid:
                    if self.api_validator.is_critical_error(response_data):
                        self.logger.critical(f"üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê API: {error_msg}")
                        self.shutdown_event.set()
                        return None
                    if attempt < self.config.MAX_RETRIES:
                        await asyncio.sleep(self.config.RETRY_DELAY)
                        continue
                    return None
                
                if response_data.get("data", {}).get("totalElements", 0) == 0:
                    return None
                
                processed = self.data_processor.process_api_response(response_data)
                if processed:
                    self.log_manager.increment_metric('records_processed')
                return processed
                
            except asyncio.TimeoutError:
                if attempt < self.config.MAX_RETRIES:
                    await asyncio.sleep(self.config.RETRY_DELAY * attempt)
                else:
                    self.log_manager.increment_metric('api_errors')
                    return None
            except Exception as e:
                if self.shutdown_event.is_set():
                    return None
                if attempt < self.config.MAX_RETRIES:
                    await asyncio.sleep(self.config.RETRY_DELAY * attempt)
                else:
                    self.log_manager.increment_metric('api_errors')
                    return None
        
        return None
    
    @asynccontextmanager
    async def _response_listener(self, page: Page):
        """–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞."""
        response_future: asyncio.Future[Dict] = asyncio.Future()
        
        async def handle_response(response: Response):
            try:
                if self.config.API_ENDPOINT in response.url and not response_future.done():
                    json_data = await response.json()
                    response_future.set_result(json_data)
            except Exception as e:
                if not response_future.done():
                    response_future.set_exception(e)
        
        page.on("response", handle_response)
        
        async def wait_response():
            try:
                return await asyncio.wait_for(
                    response_future,
                    timeout=self.config.RESPONSE_TIMEOUT
                )
            except:
                return None
        
        try:
            yield wait_response
        finally:
            with suppress(Exception):
                page.remove_listener("response", handle_response)
    
    async def _update_data_handler(self) -> None:
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–∞–Ω–Ω—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è."""
        batch = []
        last_save_time = asyncio.get_event_loop().time()
        save_interval = 5.0
        total_saved = 0
        
        self.logger.info(f"üíæ Update data handler –∑–∞–ø—É—â–µ–Ω (–±–∞—Ç—á={self.config.UPDATE_BATCH_SIZE})")
        
        while True:
            try:
                current_time = asyncio.get_event_loop().time()
                timeout = max(0.5, save_interval - (current_time - last_save_time))
                
                item = await asyncio.wait_for(self.data_queue.get(), timeout=timeout)
                
                if item is None:
                    self.logger.info("üõë –°–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è update data handler")
                    break
                
                if isinstance(item, dict) and item.get('type') == 'data':
                    batch.append(item['data'])
                
                current_time = asyncio.get_event_loop().time()
                should_save = (
                    len(batch) >= self.config.UPDATE_BATCH_SIZE or
                    (current_time - last_save_time) >= save_interval
                )
                
                if should_save and batch:
                    try:
                        tax, customs, changes = await self.db_manager.bulk_update_data(batch, silent=True)
                        total = tax + customs
                        self.stats['updated'] += total
                        self.stats['unchanged'] += len(batch) - total
                        total_saved += total
                        
                        self.log_manager.increment_metric('db_updates', total)
                        
                        if total > 0:
                            self.logger.info("üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–æ: TAX=%d, CUSTOMS=%d, –≤—Å–µ–≥–æ=%d", tax, customs, total_saved)
                    except Exception as e:
                        self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {e}")
                    
                    batch.clear()
                    last_save_time = asyncio.get_event_loop().time()
                    
            except asyncio.TimeoutError:
                if batch:
                    try:
                        tax, customs, changes = await self.db_manager.bulk_update_data(batch, silent=True)
                        total = tax + customs
                        self.stats['updated'] += total
                        self.stats['unchanged'] += len(batch) - total
                        total_saved += total
                        
                        self.log_manager.increment_metric('db_updates', total)
                        
                        if total > 0:
                            self.logger.info(f"üîÑ –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: TAX={tax}, CUSTOMS={customs}")
                    except Exception as e:
                        self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {e}")
                    
                    batch.clear()
                    last_save_time = asyncio.get_event_loop().time()
            
            except Exception as e:
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ update data handler: {e}", exc_info=True)
                if batch:
                    try:
                        tax, customs, changes = await self.db_manager.bulk_update_data(batch, silent=False)
                        self.logger.info(f"üíæ –ê–≤–∞—Ä–∏–π–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {len(batch)} –∑–∞–ø–∏—Å–µ–π")
                    except Exception:
                        self.logger.critical(f"üö® –ü–û–¢–ï–†–Ø –î–ê–ù–ù–´–•: {len(batch)} –∑–∞–ø–∏—Å–µ–π")
                    batch.clear()
        
        # –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        if batch:
            try:
                tax, customs, changes = await self.db_manager.bulk_update_data(batch, silent=False)
                total = tax + customs
                total_saved += total
                self.stats['updated'] += total
                self.stats['unchanged'] += len(batch) - total
                self.logger.info(f"üíæ –§–∏–Ω–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: TAX={tax}, CUSTOMS={customs}")
            except Exception as e:
                self.logger.critical(f"üö® –ü–û–¢–ï–†–Ø –î–ê–ù–ù–´–•: {len(batch)} –∑–∞–ø–∏—Å–µ–π: {e}")
        
        self.logger.info(f"‚úÖ Update data handler –∑–∞–≤–µ—Ä—à–µ–Ω. –í—Å–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ: {total_saved}")
    
    async def _print_update_summary(self) -> None:
        """–ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞."""
        self.logger.info("")
        self.logger.info("=" * 80)
        self.logger.info("üìä –†–ï–ó–£–õ–¨–¢–ê–¢–´ –û–ë–ù–û–í–õ–ï–ù–ò–Ø")
        self.logger.info("=" * 80)
        self.logger.info(f"üìã –í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π: {self.stats['total_to_update']}")
        self.logger.info(f"   ‚îú‚îÄ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {self.stats['processed']}")
        self.logger.info(f"   ‚îú‚îÄ –û–±–Ω–æ–≤–ª–µ–Ω–æ: {self.stats['updated']}")
        self.logger.info(f"   ‚îú‚îÄ –ë–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π: {self.stats['unchanged']}")
        self.logger.info(f"   ‚îú‚îÄ –ù–µ –Ω–∞–π–¥–µ–Ω–æ: {self.stats['not_found']}")
        self.logger.info(f"   ‚îî‚îÄ –û—à–∏–±–æ–∫: {self.stats['errors']}")
        self.logger.info("=" * 80)
        
        metrics = self.log_manager.get_metrics_summary()
        self.logger.info("")
        self.logger.info("üìà –ú–ï–¢–†–ò–ö–ò:")
        self.logger.info(f"   ‚îî‚îÄ –í—Ä–µ–º—è: {metrics['elapsed_seconds']}s")
        self.logger.info(f"   ‚îî‚îÄ API –∑–∞–ø—Ä–æ—Å–æ–≤: {metrics['api_requests']}")
        self.logger.info(f"   ‚îî‚îÄ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {metrics['records_processed']}")
        self.logger.info(f"   ‚îî‚îÄ –°–∫–æ—Ä–æ—Å—Ç—å: {metrics['records_per_second']} –∑–∞–ø/—Å")


def parse_arguments():
    """–ü–∞—Ä—Å–∏–Ω–≥ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤."""
    parser = argparse.ArgumentParser(
        description='–ê–ø–¥–µ–π—Ç–µ—Ä QAMQOR',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
–ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:
  # –û–±–Ω–æ–≤–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –Ω–æ–º–µ—Ä
  python -m parsers.qamqor.qamqor_updater --number "251000000170101/00123"
  
  # –ú–∞—Å—Å–æ–≤–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ —Å—Ç–∞—Ç—É—Å—É "1"
  python -m parsers.qamqor.qamqor_updater --status "1"
  
  # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö
  python -m parsers.qamqor.qamqor_updater --force
        """
    )
    
    parser.add_argument(
        '--number',
        type=str,
        help='–û–±–Ω–æ–≤–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –Ω–æ–º–µ—Ä (–ø—Ä–∏–º–µ—Ä: 251000000170101/00123)'
    )
    parser.add_argument(
        '--force',
        action='store_true',
        help='–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –∑–∞–ø–∏—Å–µ–π (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç —Ñ–∏–ª—å—Ç—Ä—ã)'
    )
    parser.add_argument(
        '--status',
        type=str,
        help='–°—Ç–∞—Ç—É—Å—ã –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: "1")'
    )
    
    return parser.parse_args()


async def main():
    """–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞."""
    args = parse_arguments()
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è
    if args.number and (args.status or args.force):
        print("‚ùå --number –Ω–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å --status –∏–ª–∏ --force")
        sys.exit(1)
    
    # ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ –Ω–æ–º–µ—Ä–∞
    if args.number:
        import re
        # –§–æ—Ä–º–∞—Ç: 25 + 7 —Ü–∏—Ñ—Ä (—Ä–µ–≥–∏–æ–Ω) + 170101 + —Ç–∏–ø (1 –∏–ª–∏ 2) + / + 5 —Ü–∏—Ñ—Ä
        pattern = r'^25\d{7}170101[12]/\d{5}$'
        if not re.match(pattern, args.number):
            print(f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞: {args.number}")
            print("   –û–∂–∏–¥–∞–µ—Ç—Å—è: 25RRRRRRR170101T/SSSSS")
            print("   –ì–¥–µ:")
            print("     RRRRRRR = –∫–æ–¥ —Ä–µ–≥–∏–æ–Ω–∞ (7 —Ü–∏—Ñ—Ä)")
            print("     T       = —Ç–∏–ø –ø—Ä–æ–≤–µ—Ä–∫–∏ (1=–Ω–∞–ª–æ–≥–æ–≤–∞—è, 2=—Ç–∞–º–æ–∂–µ–Ω–Ω–∞—è)")
            print("     SSSSS   = –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä (5 —Ü–∏—Ñ—Ä)")
            print("")
            print("   –ü—Ä–∏–º–µ—Ä: 2575000001701012/01598")
            sys.exit(1)
        
        # ‚úÖ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –≤ –ë–î
        check_type = args.number[12]
        table = 'qamqor_tax' if check_type == '1' else 'qamqor_customs'
        
        print(f"‚ÑπÔ∏è  –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–æ–º–µ—Ä–∞ –≤ —Ç–∞–±–ª–∏—Ü–µ {table}...")
    
    statuses = [s.strip() for s in args.status.split(',')] if args.status else None
    
    updater = QamqorUpdater(
        force=args.force,
        statuses=statuses,
        single_number=args.number
    )
    
    success = await updater.run()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è –ü—Ä–µ—Ä–≤–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
        sys.exit(1)

================================================================================
END OF CODE
================================================================================
